From 89ec7671a89f87e2d66309ddf544cf20891ab62a Mon Sep 17 00:00:00 2001
From: balbes150 <balbes-150@yandex.ru>
Date: Thu, 6 Apr 2023 13:55:20 +0300
Subject: [PATCH] 5

Signed-off-by: balbes150 <balbes-150@yandex.ru>
---
 drivers/clk/rockchip/Kconfig                  |    8 +-
 drivers/clk/rockchip/Makefile                 |    2 +
 drivers/clk/rockchip/clk-link.c               |  229 ++
 drivers/clk/rockchip/clk-pll.c                |   87 +-
 drivers/clk/rockchip/clk-rk3399.c             |    2 +-
 drivers/clk/rockchip/clk-rk3568.c             |   35 +-
 drivers/clk/rockchip/clk-rk3588.c             |   11 +-
 drivers/clk/rockchip/clk.h                    |    3 +
 drivers/nvmem/rockchip-otp.c                  |  734 ++++-
 drivers/pci/controller/dwc/pcie-dw-rockchip.c |    1 +
 drivers/phy/rockchip/phy-rockchip-inno-usb2.c | 2907 ++++++++++++++---
 .../rockchip/phy-rockchip-naneng-combphy.c    |  184 ++
 .../phy/rockchip/phy-rockchip-snps-pcie3.c    |    2 +-
 drivers/pinctrl/Kconfig                       |    9 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/pinctrl-rk806.c               |  577 ++++
 drivers/regulator/Kconfig                     |   19 +
 drivers/regulator/Makefile                    |    2 +
 drivers/regulator/rk806-regulator.c           | 1210 +++++++
 drivers/regulator/rk860x-regulator.c          |  607 ++++
 drivers/soc/rockchip/Kconfig                  |    6 +
 drivers/soc/rockchip/Makefile                 |    1 +
 drivers/soc/rockchip/pm_domains.c             |  156 +-
 drivers/soc/rockchip/rockchip_opp_select.c    | 1595 +++++++++
 .../dt-bindings/clock/rockchip,rk3588-cru.h   |    3 +-
 include/dt-bindings/display/rockchip_vop.h    |   21 +
 .../dt-bindings/soc/rockchip-system-status.h  |   48 +
 include/linux/phy/phy-rockchip-usbdp.h        |   70 +
 include/linux/soc/rockchip/cpu.h              |  244 ++
 include/linux/soc/rockchip/grf.h              |  700 ++++
 include/linux/soc/rockchip/psci.h             |   76 +
 include/linux/soc/rockchip/pvtm.h             |   17 +
 include/linux/soc/rockchip/rockchip_sip.h     |  467 +++
 include/soc/rockchip/rockchip-system-status.h |   53 +
 include/soc/rockchip/rockchip_dmc.h           |  121 +
 include/soc/rockchip/rockchip_ipa.h           |   40 +
 include/soc/rockchip/rockchip_opp_select.h    |  218 ++
 .../soc/rockchip/rockchip_system_monitor.h    |  213 ++
 kernel/dma/pool.c                             |    8 +-
 sound/soc/rockchip/rockchip_i2s.c             |    1 +
 40 files changed, 10198 insertions(+), 490 deletions(-)
 create mode 100644 drivers/clk/rockchip/clk-link.c
 create mode 100644 drivers/pinctrl/pinctrl-rk806.c
 create mode 100644 drivers/regulator/rk806-regulator.c
 create mode 100644 drivers/regulator/rk860x-regulator.c
 create mode 100644 drivers/soc/rockchip/rockchip_opp_select.c
 create mode 100644 include/dt-bindings/display/rockchip_vop.h
 create mode 100644 include/dt-bindings/soc/rockchip-system-status.h
 create mode 100644 include/linux/phy/phy-rockchip-usbdp.h
 create mode 100644 include/linux/soc/rockchip/cpu.h
 create mode 100644 include/linux/soc/rockchip/grf.h
 create mode 100644 include/linux/soc/rockchip/psci.h
 create mode 100644 include/linux/soc/rockchip/pvtm.h
 create mode 100644 include/linux/soc/rockchip/rockchip_sip.h
 create mode 100644 include/soc/rockchip/rockchip-system-status.h
 create mode 100644 include/soc/rockchip/rockchip_dmc.h
 create mode 100644 include/soc/rockchip/rockchip_ipa.h
 create mode 100644 include/soc/rockchip/rockchip_opp_select.h
 create mode 100644 include/soc/rockchip/rockchip_system_monitor.h

diff --git a/drivers/clk/rockchip/Kconfig b/drivers/clk/rockchip/Kconfig
index 9aad86925cd..99a264179b3 100644
--- a/drivers/clk/rockchip/Kconfig
+++ b/drivers/clk/rockchip/Kconfig
@@ -101,10 +101,16 @@ config CLK_RK3568
 	  Build the driver for RK3568 Clock Driver.
 
 config CLK_RK3588
-	bool "Rockchip RK3588 clock controller support"
+	tristate "Rockchip RK3588 clock controller support"
 	depends on ARM64 || COMPILE_TEST
 	default y
 	help
 	  Build the driver for RK3588 Clock Driver.
 
+config ROCKCHIP_CLK_LINK
+	tristate "Rockchip clock link support"
+	default CLK_RK3588
+	help
+	  Say y here to enable clock link for Rockchip.
+
 endif
diff --git a/drivers/clk/rockchip/Makefile b/drivers/clk/rockchip/Makefile
index 36894f6a702..af126082739 100644
--- a/drivers/clk/rockchip/Makefile
+++ b/drivers/clk/rockchip/Makefile
@@ -15,6 +15,8 @@ clk-rockchip-y += clk-muxgrf.o
 clk-rockchip-y += clk-ddr.o
 clk-rockchip-$(CONFIG_RESET_CONTROLLER) += softrst.o
 
+obj-$(CONFIG_ROCKCHIP_CLK_LINK)	+= clk-link.o
+
 obj-$(CONFIG_CLK_PX30)          += clk-px30.o
 obj-$(CONFIG_CLK_RV110X)        += clk-rv1108.o
 obj-$(CONFIG_CLK_RV1126)        += clk-rv1126.o
diff --git a/drivers/clk/rockchip/clk-link.c b/drivers/clk/rockchip/clk-link.c
new file mode 100644
index 00000000000..9edcb9d81f5
--- /dev/null
+++ b/drivers/clk/rockchip/clk-link.c
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_clock.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+
+struct rockchip_link_info {
+	u32 shift;
+	const char *name;
+	const char *pname;
+};
+
+struct rockchip_link {
+	int num;
+	const struct rockchip_link_info *info;
+};
+
+struct rockchip_link_clk {
+	void __iomem *base;
+	struct clk_gate *gate;
+	spinlock_t lock;
+	u32 shift;
+	u32 flag;
+	const char *name;
+	const char *pname;
+	const char *link_name;
+	const struct rockchip_link *link;
+};
+
+#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
+
+#define GATE_LINK(_name, _pname, _shift)	\
+{						\
+	.name = _name,				\
+	.pname = _pname,			\
+	.shift = (_shift),			\
+}
+
+static int register_clocks(struct rockchip_link_clk *priv, struct device *dev)
+{
+	struct clk_gate *gate;
+	struct clk_init_data init = {};
+	struct clk *clk;
+
+	gate = devm_kzalloc(dev, sizeof(struct clk_gate), GFP_KERNEL);
+	if (!gate)
+		return -ENOMEM;
+
+	init.name = priv->name;
+	init.ops = &clk_gate_ops;
+	init.flags |= CLK_SET_RATE_PARENT;
+	init.parent_names = &priv->pname;
+	init.num_parents = 1;
+
+	/* struct clk_gate assignments */
+	gate->reg = priv->base;
+	gate->bit_idx = priv->shift;
+	gate->flags = GFLAGS;
+	gate->lock = &priv->lock;
+	gate->hw.init = &init;
+
+	clk = devm_clk_register(dev, &gate->hw);
+	if (IS_ERR(clk)) {
+		dev_err(dev, "devm_clk_register failed: %ld\n", PTR_ERR(clk));
+		devm_kfree(dev, gate);
+		return -EINVAL;
+	}
+
+	return of_clk_add_provider(dev->of_node, of_clk_src_simple_get, clk);
+}
+
+static const struct rockchip_link_info rk3588_clk_gate_link_info[] = {
+	GATE_LINK("aclk_isp1_pre", "aclk_isp1_root", 6),
+	GATE_LINK("hclk_isp1_pre", "hclk_isp1_root", 8),
+	GATE_LINK("hclk_nvm", "hclk_nvm_root", 2),
+	GATE_LINK("aclk_usb", "aclk_usb_root", 2),
+	GATE_LINK("hclk_usb", "hclk_usb_root", 3),
+	GATE_LINK("aclk_jpeg_decoder_pre", "aclk_jpeg_decoder_root", 7),
+	GATE_LINK("aclk_vdpu_low_pre", "aclk_vdpu_low_root", 5),
+	GATE_LINK("aclk_rkvenc1_pre", "aclk_rkvenc1_root", 3),
+	GATE_LINK("hclk_rkvenc1_pre", "hclk_rkvenc1_root", 2),
+	GATE_LINK("hclk_rkvdec0_pre", "hclk_rkvdec0_root", 5),
+	GATE_LINK("aclk_rkvdec0_pre", "aclk_rkvdec0_root", 6),
+	GATE_LINK("hclk_rkvdec1_pre", "hclk_rkvdec1_root", 4),
+	GATE_LINK("aclk_rkvdec1_pre", "aclk_rkvdec1_root", 5),
+	GATE_LINK("aclk_hdcp0_pre", "aclk_vo0_root", 9),
+	GATE_LINK("hclk_vo0", "hclk_vo0_root", 5),
+	GATE_LINK("aclk_hdcp1_pre", "aclk_hdcp1_root", 6),
+	GATE_LINK("hclk_vo1", "hclk_vo1_root", 9),
+	GATE_LINK("aclk_av1_pre", "aclk_av1_root", 1),
+	GATE_LINK("pclk_av1_pre", "pclk_av1_root", 4),
+	GATE_LINK("hclk_sdio_pre", "hclk_sdio_root", 1),
+	GATE_LINK("pclk_vo0_grf", "pclk_vo0_root", 10),
+	GATE_LINK("pclk_vo1_grf", "pclk_vo1_root", 12),
+};
+
+static const struct rockchip_link rk3588_clk_gate_link = {
+	.num = ARRAY_SIZE(rk3588_clk_gate_link_info),
+	.info = rk3588_clk_gate_link_info,
+};
+
+static const struct of_device_id rockchip_clk_link_of_match[] = {
+	{
+		.compatible = "rockchip,rk3588-clock-gate-link",
+		.data = (void *)&rk3588_clk_gate_link,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, rockchip_clk_link_of_match);
+
+static const struct rockchip_link_info *
+rockchip_get_link_infos(const struct rockchip_link *link, const char *name)
+{
+	const struct rockchip_link_info *info = link->info;
+	int i = 0;
+
+	for (i = 0; i < link->num; i++) {
+		if (strcmp(info->name, name) == 0)
+			break;
+		info++;
+	}
+	return info;
+}
+
+static int rockchip_clk_link_probe(struct platform_device *pdev)
+{
+	struct rockchip_link_clk *priv;
+	struct device_node *node = pdev->dev.of_node;
+	const struct of_device_id *match;
+	const char *clk_name;
+	const struct rockchip_link_info *link_info;
+	int ret;
+
+	match = of_match_node(rockchip_clk_link_of_match, node);
+	if (!match)
+		return -ENXIO;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_link_clk),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->link = match->data;
+
+	spin_lock_init(&priv->lock);
+	platform_set_drvdata(pdev, priv);
+
+	priv->base = of_iomap(node, 0);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	if (of_property_read_string(node, "clock-output-names", &clk_name))
+		priv->name = node->name;
+	else
+		priv->name = clk_name;
+
+	link_info = rockchip_get_link_infos(priv->link, priv->name);
+	priv->shift = link_info->shift;
+	priv->pname = link_info->pname;
+
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_clk_create(&pdev->dev);
+	if (ret)
+		goto disable_pm_runtime;
+
+	ret = pm_clk_add(&pdev->dev, "link");
+
+	if (ret)
+		goto destroy_pm_clk;
+
+	ret = register_clocks(priv, &pdev->dev);
+	if (ret)
+		goto destroy_pm_clk;
+
+	return 0;
+
+destroy_pm_clk:
+	pm_clk_destroy(&pdev->dev);
+disable_pm_runtime:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_clk_link_remove(struct platform_device *pdev)
+{
+	pm_clk_destroy(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rockchip_clk_link_pm_ops = {
+	SET_RUNTIME_PM_OPS(pm_clk_suspend, pm_clk_resume, NULL)
+};
+
+static struct platform_driver rockchip_clk_link_driver = {
+	.driver = {
+		.name = "clock-link",
+		.of_match_table = of_match_ptr(rockchip_clk_link_of_match),
+		.pm = &rockchip_clk_link_pm_ops,
+	},
+	.probe = rockchip_clk_link_probe,
+	.remove = rockchip_clk_link_remove,
+};
+
+static int __init rockchip_clk_link_drv_register(void)
+{
+	return platform_driver_register(&rockchip_clk_link_driver);
+}
+postcore_initcall_sync(rockchip_clk_link_drv_register);
+
+static void __exit rockchip_clk_link_drv_unregister(void)
+{
+	platform_driver_unregister(&rockchip_clk_link_driver);
+}
+module_exit(rockchip_clk_link_drv_unregister);
+
+MODULE_AUTHOR("Elaine Zhang <zhangqing@rock-chips.com>");
+MODULE_DESCRIPTION("Clock driver for Niu Dependencies");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/rockchip/clk-pll.c b/drivers/clk/rockchip/clk-pll.c
index 2d42eb62892..edd25ecc2e6 100644
--- a/drivers/clk/rockchip/clk-pll.c
+++ b/drivers/clk/rockchip/clk-pll.c
@@ -38,6 +38,8 @@ struct rockchip_clk_pll {
 	u8			flags;
 	const struct rockchip_pll_rate_table *rate_table;
 	unsigned int		rate_count;
+	int			sel;
+	unsigned long		scaling;
 	spinlock_t		*lock;
 
 	struct rockchip_clk_provider *ctx;
@@ -54,9 +56,16 @@ static const struct rockchip_pll_rate_table *rockchip_get_pll_settings(
 	int i;
 
 	for (i = 0; i < pll->rate_count; i++) {
-		if (rate == rate_table[i].rate)
+		if (rate == rate_table[i].rate) {
+			if (i < pll->sel) {
+				pll->scaling = rate;
+				return &rate_table[pll->sel];
+			}
+			pll->scaling = 0;
 			return &rate_table[i];
+		}
 	}
+	pll->scaling = 0;
 
 	return NULL;
 }
@@ -899,6 +908,9 @@ static unsigned long rockchip_rk3588_pll_recalc_rate(struct clk_hw *hw, unsigned
 	struct rockchip_pll_rate_table cur;
 	u64 rate64 = prate, postdiv;
 
+	if (pll->sel && pll->scaling)
+		return pll->scaling;
+
 	rockchip_rk3588_pll_get_params(pll, &cur);
 
 	rate64 *= cur.m;
@@ -980,6 +992,7 @@ static int rockchip_rk3588_pll_set_rate(struct clk_hw *hw, unsigned long drate,
 {
 	struct rockchip_clk_pll *pll = to_rockchip_clk_pll(hw);
 	const struct rockchip_pll_rate_table *rate;
+	int ret;
 
 	pr_debug("%s: changing %s to %lu with a parent rate of %lu\n",
 		 __func__, __clk_get_name(hw->clk), drate, prate);
@@ -992,7 +1005,11 @@ static int rockchip_rk3588_pll_set_rate(struct clk_hw *hw, unsigned long drate,
 		return -EINVAL;
 	}
 
-	return rockchip_rk3588_pll_set_params(pll, rate);
+	ret = rockchip_rk3588_pll_set_params(pll, rate);
+	if (ret)
+		pll->scaling = 0;
+
+	return ret;
 }
 
 static int rockchip_rk3588_pll_enable(struct clk_hw *hw)
@@ -1204,3 +1221,69 @@ struct clk *rockchip_clk_register_pll(struct rockchip_clk_provider *ctx,
 	kfree(pll);
 	return mux_clk;
 }
+
+int rockchip_pll_clk_adaptive_scaling(struct clk *clk, int sel)
+{
+        struct clk *parent = clk_get_parent(clk);
+        struct rockchip_clk_pll *pll;
+
+        if (IS_ERR_OR_NULL(parent))
+                return -EINVAL;
+
+        pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+        if (!pll)
+                return -EINVAL;
+
+        pll->sel = sel;
+
+        return 0;
+}
+EXPORT_SYMBOL(rockchip_pll_clk_adaptive_scaling);
+
+int rockchip_pll_clk_rate_to_scale(struct clk *clk, unsigned long rate)
+{
+        const struct rockchip_pll_rate_table *rate_table;
+        struct clk *parent = clk_get_parent(clk);
+        struct rockchip_clk_pll *pll;
+        unsigned int i;
+
+        if (IS_ERR_OR_NULL(parent))
+                return -EINVAL;
+
+        pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+        if (!pll)
+                return -EINVAL;
+
+        rate_table = pll->rate_table;
+        for (i = 0; i < pll->rate_count; i++) {
+                if (rate >= rate_table[i].rate)
+                        return i;
+        }
+
+        return -EINVAL;
+}
+EXPORT_SYMBOL(rockchip_pll_clk_rate_to_scale);
+
+int rockchip_pll_clk_scale_to_rate(struct clk *clk, unsigned int scale)
+{
+        const struct rockchip_pll_rate_table *rate_table;
+        struct clk *parent = clk_get_parent(clk);
+        struct rockchip_clk_pll *pll;
+        unsigned int i;
+
+        if (IS_ERR_OR_NULL(parent))
+                return -EINVAL;
+
+        pll = to_rockchip_clk_pll(__clk_get_hw(parent));
+        if (!pll)
+                return -EINVAL;
+
+        rate_table = pll->rate_table;
+        for (i = 0; i < pll->rate_count; i++) {
+                if (i == scale)
+                        return rate_table[i].rate;
+        }
+
+        return -EINVAL;
+}
+EXPORT_SYMBOL(rockchip_pll_clk_scale_to_rate);
diff --git a/drivers/clk/rockchip/clk-rk3399.c b/drivers/clk/rockchip/clk-rk3399.c
index aef3fddb842..306910a3a0d 100644
--- a/drivers/clk/rockchip/clk-rk3399.c
+++ b/drivers/clk/rockchip/clk-rk3399.c
@@ -624,7 +624,7 @@ static struct rockchip_clk_branch rk3399_clk_branches[] __initdata = {
 	GATE(SCLK_I2S2_8CH, "clk_i2s2", "clk_i2s2_mux", CLK_SET_RATE_PARENT,
 			RK3399_CLKGATE_CON(8), 11, GFLAGS),
 
-	MUX(SCLK_I2SOUT_SRC, "clk_i2sout_src", mux_i2sch_p, CLK_SET_RATE_PARENT,
+	MUX(0, "clk_i2sout_src", mux_i2sch_p, CLK_SET_RATE_PARENT,
 			RK3399_CLKSEL_CON(31), 0, 2, MFLAGS),
 	COMPOSITE_NODIV(SCLK_I2S_8CH_OUT, "clk_i2sout", mux_i2sout_p, CLK_SET_RATE_PARENT,
 			RK3399_CLKSEL_CON(31), 2, 1, MFLAGS,
diff --git a/drivers/clk/rockchip/clk-rk3568.c b/drivers/clk/rockchip/clk-rk3568.c
index 04f9901c1ff..f85902e2590 100644
--- a/drivers/clk/rockchip/clk-rk3568.c
+++ b/drivers/clk/rockchip/clk-rk3568.c
@@ -13,8 +13,6 @@
 #include <dt-bindings/clock/rk3568-cru.h>
 #include "clk.h"
 
-#define RK3568_GRF_SOC_CON1	0x504
-#define RK3568_GRF_SOC_CON2	0x508
 #define RK3568_GRF_SOC_STATUS0	0x580
 
 enum rk3568_pmu_plls {
@@ -249,13 +247,13 @@ PNAME(dpll_gpll_cpll_p)			= { "dpll", "gpll", "cpll" };
 PNAME(clk_ddr1x_p)			= { "clk_ddrphy1x_src", "dpll" };
 PNAME(gpll200_gpll150_gpll100_xin24m_p)	= { "gpll_200m", "gpll_150m", "gpll_100m", "xin24m" };
 PNAME(gpll100_gpll75_gpll50_p)		= { "gpll_100m", "gpll_75m", "cpll_50m" };
-PNAME(i2s0_mclkout_tx_p)		= { "mclk_i2s0_8ch_tx", "xin_osc0_half" };
-PNAME(i2s0_mclkout_rx_p)		= { "mclk_i2s0_8ch_rx", "xin_osc0_half" };
-PNAME(i2s1_mclkout_tx_p)		= { "mclk_i2s1_8ch_tx", "xin_osc0_half" };
-PNAME(i2s1_mclkout_rx_p)		= { "mclk_i2s1_8ch_rx", "xin_osc0_half" };
-PNAME(i2s2_mclkout_p)			= { "mclk_i2s2_2ch", "xin_osc0_half" };
-PNAME(i2s3_mclkout_tx_p)		= { "mclk_i2s3_2ch_tx", "xin_osc0_half" };
-PNAME(i2s3_mclkout_rx_p)		= { "mclk_i2s3_2ch_rx", "xin_osc0_half" };
+PNAME(i2s0_mclkout_tx_p)		= { "clk_i2s0_8ch_tx", "xin_osc0_half" };
+PNAME(i2s0_mclkout_rx_p)		= { "clk_i2s0_8ch_rx", "xin_osc0_half" };
+PNAME(i2s1_mclkout_tx_p)		= { "clk_i2s1_8ch_tx", "xin_osc0_half" };
+PNAME(i2s1_mclkout_rx_p)		= { "clk_i2s1_8ch_rx", "xin_osc0_half" };
+PNAME(i2s2_mclkout_p)			= { "clk_i2s2_2ch", "xin_osc0_half" };
+PNAME(i2s3_mclkout_tx_p)		= { "clk_i2s3_2ch_tx", "xin_osc0_half" };
+PNAME(i2s3_mclkout_rx_p)		= { "clk_i2s3_2ch_rx", "xin_osc0_half" };
 PNAME(mclk_pdm_p)			= { "gpll_300m", "cpll_250m", "gpll_200m", "gpll_100m" };
 PNAME(clk_i2c_p)			= { "gpll_200m", "gpll_100m", "xin24m", "cpll_100m" };
 PNAME(gpll200_gpll150_gpll100_p)	= { "gpll_200m", "gpll_150m", "gpll_100m" };
@@ -309,12 +307,6 @@ PNAME(clk_mac_2top_p)			= { "cpll_125m", "cpll_50m", "cpll_25m", "ppll" };
 PNAME(clk_pwm0_p)			= { "xin24m", "clk_pdpmu" };
 PNAME(aclk_rkvdec_pre_p)		= { "gpll", "cpll" };
 PNAME(clk_rkvdec_core_p)		= { "gpll", "cpll", "dummy_npll", "dummy_vpll" };
-PNAME(i2s1_mclkout_p)			= { "i2s1_mclkout_rx", "i2s1_mclkout_tx" };
-PNAME(i2s3_mclkout_p)			= { "i2s3_mclkout_rx", "i2s3_mclkout_tx" };
-PNAME(i2s1_mclk_rx_ioe_p)		= { "i2s1_mclkin_rx", "i2s1_mclkout_rx" };
-PNAME(i2s1_mclk_tx_ioe_p)		= { "i2s1_mclkin_tx", "i2s1_mclkout_tx" };
-PNAME(i2s2_mclk_ioe_p)			= { "i2s2_mclkin", "i2s2_mclkout" };
-PNAME(i2s3_mclk_ioe_p)			= { "i2s3_mclkin", "i2s3_mclkout" };
 
 static struct rockchip_pll_clock rk3568_pmu_pll_clks[] __initdata = {
 	[ppll] = PLL(pll_rk3328, PLL_PPLL, "ppll",  mux_pll_p,
@@ -712,19 +704,6 @@ static struct rockchip_clk_branch rk3568_clk_branches[] __initdata = {
 			RK3568_CLKSEL_CON(83), 15, 1, MFLAGS,
 			RK3568_CLKGATE_CON(7), 11, GFLAGS),
 
-	MUXGRF(I2S1_MCLKOUT, "i2s1_mclkout", i2s1_mclkout_p,  CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
-			RK3568_GRF_SOC_CON1, 5, 1, MFLAGS),
-	MUXGRF(I2S3_MCLKOUT, "i2s3_mclkout", i2s3_mclkout_p,  CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
-			RK3568_GRF_SOC_CON2, 15, 1, MFLAGS),
-	MUXGRF(I2S1_MCLK_RX_IOE, "i2s1_mclk_rx_ioe", i2s1_mclk_rx_ioe_p,  0,
-			RK3568_GRF_SOC_CON2, 0, 1, MFLAGS),
-	MUXGRF(I2S1_MCLK_TX_IOE, "i2s1_mclk_tx_ioe", i2s1_mclk_tx_ioe_p,  0,
-			RK3568_GRF_SOC_CON2, 1, 1, MFLAGS),
-	MUXGRF(I2S2_MCLK_IOE, "i2s2_mclk_ioe", i2s2_mclk_ioe_p,  0,
-			RK3568_GRF_SOC_CON2, 2, 1, MFLAGS),
-	MUXGRF(I2S3_MCLK_IOE, "i2s3_mclk_ioe", i2s3_mclk_ioe_p,  0,
-			RK3568_GRF_SOC_CON2, 3, 1, MFLAGS),
-
 	GATE(HCLK_PDM, "hclk_pdm", "hclk_gic_audio", 0,
 			RK3568_CLKGATE_CON(5), 14, GFLAGS),
 	COMPOSITE_NODIV(MCLK_PDM, "mclk_pdm", mclk_pdm_p, 0,
diff --git a/drivers/clk/rockchip/clk-rk3588.c b/drivers/clk/rockchip/clk-rk3588.c
index b7ce3fbd6fa..93a91474584 100644
--- a/drivers/clk/rockchip/clk-rk3588.c
+++ b/drivers/clk/rockchip/clk-rk3588.c
@@ -5,6 +5,7 @@
  */
 
 #include <linux/clk-provider.h>
+#include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
@@ -1988,7 +1989,7 @@ static struct rockchip_clk_branch rk3588_clk_branches[] __initdata = {
 			RK3588_CLKGATE_CON(60), 9, GFLAGS),
 	GATE(PCLK_TRNG1, "pclk_trng1", "pclk_vo1_root", 0,
 			RK3588_CLKGATE_CON(60), 10, GFLAGS),
-	GATE(0, "pclk_vo1grf", "pclk_vo1_root", CLK_IGNORE_UNUSED,
+	GATE(PCLK_VO1GRF, "pclk_vo1grf", "pclk_vo1_root", CLK_IGNORE_UNUSED,
 			RK3588_CLKGATE_CON(59), 12, GFLAGS),
 	GATE(PCLK_S_EDP0, "pclk_s_edp0", "pclk_vo1_s_root", 0,
 			RK3588_CLKGATE_CON(59), 14, GFLAGS),
@@ -2423,7 +2424,7 @@ static struct rockchip_clk_branch rk3588_clk_branches[] __initdata = {
 	GATE(ACLK_AV1, "aclk_av1", "aclk_av1_pre", 0,
 			RK3588_CLKGATE_CON(68), 2, GFLAGS),
 
-	GATE_LINK(ACLK_ISP1_PRE, "aclk_isp1_pre", "aclk_isp1_root", "aclk_vi_root", 0, RK3588_CLKGATE_CON(26), 6, GFLAGS),
+/*	GATE_LINK(ACLK_ISP1_PRE, "aclk_isp1_pre", "aclk_isp1_root", "aclk_vi_root", 0, RK3588_CLKGATE_CON(26), 6, GFLAGS),
 	GATE_LINK(HCLK_ISP1_PRE, "hclk_isp1_pre", "hclk_isp1_root", "hclk_vi_root", 0, RK3588_CLKGATE_CON(26), 8, GFLAGS),
 	GATE_LINK(HCLK_NVM, "hclk_nvm", "hclk_nvm_root", "aclk_nvm_root", 0, RK3588_CLKGATE_CON(31), 2, GFLAGS),
 	GATE_LINK(ACLK_USB, "aclk_usb", "aclk_usb_root", "aclk_vo1usb_top_root", 0, RK3588_CLKGATE_CON(42), 2, GFLAGS),
@@ -2442,7 +2443,7 @@ static struct rockchip_clk_branch rk3588_clk_branches[] __initdata = {
 	GATE_LINK(HCLK_VO1, "hclk_vo1", "hclk_vo1_root", "hclk_vo1usb_top_root", 0, RK3588_CLKGATE_CON(59), 9, GFLAGS),
 	GATE_LINK(ACLK_AV1_PRE, "aclk_av1_pre", "aclk_av1_root", "aclk_vdpu_root", 0, RK3588_CLKGATE_CON(68), 1, GFLAGS),
 	GATE_LINK(PCLK_AV1_PRE, "pclk_av1_pre", "pclk_av1_root", "hclk_vdpu_root", 0, RK3588_CLKGATE_CON(68), 4, GFLAGS),
-	GATE_LINK(HCLK_SDIO_PRE, "hclk_sdio_pre", "hclk_sdio_root", "hclk_nvm", 0, RK3588_CLKGATE_CON(75), 1, GFLAGS),
+	GATE_LINK(HCLK_SDIO_PRE, "hclk_sdio_pre", "hclk_sdio_root", "hclk_nvm", 0, RK3588_CLKGATE_CON(75), 1, GFLAGS),*/
 };
 
 static void __init rk3588_clk_init(struct device_node *np)
@@ -2507,6 +2508,7 @@ static const struct of_device_id clk_rk3588_match_table[] = {
 	},
 	{ }
 };
+MODULE_DEVICE_TABLE(of, clk_rk3588_match_table);
 
 static int __init clk_rk3588_probe(struct platform_device *pdev)
 {
@@ -2531,3 +2533,6 @@ static struct platform_driver clk_rk3588_driver = {
 	},
 };
 builtin_platform_driver_probe(clk_rk3588_driver, clk_rk3588_probe);
+
+MODULE_DESCRIPTION("Rockchip RK3588 Clock Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
index 758ebaf2236..60dea093646 100644
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -1024,5 +1024,8 @@ static inline void rockchip_register_softrst(struct device_node *np,
 }
 
 void rk3588_rst_init(struct device_node *np, void __iomem *reg_base);
+int rockchip_pll_clk_scale_to_rate(struct clk *clk, unsigned int scale);
+int rockchip_pll_clk_rate_to_scale(struct clk *clk, unsigned long rate);
+int rockchip_pll_clk_adaptive_scaling(struct clk *clk, int sel);
 
 #endif
diff --git a/drivers/nvmem/rockchip-otp.c b/drivers/nvmem/rockchip-otp.c
index 9f53bcce2f8..3dbb0ac5ed2 100644
--- a/drivers/nvmem/rockchip-otp.c
+++ b/drivers/nvmem/rockchip-otp.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/nvmem-provider.h>
 #include <linux/reset.h>
+#include <linux/soc/rockchip/cpu.h>
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
@@ -27,11 +28,31 @@
 #define OTPC_USER_CTRL			0x0100
 #define OTPC_USER_ADDR			0x0104
 #define OTPC_USER_ENABLE		0x0108
+#define OTPC_USER_QP			0x0120
 #define OTPC_USER_Q			0x0124
 #define OTPC_INT_STATUS			0x0304
 #define OTPC_SBPI_CMD0_OFFSET		0x1000
 #define OTPC_SBPI_CMD1_OFFSET		0x1004
 
+#define OTPC_MODE_CTRL			0x2000
+#define OTPC_IRQ_ST			0x2008
+#define OTPC_ACCESS_ADDR		0x200c
+#define OTPC_RD_DATA			0x2010
+#define OTPC_REPR_RD_TRANS_NUM		0x2020
+
+#define OTPC_DEEP_STANDBY		0x0
+#define OTPC_STANDBY			0x1
+#define OTPC_ACTIVE			0x2
+#define OTPC_READ_ACCESS		0x3
+#define OTPC_TRANS_NUM			0x1
+#define OTPC_RDM_IRQ_ST			BIT(0)
+#define OTPC_STB2ACT_IRQ_ST		BIT(7)
+#define OTPC_DP2STB_IRQ_ST		BIT(8)
+#define OTPC_ACT2STB_IRQ_ST		BIT(9)
+#define OTPC_STB2DP_IRQ_ST		BIT(10)
+#define PX30S_NBYTES			4
+#define PX30S_NO_SECURE_OFFSET		224
+
 /* OTP Register bits and masks */
 #define OTPC_USER_ADDR_MASK		GENMASK(31, 16)
 #define OTPC_USE_USER			BIT(0)
@@ -53,6 +74,84 @@
 #define SBPI_ENABLE_MASK		GENMASK(16, 16)
 
 #define OTPC_TIMEOUT			10000
+#define OTPC_TIMEOUT_PROG		100000
+#define RK3568_NBYTES			2
+
+#define RK3588_OTPC_AUTO_CTRL		0x04
+#define RK3588_OTPC_AUTO_EN		0x08
+#define RK3588_OTPC_INT_ST		0x84
+#define RK3588_OTPC_DOUT0		0x20
+#define RK3588_NO_SECURE_OFFSET		0x300
+#define RK3588_NBYTES			4
+#define RK3588_BURST_NUM		1
+#define RK3588_BURST_SHIFT		8
+#define RK3588_ADDR_SHIFT		16
+#define RK3588_AUTO_EN			BIT(0)
+#define RK3588_RD_DONE			BIT(1)
+
+#define RV1126_OTP_NVM_CEB		0x00
+#define RV1126_OTP_NVM_RSTB		0x04
+#define RV1126_OTP_NVM_ST		0x18
+#define RV1126_OTP_NVM_RADDR		0x1C
+#define RV1126_OTP_NVM_RSTART		0x20
+#define RV1126_OTP_NVM_RDATA		0x24
+#define RV1126_OTP_NVM_TRWH		0x28
+#define RV1126_OTP_READ_ST		0x30
+#define RV1126_OTP_NVM_PRADDR		0x34
+#define RV1126_OTP_NVM_PRLEN		0x38
+#define RV1126_OTP_NVM_PRDATA		0x3c
+#define RV1126_OTP_NVM_FAILTIME		0x40
+#define RV1126_OTP_NVM_PRSTART		0x44
+#define RV1126_OTP_NVM_PRSTATE		0x48
+
+/*
+ * +----------+------------------+--------------------------+
+ * | TYPE     | RANGE(byte)      | NOTE                     |
+ * +----------+------------------+--------------------------+
+ * | system   | 0x000 ~ 0x0ff    | system info, read only   |
+ * +----------+------------------+--------------------------+
+ * | oem      | 0x100 ~ 0x1ef    | for customized           |
+ * +----------+------------------+--------------------------+
+ * | reserved | 0x1f0 ~ 0x1f7    | future extension         |
+ * +----------+------------------+--------------------------+
+ * | wp       | 0x1f8 ~ 0x1ff    | write protection for oem |
+ * +----------+------------------+--------------------------+
+ *
+ * +-----+    +------------------+
+ * | wp  | -- | wp for oem range |
+ * +-----+    +------------------+
+ * | 1f8 |    | 0x100 ~ 0x11f    |
+ * +-----+    +------------------+
+ * | 1f9 |    | 0x120 ~ 0x13f    |
+ * +-----+    +------------------+
+ * | 1fa |    | 0x140 ~ 0x15f    |
+ * +-----+    +------------------+
+ * | 1fb |    | 0x160 ~ 0x17f    |
+ * +-----+    +------------------+
+ * | 1fc |    | 0x180 ~ 0x19f    |
+ * +-----+    +------------------+
+ * | 1fd |    | 0x1a0 ~ 0x1bf    |
+ * +-----+    +------------------+
+ * | 1fe |    | 0x1c0 ~ 0x1df    |
+ * +-----+    +------------------+
+ * | 1ff |    | 0x1e0 ~ 0x1ef    |
+ * +-----+    +------------------+
+ */
+#define RV1126_OTP_OEM_OFFSET		0x100
+#define RV1126_OTP_OEM_SIZE		0xf0
+#define RV1126_OTP_WP_OFFSET		0x1f8
+#define RV1126_OTP_WP_SIZE		0x8
+
+/* magic for enable otp write func */
+#define ROCKCHIP_OTP_WR_MAGIC		0x524F434B
+/* each bit mask 32 bits in OTP NVM */
+#define ROCKCHIP_OTP_WP_MASK_NBITS	64
+
+static unsigned int rockchip_otp_wr_magic;
+module_param(rockchip_otp_wr_magic, uint, 0644);
+MODULE_PARM_DESC(rockchip_otp_wr_magic, "magic for enable otp write func.");
+
+struct rockchip_data;
 
 struct rockchip_otp {
 	struct device *dev;
@@ -60,15 +159,19 @@ struct rockchip_otp {
 	struct clk_bulk_data	*clks;
 	int num_clks;
 	struct reset_control *rst;
-};
-
-/* list of required clocks */
-static const char * const rockchip_otp_clocks[] = {
-	"otp", "apb_pclk", "phy",
+	struct nvmem_config *config;
+	const struct rockchip_data *data;
+	struct mutex mutex;
+	DECLARE_BITMAP(wp_mask, ROCKCHIP_OTP_WP_MASK_NBITS);
 };
 
 struct rockchip_data {
 	int size;
+	const char * const *clocks;
+	int num_clks;
+	nvmem_reg_read_t reg_read;
+	nvmem_reg_write_t reg_write;
+	int (*init)(struct rockchip_otp *otp);
 };
 
 static int rockchip_otp_reset(struct rockchip_otp *otp)
@@ -92,7 +195,7 @@ static int rockchip_otp_reset(struct rockchip_otp *otp)
 	return 0;
 }
 
-static int rockchip_otp_wait_status(struct rockchip_otp *otp, u32 flag)
+static int px30_otp_wait_status(struct rockchip_otp *otp, u32 flag)
 {
 	u32 status = 0;
 	int ret;
@@ -108,7 +211,7 @@ static int rockchip_otp_wait_status(struct rockchip_otp *otp, u32 flag)
 	return 0;
 }
 
-static int rockchip_otp_ecc_enable(struct rockchip_otp *otp, bool enable)
+static int px30_otp_ecc_enable(struct rockchip_otp *otp, bool enable)
 {
 	int ret = 0;
 
@@ -125,15 +228,15 @@ static int rockchip_otp_ecc_enable(struct rockchip_otp *otp, bool enable)
 
 	writel(SBPI_ENABLE_MASK | SBPI_ENABLE, otp->base + OTPC_SBPI_CTRL);
 
-	ret = rockchip_otp_wait_status(otp, OTPC_SBPI_DONE);
+	ret = px30_otp_wait_status(otp, OTPC_SBPI_DONE);
 	if (ret < 0)
 		dev_err(otp->dev, "timeout during ecc_enable\n");
 
 	return ret;
 }
 
-static int rockchip_otp_read(void *context, unsigned int offset,
-			     void *val, size_t bytes)
+static int px30_otp_read(void *context, unsigned int offset, void *val,
+			 size_t bytes)
 {
 	struct rockchip_otp *otp = context;
 	u8 *buf = val;
@@ -151,7 +254,7 @@ static int rockchip_otp_read(void *context, unsigned int offset,
 		goto disable_clks;
 	}
 
-	ret = rockchip_otp_ecc_enable(otp, false);
+	ret = px30_otp_ecc_enable(otp, false);
 	if (ret < 0) {
 		dev_err(otp->dev, "rockchip_otp_ecc_enable err\n");
 		goto disable_clks;
@@ -164,7 +267,7 @@ static int rockchip_otp_read(void *context, unsigned int offset,
 		       otp->base + OTPC_USER_ADDR);
 		writel(OTPC_USER_FSM_ENABLE | OTPC_USER_FSM_ENABLE_MASK,
 		       otp->base + OTPC_USER_ENABLE);
-		ret = rockchip_otp_wait_status(otp, OTPC_USER_DONE);
+		ret = px30_otp_wait_status(otp, OTPC_USER_DONE);
 		if (ret < 0) {
 			dev_err(otp->dev, "timeout during read setup\n");
 			goto read_end;
@@ -180,32 +283,589 @@ static int rockchip_otp_read(void *context, unsigned int offset,
 	return ret;
 }
 
+static int px30s_otp_wait_status(struct rockchip_otp *otp, u32 flag)
+{
+	u32 status = 0;
+	int ret;
+
+	ret = readl_poll_timeout_atomic(otp->base + OTPC_IRQ_ST, status,
+					(status & flag), 1, OTPC_TIMEOUT);
+	if (ret)
+		return ret;
+
+	/* clean int status */
+	writel(flag, otp->base + OTPC_IRQ_ST);
+
+	return 0;
+}
+
+static int px30s_otp_active(struct rockchip_otp *otp)
+{
+	int ret = 0;
+	u32 mode;
+
+	mode = readl(otp->base + OTPC_MODE_CTRL);
+
+	switch (mode) {
+	case OTPC_DEEP_STANDBY:
+		writel(OTPC_STANDBY, otp->base + OTPC_MODE_CTRL);
+		ret = px30s_otp_wait_status(otp, OTPC_DP2STB_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait dp2stb\n");
+			return ret;
+		}
+		fallthrough;
+	case OTPC_STANDBY:
+		writel(OTPC_ACTIVE, otp->base + OTPC_MODE_CTRL);
+		ret = px30s_otp_wait_status(otp, OTPC_STB2ACT_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait stb2act\n");
+			return ret;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int px30s_otp_standby(struct rockchip_otp *otp)
+{
+	int ret = 0;
+	u32 mode;
+
+	mode = readl(otp->base + OTPC_MODE_CTRL);
+
+	switch (mode) {
+	case OTPC_ACTIVE:
+		writel(OTPC_STANDBY, otp->base + OTPC_MODE_CTRL);
+		ret = px30s_otp_wait_status(otp, OTPC_ACT2STB_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait act2stb\n");
+			return ret;
+		}
+		fallthrough;
+	case OTPC_STANDBY:
+		writel(OTPC_DEEP_STANDBY, otp->base + OTPC_MODE_CTRL);
+		ret = px30s_otp_wait_status(otp, OTPC_STB2DP_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait stb2dp\n");
+			return ret;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int px30s_otp_read(void *context, unsigned int offset, void *val,
+			  size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	int ret, i = 0;
+	u32 out_value;
+	u8 *buf;
+
+	if (offset >= otp->data->size)
+		return -ENOMEM;
+	if (offset + bytes > otp->data->size)
+		bytes = otp->data->size - offset;
+
+	ret = clk_bulk_prepare_enable(otp->num_clks, otp->clks);
+	if (ret < 0) {
+		dev_err(otp->dev, "failed to prepare/enable clks\n");
+		return ret;
+	}
+
+	ret = rockchip_otp_reset(otp);
+	if (ret) {
+		dev_err(otp->dev, "failed to reset otp phy\n");
+		goto disable_clks;
+	}
+
+	ret = px30s_otp_active(otp);
+	if (ret)
+		goto disable_clks;
+
+	addr_start = rounddown(offset, PX30S_NBYTES) / PX30S_NBYTES;
+	addr_end = roundup(offset + bytes, PX30S_NBYTES) / PX30S_NBYTES;
+	addr_offset = offset % PX30S_NBYTES;
+	addr_len = addr_end - addr_start;
+	addr_start += PX30S_NO_SECURE_OFFSET;
+
+	buf = kzalloc(sizeof(*buf) * addr_len * PX30S_NBYTES, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto read_end;
+	}
+
+	while (addr_len--) {
+		writel(OTPC_TRANS_NUM, otp->base + OTPC_REPR_RD_TRANS_NUM);
+		writel(addr_start++, otp->base + OTPC_ACCESS_ADDR);
+		writel(OTPC_READ_ACCESS, otp->base + OTPC_MODE_CTRL);
+		ret = px30s_otp_wait_status(otp, OTPC_RDM_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait rd\n");
+			goto read_end;
+		}
+		out_value = readl(otp->base + OTPC_RD_DATA);
+		memcpy(&buf[i], &out_value, PX30S_NBYTES);
+		i += PX30S_NBYTES;
+	}
+	memcpy(val, buf + addr_offset, (unsigned int)bytes);
+
+read_end:
+	kfree(buf);
+	px30s_otp_standby(otp);
+disable_clks:
+	clk_bulk_disable_unprepare(otp->num_clks, otp->clks);
+
+	return ret;
+}
+
+static int rk3568_otp_read(void *context, unsigned int offset, void *val,
+			   size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	unsigned int otp_qp;
+	u32 out_value;
+	u8 *buf;
+	int ret = 0, i = 0;
+
+	addr_start = rounddown(offset, RK3568_NBYTES) / RK3568_NBYTES;
+	addr_end = roundup(offset + bytes, RK3568_NBYTES) / RK3568_NBYTES;
+	addr_offset = offset % RK3568_NBYTES;
+	addr_len = addr_end - addr_start;
+
+	buf = kzalloc(array3_size(addr_len, RK3568_NBYTES, sizeof(*buf)),
+		      GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = clk_bulk_prepare_enable(otp->num_clks, otp->clks);
+	if (ret < 0) {
+		dev_err(otp->dev, "failed to prepare/enable clks\n");
+		goto out;
+	}
+
+	ret = rockchip_otp_reset(otp);
+	if (ret) {
+		dev_err(otp->dev, "failed to reset otp phy\n");
+		goto disable_clks;
+	}
+
+	ret = px30_otp_ecc_enable(otp, true);
+	if (ret < 0) {
+		dev_err(otp->dev, "rockchip_otp_ecc_enable err\n");
+		goto disable_clks;
+	}
+
+	writel(OTPC_USE_USER | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);
+	udelay(5);
+	while (addr_len--) {
+		writel(addr_start++ | OTPC_USER_ADDR_MASK,
+		       otp->base + OTPC_USER_ADDR);
+		writel(OTPC_USER_FSM_ENABLE | OTPC_USER_FSM_ENABLE_MASK,
+		       otp->base + OTPC_USER_ENABLE);
+		ret = px30_otp_wait_status(otp, OTPC_USER_DONE);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during read setup\n");
+			goto read_end;
+		}
+		otp_qp = readl(otp->base + OTPC_USER_QP);
+		if (((otp_qp & 0xc0) == 0xc0) || (otp_qp & 0x20)) {
+			ret = -EIO;
+			dev_err(otp->dev, "ecc check error during read setup\n");
+			goto read_end;
+		}
+		out_value = readl(otp->base + OTPC_USER_Q);
+		memcpy(&buf[i], &out_value, RK3568_NBYTES);
+		i += RK3568_NBYTES;
+	}
+
+	memcpy(val, buf + addr_offset, bytes);
+
+read_end:
+	writel(0x0 | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);
+disable_clks:
+	clk_bulk_disable_unprepare(otp->num_clks, otp->clks);
+out:
+	kfree(buf);
+
+	return ret;
+}
+
+static int rk3588_otp_wait_status(struct rockchip_otp *otp, u32 flag)
+{
+	u32 status = 0;
+	int ret;
+
+	ret = readl_poll_timeout_atomic(otp->base + RK3588_OTPC_INT_ST, status,
+					(status & flag), 1, OTPC_TIMEOUT);
+	if (ret)
+		return ret;
+
+	/* clean int status */
+	writel(flag, otp->base + RK3588_OTPC_INT_ST);
+
+	return 0;
+}
+
+static int rk3588_otp_read(void *context, unsigned int offset, void *val,
+			   size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	int ret = 0, i = 0;
+	u32 out_value;
+	u8 *buf;
+
+	if (offset >= otp->data->size)
+		return -ENOMEM;
+	if (offset + bytes > otp->data->size)
+		bytes = otp->data->size - offset;
+
+	addr_start = rounddown(offset, RK3588_NBYTES) / RK3588_NBYTES;
+	addr_end = roundup(offset + bytes, RK3588_NBYTES) / RK3588_NBYTES;
+	addr_offset = offset % RK3588_NBYTES;
+	addr_len = addr_end - addr_start;
+	addr_start += RK3588_NO_SECURE_OFFSET;
+
+	buf = kzalloc(array3_size(addr_len, RK3588_NBYTES, sizeof(*buf)),
+		      GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = clk_bulk_prepare_enable(otp->num_clks, otp->clks);
+	if (ret < 0) {
+		dev_err(otp->dev, "failed to prepare/enable clks\n");
+		goto out;
+	}
+
+	while (addr_len--) {
+		writel((addr_start << RK3588_ADDR_SHIFT) |
+		       (RK3588_BURST_NUM << RK3588_BURST_SHIFT),
+		       otp->base + RK3588_OTPC_AUTO_CTRL);
+		writel(RK3588_AUTO_EN, otp->base + RK3588_OTPC_AUTO_EN);
+		ret = rk3588_otp_wait_status(otp, RK3588_RD_DONE);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during read setup\n");
+			goto read_end;
+		}
+
+		out_value = readl(otp->base + RK3588_OTPC_DOUT0);
+		memcpy(&buf[i], &out_value, RK3588_NBYTES);
+		i += RK3588_NBYTES;
+		addr_start++;
+	}
+
+	memcpy(val, buf + addr_offset, bytes);
+
+read_end:
+	clk_bulk_disable_unprepare(otp->num_clks, otp->clks);
+out:
+	kfree(buf);
+
+	return ret;
+}
+
+static int rv1126_otp_init(struct rockchip_otp *otp)
+{
+	u32 status = 0;
+	int ret;
+
+	writel(0x0, otp->base + RV1126_OTP_NVM_CEB);
+	ret = readl_poll_timeout_atomic(otp->base + RV1126_OTP_NVM_ST, status,
+					status & 0x1, 1, OTPC_TIMEOUT);
+	if (ret < 0) {
+		dev_err(otp->dev, "timeout during set ceb\n");
+		return ret;
+	}
+
+	writel(0x1, otp->base + RV1126_OTP_NVM_RSTB);
+	ret = readl_poll_timeout_atomic(otp->base + RV1126_OTP_NVM_ST, status,
+					status & 0x4, 1, OTPC_TIMEOUT);
+	if (ret < 0) {
+		dev_err(otp->dev, "timeout during set rstb\n");
+		return ret;
+	}
+
+	otp->config->read_only = false;
+
+	return 0;
+}
+
+static int rv1126_otp_read(void *context, unsigned int offset, void *val,
+			   size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	u32 status = 0;
+	u8 *buf = val;
+	int ret = 0;
+
+	while (bytes--) {
+		writel(offset++, otp->base + RV1126_OTP_NVM_RADDR);
+		writel(0x1, otp->base + RV1126_OTP_NVM_RSTART);
+		ret = readl_poll_timeout_atomic(otp->base + RV1126_OTP_READ_ST,
+						status, status == 0, 1,
+						OTPC_TIMEOUT);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during read setup\n");
+			return ret;
+		}
+
+		*buf++ = readb(otp->base + RV1126_OTP_NVM_RDATA);
+	}
+
+	return 0;
+}
+
+static int rv1126_otp_prog(struct rockchip_otp *otp, u32 bit_offset, u32 data,
+			   u32 bit_len)
+{
+	u32 status = 0;
+	int ret = 0;
+
+	if (!data)
+		return 0;
+
+	writel(bit_offset, otp->base + RV1126_OTP_NVM_PRADDR);
+	writel(bit_len - 1, otp->base + RV1126_OTP_NVM_PRLEN);
+	writel(data, otp->base + RV1126_OTP_NVM_PRDATA);
+	writel(1, otp->base + RV1126_OTP_NVM_PRSTART);
+	/* Wait max 100 ms */
+	ret = readl_poll_timeout_atomic(otp->base + RV1126_OTP_NVM_PRSTATE,
+					status, status == 0, 1,
+					OTPC_TIMEOUT_PROG);
+	if (ret < 0)
+		dev_err(otp->dev, "timeout during prog\n");
+
+	return ret;
+}
+
+static int rv1126_otp_write(void *context, unsigned int offset, void *val,
+			    size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	u8 *buf = val;
+	u8 val_r, val_w;
+	int ret = 0;
+
+	while (bytes--) {
+		ret = rv1126_otp_read(context, offset, &val_r, 1);
+		if (ret)
+			return ret;
+		val_w = *buf & (~val_r);
+		ret = rv1126_otp_prog(otp, offset * 8, val_w, 8);
+		if (ret)
+			return ret;
+		buf++;
+		offset++;
+	}
+
+	return 0;
+}
+
+static int rv1126_otp_wp(void *context, unsigned int offset, size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+
+	bitmap_set(otp->wp_mask, (offset - RV1126_OTP_OEM_OFFSET) / 4, bytes / 4);
+
+	return rv1126_otp_write(context, RV1126_OTP_WP_OFFSET, otp->wp_mask,
+				RV1126_OTP_WP_SIZE);
+}
+
+static int rv1126_otp_oem_write(void *context, unsigned int offset, void *val,
+				size_t bytes)
+{
+	int ret = 0;
+
+	if (offset < RV1126_OTP_OEM_OFFSET ||
+	    offset > (RV1126_OTP_OEM_OFFSET + RV1126_OTP_OEM_SIZE - 1) ||
+	    bytes > RV1126_OTP_OEM_SIZE ||
+	    (offset + bytes) > (RV1126_OTP_OEM_OFFSET + RV1126_OTP_OEM_SIZE))
+		return -EINVAL;
+
+	if (!IS_ALIGNED(offset, 4) || !IS_ALIGNED(bytes, 4))
+		return -EINVAL;
+
+	ret = rv1126_otp_write(context, offset, val, bytes);
+	if (!ret)
+		ret = rv1126_otp_wp(context, offset, bytes);
+
+	return ret;
+}
+
+static int rockchip_otp_read(void *context, unsigned int offset, void *val,
+			     size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	int ret = -EINVAL;
+
+	mutex_lock(&otp->mutex);
+	if (otp->data && otp->data->reg_read)
+		ret = otp->data->reg_read(context, offset, val, bytes);
+	mutex_unlock(&otp->mutex);
+
+	return ret;
+}
+
+static int rockchip_otp_write(void *context, unsigned int offset, void *val,
+			      size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	int ret = -EINVAL;
+
+	mutex_lock(&otp->mutex);
+	if (rockchip_otp_wr_magic == ROCKCHIP_OTP_WR_MAGIC &&
+	    otp->data && otp->data->reg_write) {
+		ret = otp->data->reg_write(context, offset, val, bytes);
+		rockchip_otp_wr_magic = 0;
+	}
+	mutex_unlock(&otp->mutex);
+
+	return ret;
+}
+
 static struct nvmem_config otp_config = {
 	.name = "rockchip-otp",
 	.owner = THIS_MODULE,
 	.read_only = true,
+	.reg_read = rockchip_otp_read,
+	.reg_write = rockchip_otp_write,
 	.stride = 1,
 	.word_size = 1,
-	.reg_read = rockchip_otp_read,
+};
+
+static const char * const px30_otp_clocks[] = {
+	"otp", "apb_pclk", "phy",
 };
 
 static const struct rockchip_data px30_data = {
 	.size = 0x40,
+	.clocks = px30_otp_clocks,
+	.num_clks = ARRAY_SIZE(px30_otp_clocks),
+	.reg_read = px30_otp_read,
+};
+
+static const struct rockchip_data px30s_data = {
+	.size = 0x80,
+	.clocks = px30_otp_clocks,
+	.num_clks = ARRAY_SIZE(px30_otp_clocks),
+	.reg_read = px30s_otp_read,
+};
+
+static const char * const rk3568_otp_clocks[] = {
+	"usr", "sbpi", "apb", "phy",
+};
+
+static const struct rockchip_data rk3568_data = {
+	.size = 0x80,
+	.clocks = rk3568_otp_clocks,
+	.num_clks = ARRAY_SIZE(rk3568_otp_clocks),
+	.reg_read = rk3568_otp_read,
+};
+
+static const char * const rk3588_otp_clocks[] = {
+	"otpc", "apb", "arb", "phy",
+};
+
+static const struct rockchip_data rk3588_data = {
+	.size = 0x400,
+	.clocks = rk3588_otp_clocks,
+	.num_clks = ARRAY_SIZE(rk3588_otp_clocks),
+	.reg_read = rk3588_otp_read,
+};
+
+static const char * const rv1106_otp_clocks[] = {
+	"usr", "sbpi", "apb", "phy", "arb", "pmc",
+};
+
+static const struct rockchip_data rv1106_data = {
+	.size = 0x80,
+	.clocks = rv1106_otp_clocks,
+	.num_clks = ARRAY_SIZE(rv1106_otp_clocks),
+	.reg_read = rk3568_otp_read,
+};
+
+static const char * const rv1126_otp_clocks[] = {
+	"otp", "apb_pclk",
+};
+
+static const struct rockchip_data rv1126_data = {
+	.size = 0x200,
+	.clocks = rv1126_otp_clocks,
+	.num_clks = ARRAY_SIZE(rv1126_otp_clocks),
+	.init = rv1126_otp_init,
+	.reg_read = rv1126_otp_read,
+	.reg_write = rv1126_otp_oem_write,
 };
 
 static const struct of_device_id rockchip_otp_match[] = {
+#ifdef CONFIG_CPU_PX30
 	{
 		.compatible = "rockchip,px30-otp",
 		.data = (void *)&px30_data,
 	},
+	{
+		.compatible = "rockchip,px30s-otp",
+		.data = (void *)&px30s_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RK3308
 	{
 		.compatible = "rockchip,rk3308-otp",
 		.data = (void *)&px30_data,
 	},
+	{
+		.compatible = "rockchip,rk3308bs-otp",
+		.data = (void *)&px30s_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RK3568
+	{
+		.compatible = "rockchip,rk3568-otp",
+		.data = (void *)&rk3568_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RK3588
+	{
+		.compatible = "rockchip,rk3588-otp",
+		.data = (void *)&rk3588_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RV1106
+	{
+		.compatible = "rockchip,rv1106-otp",
+		.data = (void *)&rv1106_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RV1126
+	{
+		.compatible = "rockchip,rv1126-otp",
+		.data = (void *)&rv1126_data,
+	},
+#endif
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, rockchip_otp_match);
 
+static bool soc_is_px30s(void)
+{
+	return false;
+}
+
+static bool soc_is_rk3308bs(void)
+{
+	return false;
+}
+
 static int rockchip_otp_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -219,38 +879,50 @@ static int rockchip_otp_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to get match data\n");
 		return -EINVAL;
 	}
+	if (soc_is_px30s() || soc_is_rk3308bs())
+		data = &px30s_data;
 
 	otp = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_otp),
 			   GFP_KERNEL);
 	if (!otp)
 		return -ENOMEM;
 
+	mutex_init(&otp->mutex);
+	otp->data = data;
 	otp->dev = dev;
 	otp->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(otp->base))
 		return PTR_ERR(otp->base);
 
-	otp->num_clks = ARRAY_SIZE(rockchip_otp_clocks);
+	otp->num_clks = data->num_clks;
 	otp->clks = devm_kcalloc(dev, otp->num_clks,
 				     sizeof(*otp->clks), GFP_KERNEL);
 	if (!otp->clks)
 		return -ENOMEM;
 
 	for (i = 0; i < otp->num_clks; ++i)
-		otp->clks[i].id = rockchip_otp_clocks[i];
+		otp->clks[i].id = data->clocks[i];
 
 	ret = devm_clk_bulk_get(dev, otp->num_clks, otp->clks);
 	if (ret)
 		return ret;
 
-	otp->rst = devm_reset_control_get(dev, "phy");
+	otp->rst = devm_reset_control_array_get_optional_exclusive(dev);
 	if (IS_ERR(otp->rst))
 		return PTR_ERR(otp->rst);
 
-	otp_config.size = data->size;
-	otp_config.priv = otp;
-	otp_config.dev = dev;
-	nvmem = devm_nvmem_register(dev, &otp_config);
+	otp->config = &otp_config;
+	otp->config->size = data->size;
+	otp->config->priv = otp;
+	otp->config->dev = dev;
+
+	if (data->init) {
+		ret = data->init(otp);
+		if (ret)
+			return ret;
+	}
+
+	nvmem = devm_nvmem_register(dev, otp->config);
 
 	return PTR_ERR_OR_ZERO(nvmem);
 }
@@ -263,6 +935,26 @@ static struct platform_driver rockchip_otp_driver = {
 	},
 };
 
-module_platform_driver(rockchip_otp_driver);
+static int __init rockchip_otp_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&rockchip_otp_driver);
+	if (ret) {
+		pr_err("failed to register otp driver\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit rockchip_otp_exit(void)
+{
+	return platform_driver_unregister(&rockchip_otp_driver);
+}
+
+subsys_initcall(rockchip_otp_init);
+module_exit(rockchip_otp_exit);
+
 MODULE_DESCRIPTION("Rockchip OTP driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/pci/controller/dwc/pcie-dw-rockchip.c b/drivers/pci/controller/dwc/pcie-dw-rockchip.c
index c1e7653e508..435b717e5bc 100644
--- a/drivers/pci/controller/dwc/pcie-dw-rockchip.c
+++ b/drivers/pci/controller/dwc/pcie-dw-rockchip.c
@@ -354,6 +354,7 @@ static int rockchip_pcie_probe(struct platform_device *pdev)
 
 static const struct of_device_id rockchip_pcie_of_match[] = {
 	{ .compatible = "rockchip,rk3568-pcie", },
+	{ .compatible = "rockchip,rk3588-pcie", },
 	{},
 };
 
diff --git a/drivers/phy/rockchip/phy-rockchip-inno-usb2.c b/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
index a0bc10aa796..ca8ed5b9328 100644
--- a/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
+++ b/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
@@ -22,15 +22,24 @@
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/power_supply.h>
 #include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/soc/rockchip/cpu.h>
 #include <linux/mfd/syscon.h>
 #include <linux/usb/of.h>
 #include <linux/usb/otg.h>
+#include <linux/usb/role.h>
+#include <linux/usb/typec_mux.h>
 
 #define BIT_WRITEABLE_SHIFT	16
 #define SCHEDULE_DELAY		(60 * HZ)
-#define OTG_SCHEDULE_DELAY	(2 * HZ)
+#define OTG_SCHEDULE_DELAY	(1 * HZ)
+#define BYPASS_SCHEDULE_DELAY	(2 * HZ)
+#define FILTER_COUNTER		0xF4240
+
+struct rockchip_usb2phy;
 
 enum rockchip_usb2phy_port_id {
 	USB2PHY_PORT_OTG,
@@ -69,6 +78,7 @@ enum usb_chg_state {
 static const unsigned int rockchip_usb2phy_extcon_cable[] = {
 	EXTCON_USB,
 	EXTCON_USB_HOST,
+	EXTCON_PROP_USB_VBUS,
 	EXTCON_CHG_USB_SDP,
 	EXTCON_CHG_USB_CDP,
 	EXTCON_CHG_USB_DCP,
@@ -95,7 +105,7 @@ struct usb2phy_reg {
  * @rdm_pdwn_en: open dm pull down resistor.
  * @vdm_src_en: open dm voltage source.
  * @vdp_src_en: open dp voltage source.
- * @opmode: utmi operational mode.
+ * @chg_mode: set phy in charge detection mode.
  */
 struct rockchip_chg_det_reg {
 	struct usb2phy_reg	cp_det;
@@ -107,57 +117,109 @@ struct rockchip_chg_det_reg {
 	struct usb2phy_reg	rdm_pdwn_en;
 	struct usb2phy_reg	vdm_src_en;
 	struct usb2phy_reg	vdp_src_en;
-	struct usb2phy_reg	opmode;
+	struct usb2phy_reg	chg_mode;
 };
 
 /**
  * struct rockchip_usb2phy_port_cfg - usb-phy port configuration.
  * @phy_sus: phy suspend register.
+ * @pipe_phystatus: select pipe phystatus from grf or phy.
  * @bvalid_det_en: vbus valid rise detection enable register.
  * @bvalid_det_st: vbus valid rise detection status register.
  * @bvalid_det_clr: vbus valid rise detection clear register.
- * @id_det_en: id detection enable register.
- * @id_det_st: id detection state register.
- * @id_det_clr: id detection clear register.
+ * @bvalid_grf_con: vbus valid software control.
+ * @bvalid_grf_sel: vbus valid software control select.
+ * @bvalid_phy_con: vbus valid external select and enable.
+ * @bypass_dm_en: usb bypass uart DM enable register.
+ * @bypass_sel: usb bypass uart select register.
+ * @bypass_iomux: usb bypass uart GRF iomux register.
+ * @bypass_bc: bypass battery charging module.
+ * @bypass_otg: bypass otg module.
+ * @bypass_host: bypass host module.
+ * @disfall_en: host disconnect fall edge detection enable.
+ * @disfall_st: host disconnect fall edge detection state.
+ * @disfall_clr: host disconnect fall edge detection clear.
+ * @disrise_en: host disconnect rise edge detection enable.
+ * @disrise_st: host disconnect rise edge detection state.
+ * @disrise_clr: host disconnect rise edge detection clear.
  * @ls_det_en: linestate detection enable register.
  * @ls_det_st: linestate detection state register.
  * @ls_det_clr: linestate detection clear register.
+ * @iddig_output: iddig output from grf.
+ * @iddig_en: utmi iddig select between grf and phy,
+ *	      0: from phy; 1: from grf
+ * @idfall_det_en: id fall detection enable register.
+ * @idfall_det_st: id fall detection state register.
+ * @idfall_det_clr: id fall detection clear register.
+ * @idrise_det_en: id rise detection enable register.
+ * @idrise_det_st: id rise detection state register.
+ * @idrise_det_clr: id rise detection clear register.
  * @utmi_avalid: utmi vbus avalid status register.
  * @utmi_bvalid: utmi vbus bvalid status register.
- * @utmi_id: utmi id state register.
+ * @utmi_iddig: otg port id pin status register.
  * @utmi_ls: utmi linestate state register.
  * @utmi_hstdet: utmi host disconnect register.
+ * @vbus_det_en: vbus detect function power down register.
  */
 struct rockchip_usb2phy_port_cfg {
 	struct usb2phy_reg	phy_sus;
+	struct usb2phy_reg	pipe_phystatus;
 	struct usb2phy_reg	bvalid_det_en;
 	struct usb2phy_reg	bvalid_det_st;
 	struct usb2phy_reg	bvalid_det_clr;
-	struct usb2phy_reg	id_det_en;
-	struct usb2phy_reg	id_det_st;
-	struct usb2phy_reg	id_det_clr;
+	struct usb2phy_reg	bvalid_grf_con;
+	struct usb2phy_reg	bvalid_grf_sel;
+	struct usb2phy_reg	bvalid_phy_con;
+	struct usb2phy_reg	bypass_dm_en;
+	struct usb2phy_reg	bypass_sel;
+	struct usb2phy_reg	bypass_iomux;
+	struct usb2phy_reg	bypass_bc;
+	struct usb2phy_reg	bypass_otg;
+	struct usb2phy_reg	bypass_host;
+	struct usb2phy_reg	disfall_en;
+	struct usb2phy_reg	disfall_st;
+	struct usb2phy_reg	disfall_clr;
+	struct usb2phy_reg	disrise_en;
+	struct usb2phy_reg	disrise_st;
+	struct usb2phy_reg	disrise_clr;
 	struct usb2phy_reg	ls_det_en;
 	struct usb2phy_reg	ls_det_st;
 	struct usb2phy_reg	ls_det_clr;
+	struct usb2phy_reg	iddig_output;
+	struct usb2phy_reg	iddig_en;
+	struct usb2phy_reg	idfall_det_en;
+	struct usb2phy_reg	idfall_det_st;
+	struct usb2phy_reg	idfall_det_clr;
+	struct usb2phy_reg	idrise_det_en;
+	struct usb2phy_reg	idrise_det_st;
+	struct usb2phy_reg	idrise_det_clr;
 	struct usb2phy_reg	utmi_avalid;
 	struct usb2phy_reg	utmi_bvalid;
-	struct usb2phy_reg	utmi_id;
+	struct usb2phy_reg	utmi_iddig;
 	struct usb2phy_reg	utmi_ls;
 	struct usb2phy_reg	utmi_hstdet;
+	struct usb2phy_reg	vbus_det_en;
 };
 
 /**
  * struct rockchip_usb2phy_cfg - usb-phy configuration.
  * @reg: the address offset of grf for usb-phy config.
  * @num_ports: specify how many ports that the phy has.
+ * @phy_tuning: phy default parameters tuning.
+ * @vbus_detect: vbus voltage level detection function.
  * @clkout_ctl: keep on/turn off output clk of phy.
+ * @ls_filter_con: set linestate filter time.
  * @port_cfgs: usb-phy port configurations.
+ * @ls_filter_con: set linestate filter time.
  * @chg_det: charger detection registers.
  */
 struct rockchip_usb2phy_cfg {
 	unsigned int	reg;
 	unsigned int	num_ports;
+	int (*phy_tuning)(struct rockchip_usb2phy *rphy);
+	int (*vbus_detect)(struct rockchip_usb2phy *rphy, bool en);
 	struct usb2phy_reg	clkout_ctl;
+	struct usb2phy_reg	ls_filter_con;
 	const struct rockchip_usb2phy_port_cfg	port_cfgs[USB2PHY_NUM_PORTS];
 	const struct rockchip_chg_det_reg	chg_det;
 };
@@ -166,17 +228,33 @@ struct rockchip_usb2phy_cfg {
  * struct rockchip_usb2phy_port - usb-phy port data.
  * @phy: generic phy.
  * @port_id: flag for otg port or host port.
+ * @low_power_en: enable enter low power when suspend.
+ * @perip_connected: flag for periphyeral connect status.
+ * @prev_iddig: previous otg port id pin status.
+ * @sel_pipe_phystatus: select pipe phystatus from grf.
  * @suspended: phy suspended flag.
+ * @typec_vbus_det: Type-C otg vbus detect.
+ * @utmi_avalid: utmi avalid status usage flag.
+ *	true	- use avalid to get vbus status
+ *	false	- use bvalid to get vbus status
  * @vbus_attached: otg device vbus status.
+ * @vbus_always_on: otg vbus is always powered on.
+ * @vbus_enabled: vbus regulator status.
+ * @bypass_uart_en: usb bypass uart enable, passed from DT.
+ * @host_disconnect: usb host disconnect status.
+ * @dis_u2_susphy: disable usb2 phy suspend.
  * @bvalid_irq: IRQ number assigned for vbus valid rise detection.
- * @id_irq: IRQ number assigned for ID pin detection.
  * @ls_irq: IRQ number assigned for linestate detection.
+ * @id_irq: IRQ number assigned for id fall or rise detection.
  * @otg_mux_irq: IRQ number which multiplex otg-id/otg-bvalid/linestate
  *		 irqs to one irq in otg-port.
  * @mutex: for register updating in sm_work.
  * @chg_work: charge detect work.
+ * @bypass_uart_work: usb bypass uart work.
  * @otg_sm_work: OTG state machine work.
  * @sm_work: HOST state machine work.
+ * @vbus: vbus regulator supply on few rockchip boards.
+ * @sw: orientation switch, communicate with TCPM (Type-C Port Manager).
  * @port_cfg: port register configuration, assigned by driver data.
  * @event_nb: hold event notification callback.
  * @state: define OTG enumeration states before device reset.
@@ -185,16 +263,30 @@ struct rockchip_usb2phy_cfg {
 struct rockchip_usb2phy_port {
 	struct phy	*phy;
 	unsigned int	port_id;
+	bool		low_power_en;
+	bool		perip_connected;
+	bool		prev_iddig;
+	bool		sel_pipe_phystatus;
 	bool		suspended;
+	bool		typec_vbus_det;
+	bool		utmi_avalid;
 	bool		vbus_attached;
+	bool		vbus_always_on;
+	bool		vbus_enabled;
+	bool		bypass_uart_en;
+	bool		host_disconnect;
+	bool		dis_u2_susphy;
 	int		bvalid_irq;
-	int		id_irq;
 	int		ls_irq;
+	int             id_irq;
 	int		otg_mux_irq;
 	struct mutex	mutex;
+	struct		delayed_work bypass_uart_work;
 	struct		delayed_work chg_work;
 	struct		delayed_work otg_sm_work;
 	struct		delayed_work sm_work;
+	struct		regulator *vbus;
+	struct		typec_switch_dev *sw;
 	const struct	rockchip_usb2phy_port_cfg *port_cfg;
 	struct notifier_block	event_nb;
 	enum usb_otg_state	state;
@@ -206,15 +298,24 @@ struct rockchip_usb2phy_port {
  * @dev: pointer to device.
  * @grf: General Register Files regmap.
  * @usbgrf: USB General Register Files regmap.
- * @clk: clock struct of phy input clk.
+ * @usbctrl_grf: USB Controller General Register Files regmap.
+ * *phy_base: the base address of USB PHY.
+ * @phy_reset: phy reset control.
+ * @clks: array of phy input clocks.
  * @clk480m: clock struct of phy output clk.
  * @clk480m_hw: clock struct of phy output clk management.
+ * @num_clks: number of phy input clocks.
  * @chg_state: states involved in USB charger detection.
  * @chg_type: USB charger types.
  * @dcd_retries: The retry count used to track Data contact
  *		 detection process.
+ * @primary_retries: The retry count used for charger
+ *		     detection primary phase.
+ * @phy_sus_cfg: Store the phy current suspend configuration.
+ * @edev_self: represent the source of extcon.
+ * @irq: IRQ number assigned for phy which combined irqs of
+ *	 otg port and host port.
  * @edev: extcon device for notification registration
- * @irq: muxed interrupt for single irq configuration
  * @phy_cfg: phy register configuration, assigned by driver data.
  * @ports: phy port instance.
  */
@@ -222,14 +323,21 @@ struct rockchip_usb2phy {
 	struct device	*dev;
 	struct regmap	*grf;
 	struct regmap	*usbgrf;
-	struct clk	*clk;
+	struct regmap	*usbctrl_grf;
+	void __iomem	*phy_base;
+	struct reset_control	*phy_reset;
+	struct clk_bulk_data	*clks;
 	struct clk	*clk480m;
 	struct clk_hw	clk480m_hw;
+	int		num_clks;
 	enum usb_chg_state	chg_state;
 	enum power_supply_type	chg_type;
 	u8			dcd_retries;
-	struct extcon_dev	*edev;
+	u8			primary_retries;
+	unsigned int		phy_sus_cfg;
+	bool			edev_self;
 	int			irq;
+	struct extcon_dev	*edev;
 	const struct rockchip_usb2phy_cfg	*phy_cfg;
 	struct rockchip_usb2phy_port	ports[USB2PHY_NUM_PORTS];
 };
@@ -266,6 +374,53 @@ static inline bool property_enabled(struct regmap *base,
 	return tmp != reg->disable;
 }
 
+static inline void phy_clear_bits(void __iomem *reg, u32 bits)
+{
+	u32 tmp = readl(reg);
+
+	tmp &= ~bits;
+	writel(tmp, reg);
+}
+
+static inline void phy_set_bits(void __iomem *reg, u32 bits)
+{
+	u32 tmp = readl(reg);
+
+	tmp |= bits;
+	writel(tmp, reg);
+}
+
+static inline void phy_update_bits(void __iomem *reg, u32 mask, u32 val)
+{
+	u32 tmp = readl(reg);
+
+	tmp &= ~mask;
+	tmp |= val & mask;
+	writel(tmp, reg);
+}
+
+static int rockchip_usb2phy_reset(struct rockchip_usb2phy *rphy)
+{
+	int ret;
+
+	if (!rphy->phy_reset)
+		return 0;
+
+	ret = reset_control_assert(rphy->phy_reset);
+	if (ret)
+		return ret;
+
+	udelay(10);
+
+	ret = reset_control_deassert(rphy->phy_reset);
+	if (ret)
+		return ret;
+
+	usleep_range(100, 200);
+
+	return 0;
+}
+
 static int rockchip_usb2phy_clk480m_prepare(struct clk_hw *hw)
 {
 	struct rockchip_usb2phy *rphy =
@@ -331,7 +486,8 @@ static int
 rockchip_usb2phy_clk480m_register(struct rockchip_usb2phy *rphy)
 {
 	struct device_node *node = rphy->dev->of_node;
-	struct clk_init_data init;
+	struct clk_init_data init = {};
+	struct clk *refclk = of_clk_get_by_name(node, "phyclk");
 	const char *clk_name;
 	int ret = 0;
 
@@ -342,8 +498,8 @@ rockchip_usb2phy_clk480m_register(struct rockchip_usb2phy *rphy)
 	/* optional override of the clockname */
 	of_property_read_string(node, "clock-output-names", &init.name);
 
-	if (rphy->clk) {
-		clk_name = __clk_get_name(rphy->clk);
+	if (!IS_ERR(refclk)) {
+		clk_name = __clk_get_name(refclk);
 		init.parent_names = &clk_name;
 		init.num_parents = 1;
 	} else {
@@ -398,6 +554,8 @@ static int rockchip_usb2phy_extcon_register(struct rockchip_usb2phy *rphy)
 			dev_err(rphy->dev, "failed to register extcon device\n");
 			return ret;
 		}
+
+		rphy->edev_self = true;
 	}
 
 	rphy->edev = edev;
@@ -405,60 +563,235 @@ static int rockchip_usb2phy_extcon_register(struct rockchip_usb2phy *rphy)
 	return 0;
 }
 
+/* The caller must hold rport->mutex lock */
+static int rockchip_usb2phy_enable_id_irq(struct rockchip_usb2phy *rphy,
+					  struct rockchip_usb2phy_port *rport,
+					  bool en)
+{
+	int ret;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->idfall_det_clr, true);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->idfall_det_en, en);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->idrise_det_clr, true);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->idrise_det_en, en);
+out:
+	return ret;
+}
+
+/* The caller must hold rport->mutex lock */
+static int rockchip_usb2phy_enable_vbus_irq(struct rockchip_usb2phy *rphy,
+					    struct rockchip_usb2phy_port *rport,
+					    bool en)
+{
+	int ret;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->bvalid_det_clr, true);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->bvalid_det_en, en);
+out:
+	return ret;
+}
+
+static int rockchip_usb2phy_enable_line_irq(struct rockchip_usb2phy *rphy,
+					    struct rockchip_usb2phy_port *rport,
+					    bool en)
+{
+	int ret;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->ls_det_clr, true);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->ls_det_en, en);
+out:
+	return ret;
+}
+
+static int rockchip_usb2phy_enable_host_disc_irq(struct rockchip_usb2phy *rphy,
+						 struct rockchip_usb2phy_port *rport,
+						 bool en)
+{
+	int ret;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->disfall_clr, true);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->disfall_en, en);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->disrise_clr, true);
+	if (ret)
+		goto out;
+
+	ret = property_enable(rphy->grf, &rport->port_cfg->disrise_en, en);
+out:
+	return ret;
+}
+
+static int rockchip_usb_bypass_uart(struct rockchip_usb2phy_port *rport,
+				    bool en)
+{
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
+	const struct usb2phy_reg *iomux = &rport->port_cfg->bypass_iomux;
+	struct regmap *base = get_reg_base(rphy);
+	int ret = 0;
+
+	mutex_lock(&rport->mutex);
+
+	if (en == property_enabled(base, &rport->port_cfg->bypass_sel)) {
+		dev_info(&rport->phy->dev,
+			 "bypass uart %s is already set\n", en ? "on" : "off");
+		goto unlock;
+	}
+
+	dev_info(&rport->phy->dev, "bypass uart %s\n", en ? "on" : "off");
+
+	if (en) {
+		/*
+		 * To use UART function:
+		 * 1. Put the USB PHY in suspend mode and opmode is normal;
+		 * 2. Set bypasssel to 1'b1 and bypassdmen to 1'b1;
+		 *
+		 * Note: Although the datasheet requires that put USB PHY
+		 * in non-driving mode to disable resistance when use USB
+		 * bypass UART function, but actually we find that if we
+		 * set phy in non-driving mode, it will cause UART to print
+		 * random codes. So just put USB PHY in normal mode.
+		 */
+		ret |= property_enable(base, &rport->port_cfg->bypass_sel,
+				       true);
+		ret |= property_enable(base, &rport->port_cfg->bypass_dm_en,
+				       true);
+
+		/* Some platforms required to set iomux of bypass uart */
+		if (iomux->offset)
+			ret |= property_enable(rphy->grf, iomux, true);
+	} else {
+		/* just disable bypass, and resume phy in phy power_on later */
+		ret |= property_enable(base, &rport->port_cfg->bypass_sel,
+				       false);
+		ret |= property_enable(base, &rport->port_cfg->bypass_dm_en,
+				       false);
+
+		/* Some platforms required to set iomux of bypass uart */
+		if (iomux->offset)
+			ret |= property_enable(rphy->grf, iomux, false);
+	}
+
+unlock:
+	mutex_unlock(&rport->mutex);
+
+	return ret;
+}
+
+static void rockchip_usb_bypass_uart_work(struct work_struct *work)
+{
+	struct rockchip_usb2phy_port *rport =
+		container_of(work, struct rockchip_usb2phy_port,
+			     bypass_uart_work.work);
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
+	bool vbus, iddig;
+	int ret;
+
+	mutex_lock(&rport->mutex);
+
+	iddig = property_enabled(rphy->grf, &rport->port_cfg->utmi_iddig);
+
+	if (rport->utmi_avalid)
+		vbus = property_enabled(rphy->grf, &rport->port_cfg->utmi_avalid);
+	else
+		vbus = property_enabled(rphy->grf, &rport->port_cfg->utmi_bvalid);
+
+	mutex_unlock(&rport->mutex);
+
+	/*
+	 * If the vbus is low and iddig is high, it indicates that usb
+	 * otg is not working, then we can enable usb to bypass uart,
+	 * otherwise schedule the work until the conditions (vbus is low
+	 * and iddig is high) are matched.
+	 */
+	if (!vbus && iddig) {
+		ret = rockchip_usb_bypass_uart(rport, true);
+		if (ret)
+			dev_warn(&rport->phy->dev,
+				 "failed to enable bypass uart\n");
+	} else {
+		schedule_delayed_work(&rport->bypass_uart_work,
+				      BYPASS_SCHEDULE_DELAY);
+	}
+}
+
 static int rockchip_usb2phy_init(struct phy *phy)
 {
 	struct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);
 	struct rockchip_usb2phy *rphy = dev_get_drvdata(phy->dev.parent);
 	int ret = 0;
+	unsigned int ul, ul_mask;
 
 	mutex_lock(&rport->mutex);
 
-	if (rport->port_id == USB2PHY_PORT_OTG) {
-		if (rport->mode != USB_DR_MODE_HOST &&
-		    rport->mode != USB_DR_MODE_UNKNOWN) {
-			/* clear bvalid status and enable bvalid detect irq */
-			ret = property_enable(rphy->grf,
-					      &rport->port_cfg->bvalid_det_clr,
-					      true);
-			if (ret)
-				goto out;
-
-			ret = property_enable(rphy->grf,
-					      &rport->port_cfg->bvalid_det_en,
-					      true);
-			if (ret)
-				goto out;
-
-			/* clear id status and enable id detect irq */
-			ret = property_enable(rphy->grf,
-					      &rport->port_cfg->id_det_clr,
-					      true);
-			if (ret)
+	if (rport->port_id == USB2PHY_PORT_OTG &&
+	    (rport->mode == USB_DR_MODE_PERIPHERAL ||
+	     rport->mode == USB_DR_MODE_OTG)) {
+		/* clear id status and enable id detect irq */
+		if (rport->id_irq > 0 || rport->otg_mux_irq > 0 ||
+		    rphy->irq > 0) {
+			ret = rockchip_usb2phy_enable_id_irq(rphy, rport,
+							     true);
+			if (ret) {
+				dev_err(rphy->dev,
+					"failed to enable id irq\n");
 				goto out;
+			}
+		}
 
-			ret = property_enable(rphy->grf,
-					      &rport->port_cfg->id_det_en,
-					      true);
-			if (ret)
+		/* clear bvalid status and enable bvalid detect irq */
+		if ((rport->bvalid_irq > 0 || rport->otg_mux_irq > 0 ||
+		    rphy->irq > 0) && !rport->vbus_always_on) {
+			ret = rockchip_usb2phy_enable_vbus_irq(rphy, rport,
+							       true);
+			if (ret) {
+				dev_err(rphy->dev,
+					"failed to enable bvalid irq\n");
 				goto out;
-
+			}
 			schedule_delayed_work(&rport->otg_sm_work,
-					      OTG_SCHEDULE_DELAY * 3);
-		} else {
-			/* If OTG works in host only mode, do nothing. */
-			dev_dbg(&rport->phy->dev, "mode %d\n", rport->mode);
+					      rport->typec_vbus_det ? 0 : OTG_SCHEDULE_DELAY);
 		}
 	} else if (rport->port_id == USB2PHY_PORT_HOST) {
-		/* clear linestate and enable linestate detect irq */
-		ret = property_enable(rphy->grf,
-				      &rport->port_cfg->ls_det_clr, true);
-		if (ret)
-			goto out;
+		if (rport->port_cfg->disfall_en.offset) {
+			ret = regmap_read(rphy->grf, rport->port_cfg->utmi_ls.offset, &ul);
+			if (ret < 0)
+				goto out;
+			ul_mask = GENMASK(rport->port_cfg->utmi_ls.bitend,
+					  rport->port_cfg->utmi_ls.bitstart);
+			rport->host_disconnect = (ul & ul_mask) == 0 ? true : false;
+			ret = rockchip_usb2phy_enable_host_disc_irq(rphy, rport, true);
+			if (ret) {
+				dev_err(rphy->dev, "failed to enable disconnect irq\n");
+				goto out;
+			}
+		}
 
-		ret = property_enable(rphy->grf,
-				      &rport->port_cfg->ls_det_en, true);
-		if (ret)
+		/* clear linestate and enable linestate detect irq */
+		ret = rockchip_usb2phy_enable_line_irq(rphy, rport, true);
+		if (ret) {
+			dev_err(rphy->dev, "failed to enable linestate irq\n");
 			goto out;
+		}
 
 		schedule_delayed_work(&rport->sm_work, SCHEDULE_DELAY);
 	}
@@ -477,24 +810,63 @@ static int rockchip_usb2phy_power_on(struct phy *phy)
 
 	dev_dbg(&rport->phy->dev, "port power on\n");
 
-	if (!rport->suspended)
-		return 0;
+	if (rport->bypass_uart_en) {
+		ret = rockchip_usb_bypass_uart(rport, false);
+		if (ret) {
+			dev_warn(&rport->phy->dev,
+				 "failed to disable bypass uart\n");
+			goto exit;
+		}
+	}
+
+	mutex_lock(&rport->mutex);
+
+	if (!rport->suspended) {
+		ret = 0;
+		goto unlock;
+	}
 
 	ret = clk_prepare_enable(rphy->clk480m);
 	if (ret)
-		return ret;
+		goto unlock;
+
+	if (rport->sel_pipe_phystatus)
+		property_enable(rphy->usbctrl_grf,
+				&rport->port_cfg->pipe_phystatus, true);
 
 	ret = property_enable(base, &rport->port_cfg->phy_sus, false);
-	if (ret) {
-		clk_disable_unprepare(rphy->clk480m);
-		return ret;
+	if (ret)
+		goto unlock;
+
+	/*
+	 * For rk3588, it needs to reset phy when exit from
+	 * suspend mode with common_on_n 1'b1(aka REFCLK_LOGIC,
+	 * Bias, and PLL blocks are powered down) for lower
+	 * power consumption. If you don't want to reset phy,
+	 * please keep the common_on_n 1'b0 to set these blocks
+	 * remain powered.
+	 */
+	if (rport->port_id == USB2PHY_PORT_OTG &&
+	    of_device_is_compatible(rphy->dev->of_node, "rockchip,rk3588-usb2phy")) {
+		ret = rockchip_usb2phy_reset(rphy);
+		if (ret)
+			goto unlock;
 	}
 
 	/* waiting for the utmi_clk to become stable */
 	usleep_range(1500, 2000);
 
 	rport->suspended = false;
-	return 0;
+
+unlock:
+	mutex_unlock(&rport->mutex);
+
+	/* Enable bypass uart in the bypass_uart_work. */
+	if (rport->bypass_uart_en)
+		schedule_delayed_work(&rport->bypass_uart_work, 0);
+
+exit:
+	return ret;
 }
 
 static int rockchip_usb2phy_power_off(struct phy *phy)
@@ -506,103 +878,353 @@ static int rockchip_usb2phy_power_off(struct phy *phy)
 
 	dev_dbg(&rport->phy->dev, "port power off\n");
 
-	if (rport->suspended)
-		return 0;
+	mutex_lock(&rport->mutex);
+
+	if (rport->suspended) {
+		ret = 0;
+		goto unlock;
+	}
 
 	ret = property_enable(base, &rport->port_cfg->phy_sus, true);
 	if (ret)
-		return ret;
+		goto unlock;
 
 	rport->suspended = true;
 	clk_disable_unprepare(rphy->clk480m);
 
-	return 0;
+unlock:
+	mutex_unlock(&rport->mutex);
+
+	/* Enable bypass uart in the bypass_uart_work. */
+	if (rport->bypass_uart_en)
+		schedule_delayed_work(&rport->bypass_uart_work, 0);
+
+	return ret;
 }
 
 static int rockchip_usb2phy_exit(struct phy *phy)
 {
 	struct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);
 
-	if (rport->port_id == USB2PHY_PORT_OTG &&
-	    rport->mode != USB_DR_MODE_HOST &&
-	    rport->mode != USB_DR_MODE_UNKNOWN) {
-		cancel_delayed_work_sync(&rport->otg_sm_work);
-		cancel_delayed_work_sync(&rport->chg_work);
-	} else if (rport->port_id == USB2PHY_PORT_HOST)
+	if (rport->port_id == USB2PHY_PORT_HOST)
 		cancel_delayed_work_sync(&rport->sm_work);
+	else if (rport->port_id == USB2PHY_PORT_OTG &&
+		 rport->otg_sm_work.work.func)
+		flush_delayed_work(&rport->otg_sm_work);
 
 	return 0;
 }
 
+static int rockchip_set_vbus_power(struct rockchip_usb2phy_port *rport,
+				   bool en)
+{
+	int ret = 0;
+
+	if (!rport->vbus)
+		return 0;
+
+	if (en && !rport->vbus_enabled) {
+		ret = regulator_enable(rport->vbus);
+		if (ret)
+			dev_err(&rport->phy->dev,
+				"Failed to enable VBUS supply\n");
+	} else if (!en && rport->vbus_enabled) {
+		ret = regulator_disable(rport->vbus);
+	}
+
+	if (ret == 0)
+		rport->vbus_enabled = en;
+
+	return ret;
+}
+
+static int rockchip_usb2phy_set_mode(struct phy *phy,
+				     enum phy_mode mode, int submode)
+{
+	struct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(phy->dev.parent);
+	bool vbus_det_en;
+	int ret = 0;
+
+	if (rport->port_id != USB2PHY_PORT_OTG)
+		return ret;
+
+	switch (mode) {
+	case PHY_MODE_USB_OTG:
+		if (rphy->edev_self && submode) {
+			if (submode == USB_ROLE_HOST) {
+				extcon_set_state(rphy->edev, EXTCON_USB_HOST, true);
+				extcon_set_state(rphy->edev, EXTCON_USB, false);
+			} else if (submode == USB_ROLE_DEVICE) {
+				extcon_set_state(rphy->edev, EXTCON_USB_HOST, false);
+				extcon_set_state(rphy->edev, EXTCON_USB, true);
+			}
+
+			return ret;
+		}
+
+		/*
+		 * In case of using vbus to detect connect state by u2phy,
+		 * enable vbus detect on otg mode.
+		 */
+		fallthrough;
+	case PHY_MODE_USB_DEVICE ... PHY_MODE_USB_DEVICE_SS:
+		/* Disable VBUS supply */
+		rockchip_set_vbus_power(rport, false);
+		extcon_set_state_sync(rphy->edev, EXTCON_PROP_USB_VBUS, false);
+		/* For vbus always on, set EXTCON_USB to true. */
+		if (rport->vbus_always_on)
+			extcon_set_state(rphy->edev, EXTCON_USB, true);
+		rport->perip_connected = true;
+		vbus_det_en = true;
+		break;
+	case PHY_MODE_USB_HOST ... PHY_MODE_USB_HOST_SS:
+		/* Enable VBUS supply */
+		ret = rockchip_set_vbus_power(rport, true);
+		if (ret) {
+			dev_err(&rport->phy->dev,
+				"Failed to set host mode\n");
+			return ret;
+		}
+
+		extcon_set_state_sync(rphy->edev, EXTCON_PROP_USB_VBUS, true);
+		/* For vbus always on, deinit EXTCON_USB to false. */
+		if (rport->vbus_always_on)
+			extcon_set_state(rphy->edev, EXTCON_USB, false);
+		rport->perip_connected = false;
+		fallthrough;
+	case PHY_MODE_INVALID:
+		vbus_det_en = false;
+		break;
+	default:
+		dev_info(&rport->phy->dev, "illegal mode %d\n", mode);
+		return ret;
+	}
+
+	if (rphy->phy_cfg->vbus_detect)
+		rphy->phy_cfg->vbus_detect(rphy, vbus_det_en);
+	else
+		ret = property_enable(rphy->grf, &rport->port_cfg->vbus_det_en,
+				      vbus_det_en);
+
+	return ret;
+}
+
 static const struct phy_ops rockchip_usb2phy_ops = {
 	.init		= rockchip_usb2phy_init,
 	.exit		= rockchip_usb2phy_exit,
 	.power_on	= rockchip_usb2phy_power_on,
 	.power_off	= rockchip_usb2phy_power_off,
+	.set_mode	= rockchip_usb2phy_set_mode,
 	.owner		= THIS_MODULE,
 };
 
-static void rockchip_usb2phy_otg_sm_work(struct work_struct *work)
+/* Show & store the current value of otg mode for otg port */
+static ssize_t otg_mode_show(struct device *device,
+			     struct device_attribute *attr,
+			     char *buf)
 {
-	struct rockchip_usb2phy_port *rport =
-		container_of(work, struct rockchip_usb2phy_port,
-			     otg_sm_work.work);
-	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
-	static unsigned int cable;
-	unsigned long delay;
-	bool vbus_attach, sch_work, notify_charger;
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(device);
+	struct rockchip_usb2phy_port *rport = NULL;
+	unsigned int index;
 
-	vbus_attach = property_enabled(rphy->grf,
-				       &rport->port_cfg->utmi_bvalid);
+	for (index = 0; index < rphy->phy_cfg->num_ports; index++) {
+		rport = &rphy->ports[index];
+		if (rport->port_id == USB2PHY_PORT_OTG)
+			break;
+	}
 
-	sch_work = false;
-	notify_charger = false;
-	delay = OTG_SCHEDULE_DELAY;
-	dev_dbg(&rport->phy->dev, "%s otg sm work\n",
-		usb_otg_state_string(rport->state));
+	if (!rport) {
+		dev_err(rphy->dev, "Fail to get otg port\n");
+		return -EINVAL;
+	} else if (rport->port_id != USB2PHY_PORT_OTG) {
+		dev_err(rphy->dev, "No support otg\n");
+		return -EINVAL;
+	}
+
+	switch (rport->mode) {
+	case USB_DR_MODE_HOST:
+		return sprintf(buf, "host\n");
+	case USB_DR_MODE_PERIPHERAL:
+		return sprintf(buf, "peripheral\n");
+	case USB_DR_MODE_OTG:
+		return sprintf(buf, "otg\n");
+	case USB_DR_MODE_UNKNOWN:
+		return sprintf(buf, "UNKNOWN\n");
+	}
+
+	return -EINVAL;
+}
+
+static ssize_t otg_mode_store(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(device);
+	struct rockchip_usb2phy_port *rport = NULL;
+	struct regmap *base = get_reg_base(rphy);
+	enum usb_dr_mode new_dr_mode;
+	unsigned int index;
+	int rc = count;
+
+	for (index = 0; index < rphy->phy_cfg->num_ports; index++) {
+		rport = &rphy->ports[index];
+		if (rport->port_id == USB2PHY_PORT_OTG)
+			break;
+	}
+
+	if (!rport) {
+		dev_err(rphy->dev, "Fail to get otg port\n");
+		rc = -EINVAL;
+		goto err0;
+	} else if (rport->port_id != USB2PHY_PORT_OTG ||
+		   rport->mode == USB_DR_MODE_UNKNOWN) {
+		dev_err(rphy->dev, "No support otg\n");
+		rc = -EINVAL;
+		goto err0;
+	}
+
+	mutex_lock(&rport->mutex);
+
+	if (!strncmp(buf, "0", 1) || !strncmp(buf, "otg", 3)) {
+		new_dr_mode = USB_DR_MODE_OTG;
+	} else if (!strncmp(buf, "1", 1) || !strncmp(buf, "host", 4)) {
+		new_dr_mode = USB_DR_MODE_HOST;
+	} else if (!strncmp(buf, "2", 1) || !strncmp(buf, "peripheral", 10)) {
+		new_dr_mode = USB_DR_MODE_PERIPHERAL;
+	} else {
+		dev_err(rphy->dev, "Error mode! Input 'otg' or 'host' or 'peripheral'\n");
+		rc = -EINVAL;
+		goto err1;
+	}
+
+	if (rport->mode == new_dr_mode) {
+		dev_warn(rphy->dev, "Same as current mode\n");
+		goto err1;
+	}
+
+	rport->mode = new_dr_mode;
+
+	switch (rport->mode) {
+	case USB_DR_MODE_HOST:
+		rockchip_usb2phy_set_mode(rport->phy, PHY_MODE_USB_HOST, 0);
+		property_enable(base, &rport->port_cfg->iddig_output, false);
+		property_enable(base, &rport->port_cfg->iddig_en, true);
+		break;
+	case USB_DR_MODE_PERIPHERAL:
+		rockchip_usb2phy_set_mode(rport->phy, PHY_MODE_USB_DEVICE, 0);
+		property_enable(base, &rport->port_cfg->iddig_output, true);
+		property_enable(base, &rport->port_cfg->iddig_en, true);
+		break;
+	case USB_DR_MODE_OTG:
+		rockchip_usb2phy_set_mode(rport->phy, PHY_MODE_USB_OTG, 0);
+		property_enable(base, &rport->port_cfg->iddig_output, false);
+		property_enable(base, &rport->port_cfg->iddig_en, false);
+		break;
+	default:
+		break;
+	}
+
+err1:
+	mutex_unlock(&rport->mutex);
+
+err0:
+	return rc;
+}
+static DEVICE_ATTR_RW(otg_mode);
+
+/* Group all the usb2 phy attributes */
+static struct attribute *usb2_phy_attrs[] = {
+	&dev_attr_otg_mode.attr,
+	NULL,
+};
+
+static struct attribute_group usb2_phy_attr_group = {
+	.name = NULL,	/* we want them in the same directory */
+	.attrs = usb2_phy_attrs,
+};
+
+static void rockchip_usb2phy_otg_sm_work(struct work_struct *work)
+{
+	struct rockchip_usb2phy_port *rport =
+		container_of(work, struct rockchip_usb2phy_port,
+			     otg_sm_work.work);
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
+	static unsigned int cable;
+	unsigned long delay;
+	bool sch_work;
+
+	mutex_lock(&rport->mutex);
+
+	if (rport->port_cfg->bvalid_grf_con.enable && rport->typec_vbus_det)
+		rport->vbus_attached =
+			property_enabled(rphy->grf, &rport->port_cfg->bvalid_grf_con);
+	else if (rport->utmi_avalid)
+		rport->vbus_attached =
+			property_enabled(rphy->grf, &rport->port_cfg->utmi_avalid);
+	else
+		rport->vbus_attached =
+			property_enabled(rphy->grf, &rport->port_cfg->utmi_bvalid);
+
+	sch_work = false;
+	delay = OTG_SCHEDULE_DELAY;
+
+	dev_dbg(&rport->phy->dev, "%s otg sm work\n",
+		usb_otg_state_string(rport->state));
 
 	switch (rport->state) {
 	case OTG_STATE_UNDEFINED:
 		rport->state = OTG_STATE_B_IDLE;
-		if (!vbus_attach)
-			rockchip_usb2phy_power_off(rport->phy);
+		if (!rport->vbus_attached) {
+			mutex_unlock(&rport->mutex);
+			if (!rport->dis_u2_susphy)
+				rockchip_usb2phy_power_off(rport->phy);
+			mutex_lock(&rport->mutex);
+		}
 		fallthrough;
 	case OTG_STATE_B_IDLE:
-		if (extcon_get_state(rphy->edev, EXTCON_USB_HOST) > 0) {
+		if (extcon_get_state(rphy->edev, EXTCON_USB_HOST) > 0 ||
+		    extcon_get_state(rphy->edev, EXTCON_PROP_USB_VBUS) > 0) {
 			dev_dbg(&rport->phy->dev, "usb otg host connect\n");
 			rport->state = OTG_STATE_A_HOST;
+			rphy->chg_state = USB_CHG_STATE_UNDEFINED;
+			rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
+			mutex_unlock(&rport->mutex);
 			rockchip_usb2phy_power_on(rport->phy);
 			return;
-		} else if (vbus_attach) {
+		} else if (rport->vbus_attached) {
 			dev_dbg(&rport->phy->dev, "vbus_attach\n");
 			switch (rphy->chg_state) {
 			case USB_CHG_STATE_UNDEFINED:
+				mutex_unlock(&rport->mutex);
 				schedule_delayed_work(&rport->chg_work, 0);
 				return;
 			case USB_CHG_STATE_DETECTED:
 				switch (rphy->chg_type) {
 				case POWER_SUPPLY_TYPE_USB:
 					dev_dbg(&rport->phy->dev, "sdp cable is connected\n");
+					cable = EXTCON_CHG_USB_SDP;
+					mutex_unlock(&rport->mutex);
 					rockchip_usb2phy_power_on(rport->phy);
+					mutex_lock(&rport->mutex);
 					rport->state = OTG_STATE_B_PERIPHERAL;
-					notify_charger = true;
+					rport->perip_connected = true;
 					sch_work = true;
-					cable = EXTCON_CHG_USB_SDP;
 					break;
 				case POWER_SUPPLY_TYPE_USB_DCP:
 					dev_dbg(&rport->phy->dev, "dcp cable is connected\n");
-					rockchip_usb2phy_power_off(rport->phy);
-					notify_charger = true;
-					sch_work = true;
 					cable = EXTCON_CHG_USB_DCP;
+					sch_work = true;
 					break;
 				case POWER_SUPPLY_TYPE_USB_CDP:
 					dev_dbg(&rport->phy->dev, "cdp cable is connected\n");
+					cable = EXTCON_CHG_USB_CDP;
+					mutex_unlock(&rport->mutex);
 					rockchip_usb2phy_power_on(rport->phy);
+					mutex_lock(&rport->mutex);
 					rport->state = OTG_STATE_B_PERIPHERAL;
-					notify_charger = true;
+					rport->perip_connected = true;
 					sch_work = true;
-					cable = EXTCON_CHG_USB_CDP;
 					break;
 				default:
 					break;
@@ -612,48 +1234,80 @@ static void rockchip_usb2phy_otg_sm_work(struct work_struct *work)
 				break;
 			}
 		} else {
-			notify_charger = true;
 			rphy->chg_state = USB_CHG_STATE_UNDEFINED;
 			rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
-		}
-
-		if (rport->vbus_attached != vbus_attach) {
-			rport->vbus_attached = vbus_attach;
-
-			if (notify_charger && rphy->edev) {
-				extcon_set_state_sync(rphy->edev,
-							cable, vbus_attach);
-				if (cable == EXTCON_CHG_USB_SDP)
-					extcon_set_state_sync(rphy->edev,
-							      EXTCON_USB,
-							      vbus_attach);
-			}
+			mutex_unlock(&rport->mutex);
+			if (!rport->dis_u2_susphy)
+				rockchip_usb2phy_power_off(rport->phy);
+			mutex_lock(&rport->mutex);
 		}
 		break;
 	case OTG_STATE_B_PERIPHERAL:
-		if (!vbus_attach) {
-			dev_dbg(&rport->phy->dev, "usb disconnect\n");
+		sch_work = true;
+
+		if (extcon_get_state(rphy->edev, EXTCON_USB_HOST) > 0 ||
+		    extcon_get_state(rphy->edev,
+					    EXTCON_PROP_USB_VBUS) > 0) {
+			dev_dbg(&rport->phy->dev, "usb otg host connect\n");
+			rport->state = OTG_STATE_A_HOST;
 			rphy->chg_state = USB_CHG_STATE_UNDEFINED;
 			rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
+			rport->perip_connected = false;
+			sch_work = false;
+		} else if (!rport->vbus_attached) {
+			dev_dbg(&rport->phy->dev, "usb disconnect\n");
 			rport->state = OTG_STATE_B_IDLE;
-			delay = 0;
-			rockchip_usb2phy_power_off(rport->phy);
+			rport->perip_connected = false;
+			rphy->chg_state = USB_CHG_STATE_UNDEFINED;
+			rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
+			delay = OTG_SCHEDULE_DELAY;
 		}
-		sch_work = true;
 		break;
 	case OTG_STATE_A_HOST:
 		if (extcon_get_state(rphy->edev, EXTCON_USB_HOST) == 0) {
 			dev_dbg(&rport->phy->dev, "usb otg host disconnect\n");
 			rport->state = OTG_STATE_B_IDLE;
-			rockchip_usb2phy_power_off(rport->phy);
+			sch_work = true;
+		} else {
+			mutex_unlock(&rport->mutex);
+			return;
 		}
 		break;
 	default:
-		break;
+		mutex_unlock(&rport->mutex);
+		return;
+	}
+
+	if (extcon_get_state(rphy->edev, cable) != rport->vbus_attached) {
+		extcon_set_state_sync(rphy->edev,
+					cable, rport->vbus_attached);
+
+		if (!rport->vbus_attached)
+			cable = EXTCON_NONE;
+	} else if (rport->state == OTG_STATE_A_HOST &&
+		 extcon_get_state(rphy->edev, cable)) {
+		/*
+		 * If plug in OTG host cable when the rport state is
+		 * OTG_STATE_B_PERIPHERAL, the vbus voltage will stay
+		 * in high, so the rport->vbus_attached may not be
+		 * changed. We need to set cable state here.
+		 */
+		extcon_set_state_sync(rphy->edev, cable, false);
+		cable = EXTCON_NONE;
 	}
 
+	if (rphy->edev_self &&
+	    (extcon_get_state(rphy->edev, EXTCON_USB) !=
+	     rport->perip_connected)) {
+		extcon_set_state_sync(rphy->edev,
+					EXTCON_USB,
+					rport->perip_connected);
+		extcon_sync(rphy->edev, EXTCON_USB_HOST);
+	}
 	if (sch_work)
 		schedule_delayed_work(&rport->otg_sm_work, delay);
+
+	mutex_unlock(&rport->mutex);
 }
 
 static const char *chg_to_string(enum power_supply_type chg_type)
@@ -707,21 +1361,45 @@ static void rockchip_chg_detect_work(struct work_struct *work)
 		container_of(work, struct rockchip_usb2phy_port, chg_work.work);
 	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
 	struct regmap *base = get_reg_base(rphy);
+	const struct usb2phy_reg *phy_sus_reg;
 	bool is_dcd, tmout, vout;
 	unsigned long delay;
+	unsigned int mask;
+	int ret;
 
 	dev_dbg(&rport->phy->dev, "chg detection work state = %d\n",
 		rphy->chg_state);
+
+	/*
+	 * The conditions for charger detection:
+	 * 1. Set the PHY in normal mode to keep the UTMI_CLK on.
+	 * 2. Set the utmi_opmode in non-driving mode.
+	 * 3. Set the utmi_xcvrselect to FS speed.
+	 * 4. Set the utmi_termselect to FS speed.
+	 * 5. Enable the DP/DM pulldown resistor.
+	 */
 	switch (rphy->chg_state) {
 	case USB_CHG_STATE_UNDEFINED:
-		if (!rport->suspended)
-			rockchip_usb2phy_power_off(rport->phy);
-		/* put the controller in non-driving mode */
-		property_enable(base, &rphy->phy_cfg->chg_det.opmode, false);
+		mutex_lock(&rport->mutex);
+		/* Store the PHY current suspend configuration */
+		phy_sus_reg = &rport->port_cfg->phy_sus;
+		ret = regmap_read(base, phy_sus_reg->offset,
+				  &rphy->phy_sus_cfg);
+		if (ret) {
+			dev_err(&rport->phy->dev,
+				"Fail to read phy_sus reg offset 0x%x, ret %d\n",
+				phy_sus_reg->offset, ret);
+			mutex_unlock(&rport->mutex);
+			return;
+		}
+
+		/* Set the PHY in charger detection mode */
+		property_enable(base, &rphy->phy_cfg->chg_det.chg_mode, true);
 		/* Start DCD processing stage 1 */
 		rockchip_chg_enable_dcd(rphy, true);
 		rphy->chg_state = USB_CHG_STATE_WAIT_FOR_DCD;
 		rphy->dcd_retries = 0;
+		rphy->primary_retries = 0;
 		delay = CHG_DCD_POLL_TIME;
 		break;
 	case USB_CHG_STATE_WAIT_FOR_DCD:
@@ -759,6 +1437,19 @@ static void rockchip_chg_detect_work(struct work_struct *work)
 				rphy->chg_state = USB_CHG_STATE_DETECTED;
 				delay = 0;
 			} else {
+				if (rphy->primary_retries < 2) {
+					/* Turn off DCD circuitry */
+					rockchip_chg_enable_dcd(rphy, false);
+					/* Voltage Source on DP, Probe on DM */
+					rockchip_chg_enable_primary_det(rphy,
+									true);
+					delay = CHG_PRIMARY_DET_TIME;
+					rphy->chg_state =
+						USB_CHG_STATE_DCD_DONE;
+					rphy->primary_retries++;
+					/* break USB_CHG_STATE_DCD_DONE */
+					break;
+				}
 				rphy->chg_type = POWER_SUPPLY_TYPE_USB;
 				rphy->chg_state = USB_CHG_STATE_DETECTED;
 				delay = 0;
@@ -779,16 +1470,34 @@ static void rockchip_chg_detect_work(struct work_struct *work)
 		rphy->chg_state = USB_CHG_STATE_DETECTED;
 		fallthrough;
 	case USB_CHG_STATE_DETECTED:
-		/* put the controller in normal mode */
-		property_enable(base, &rphy->phy_cfg->chg_det.opmode, true);
+		if (rphy->phy_cfg->chg_det.chg_mode.offset !=
+		    rport->port_cfg->phy_sus.offset)
+			property_enable(base, &rphy->phy_cfg->chg_det.chg_mode, false);
+
+		/* Restore the PHY suspend configuration */
+		phy_sus_reg = &rport->port_cfg->phy_sus;
+		mask = GENMASK(phy_sus_reg->bitend, phy_sus_reg->bitstart);
+		ret = regmap_write(base, phy_sus_reg->offset,
+				   (rphy->phy_sus_cfg | (mask << BIT_WRITEABLE_SHIFT)));
+		if (ret)
+			dev_err(&rport->phy->dev,
+				"Fail to set phy_sus reg offset 0x%x, ret %d\n",
+				phy_sus_reg->offset, ret);
+		mutex_unlock(&rport->mutex);
 		rockchip_usb2phy_otg_sm_work(&rport->otg_sm_work.work);
 		dev_dbg(&rport->phy->dev, "charger = %s\n",
 			 chg_to_string(rphy->chg_type));
 		return;
 	default:
+		mutex_unlock(&rport->mutex);
 		return;
 	}
 
+	/*
+	 * Hold the mutex lock during the whole charger
+	 * detection stage, and release it after detect
+	 * the charger type.
+	 */
 	schedule_delayed_work(&rport->chg_work, delay);
 }
 
@@ -810,30 +1519,43 @@ static void rockchip_usb2phy_sm_work(struct work_struct *work)
 	struct rockchip_usb2phy_port *rport =
 		container_of(work, struct rockchip_usb2phy_port, sm_work.work);
 	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
-	unsigned int sh = rport->port_cfg->utmi_hstdet.bitend -
-			  rport->port_cfg->utmi_hstdet.bitstart + 1;
-	unsigned int ul, uhd, state;
+	unsigned int sh, ul, uhd, state;
 	unsigned int ul_mask, uhd_mask;
 	int ret;
 
+	if (!rport->port_cfg->utmi_ls.offset ||
+	    (!rport->port_cfg->utmi_hstdet.offset &&
+	     !rport->port_cfg->disfall_en.offset)) {
+		dev_dbg(&rport->phy->dev, "some property may not be specified\n");
+		return;
+	}
+
 	mutex_lock(&rport->mutex);
 
 	ret = regmap_read(rphy->grf, rport->port_cfg->utmi_ls.offset, &ul);
 	if (ret < 0)
 		goto next_schedule;
 
-	ret = regmap_read(rphy->grf, rport->port_cfg->utmi_hstdet.offset, &uhd);
-	if (ret < 0)
-		goto next_schedule;
-
-	uhd_mask = GENMASK(rport->port_cfg->utmi_hstdet.bitend,
-			   rport->port_cfg->utmi_hstdet.bitstart);
 	ul_mask = GENMASK(rport->port_cfg->utmi_ls.bitend,
 			  rport->port_cfg->utmi_ls.bitstart);
 
-	/* stitch on utmi_ls and utmi_hstdet as phy state */
-	state = ((uhd & uhd_mask) >> rport->port_cfg->utmi_hstdet.bitstart) |
-		(((ul & ul_mask) >> rport->port_cfg->utmi_ls.bitstart) << sh);
+	if (rport->port_cfg->utmi_hstdet.offset) {
+		ret = regmap_read(rphy->grf, rport->port_cfg->utmi_hstdet.offset, &uhd);
+		if (ret < 0)
+			goto next_schedule;
+
+		uhd_mask = GENMASK(rport->port_cfg->utmi_hstdet.bitend,
+				   rport->port_cfg->utmi_hstdet.bitstart);
+
+		sh = rport->port_cfg->utmi_hstdet.bitend -
+		     rport->port_cfg->utmi_hstdet.bitstart + 1;
+		/* stitch on utmi_ls and utmi_hstdet as phy state */
+		state = ((uhd & uhd_mask) >> rport->port_cfg->utmi_hstdet.bitstart) |
+			(((ul & ul_mask) >> rport->port_cfg->utmi_ls.bitstart) << sh);
+	} else {
+		state = ((ul & ul_mask) >> rport->port_cfg->utmi_ls.bitstart) << 1 |
+			rport->host_disconnect;
+	}
 
 	switch (state) {
 	case PHY_STATE_HS_ONLINE:
@@ -858,7 +1580,9 @@ static void rockchip_usb2phy_sm_work(struct work_struct *work)
 	case PHY_STATE_CONNECT:
 		if (rport->suspended) {
 			dev_dbg(&rport->phy->dev, "Connected\n");
+			mutex_unlock(&rport->mutex);
 			rockchip_usb2phy_power_on(rport->phy);
+			mutex_lock(&rport->mutex);
 			rport->suspended = false;
 		} else {
 			/* D+ line pull-up, D- line pull-down */
@@ -868,7 +1592,9 @@ static void rockchip_usb2phy_sm_work(struct work_struct *work)
 	case PHY_STATE_DISCONNECT:
 		if (!rport->suspended) {
 			dev_dbg(&rport->phy->dev, "Disconnected\n");
+			mutex_unlock(&rport->mutex);
 			rockchip_usb2phy_power_off(rport->phy);
+			mutex_lock(&rport->mutex);
 			rport->suspended = true;
 		}
 
@@ -876,8 +1602,7 @@ static void rockchip_usb2phy_sm_work(struct work_struct *work)
 		 * activate the linestate detection to get the next device
 		 * plug-in irq.
 		 */
-		property_enable(rphy->grf, &rport->port_cfg->ls_det_clr, true);
-		property_enable(rphy->grf, &rport->port_cfg->ls_det_en, true);
+		rockchip_usb2phy_enable_line_irq(rphy, rport, true);
 
 		/*
 		 * we don't need to rearm the delayed work when the phy port
@@ -886,7 +1611,7 @@ static void rockchip_usb2phy_sm_work(struct work_struct *work)
 		mutex_unlock(&rport->mutex);
 		return;
 	default:
-		dev_dbg(&rport->phy->dev, "unknown phy state\n");
+		dev_dbg(&rport->phy->dev, "unknown phy state %d\n", state);
 		break;
 	}
 
@@ -900,14 +1625,24 @@ static irqreturn_t rockchip_usb2phy_linestate_irq(int irq, void *data)
 	struct rockchip_usb2phy_port *rport = data;
 	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
 
-	if (!property_enabled(rphy->grf, &rport->port_cfg->ls_det_st))
+	if (!property_enabled(rphy->grf, &rport->port_cfg->ls_det_st) ||
+	    !property_enabled(rphy->grf, &rport->port_cfg->ls_det_en))
 		return IRQ_NONE;
 
+	dev_dbg(&rport->phy->dev, "linestate interrupt\n");
+
 	mutex_lock(&rport->mutex);
 
 	/* disable linestate detect irq and clear its status */
-	property_enable(rphy->grf, &rport->port_cfg->ls_det_en, false);
-	property_enable(rphy->grf, &rport->port_cfg->ls_det_clr, true);
+	rockchip_usb2phy_enable_line_irq(rphy, rport, false);
+
+	/*
+	 * For host port, it may miss disc irq when device is connected,
+	 * in this case, we can clear host_disconnect state depend on
+	 * the linestate irq.
+	 */
+	if (rport->port_id == USB2PHY_PORT_HOST && rport->port_cfg->disfall_en.offset)
+		rport->host_disconnect = false;
 
 	mutex_unlock(&rport->mutex);
 
@@ -933,7 +1668,13 @@ static irqreturn_t rockchip_usb2phy_bvalid_irq(int irq, void *data)
 	/* clear bvalid detect irq pending status */
 	property_enable(rphy->grf, &rport->port_cfg->bvalid_det_clr, true);
 
-	rockchip_usb2phy_otg_sm_work(&rport->otg_sm_work.work);
+	if (rport->bypass_uart_en)
+		rockchip_usb_bypass_uart(rport, false);
+
+	if (rport->otg_sm_work.work.func) {
+		cancel_delayed_work_sync(&rport->otg_sm_work);
+		rockchip_usb2phy_otg_sm_work(&rport->otg_sm_work.work);
+	}
 
 	return IRQ_HANDLED;
 }
@@ -942,16 +1683,61 @@ static irqreturn_t rockchip_usb2phy_id_irq(int irq, void *data)
 {
 	struct rockchip_usb2phy_port *rport = data;
 	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
-	bool id;
+	bool cable_vbus_state = false;
+
+	if (!property_enabled(rphy->grf, &rport->port_cfg->idfall_det_st) &&
+	    !property_enabled(rphy->grf, &rport->port_cfg->idrise_det_st))
+		return IRQ_NONE;
+
+	mutex_lock(&rport->mutex);
+
+	/* clear id fall or rise detect irq pending status */
+	if (property_enabled(rphy->grf, &rport->port_cfg->idfall_det_st)) {
+		property_enable(rphy->grf, &rport->port_cfg->idfall_det_clr,
+				true);
+		cable_vbus_state = true;
+	} else if (property_enabled(rphy->grf, &rport->port_cfg->idrise_det_st)) {
+		property_enable(rphy->grf, &rport->port_cfg->idrise_det_clr,
+				true);
+		cable_vbus_state = false;
+	}
+
+	extcon_set_state(rphy->edev, EXTCON_USB_HOST, cable_vbus_state);
+	extcon_set_state(rphy->edev, EXTCON_PROP_USB_VBUS, cable_vbus_state);
+
+	extcon_sync(rphy->edev, EXTCON_USB_HOST);
+	extcon_sync(rphy->edev, EXTCON_PROP_USB_VBUS);
+
+	rockchip_set_vbus_power(rport, cable_vbus_state);
+
+	mutex_unlock(&rport->mutex);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rockchip_usb2phy_host_disc_irq(int irq, void *data)
+{
+	struct rockchip_usb2phy_port *rport = data;
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
 
-	if (!property_enabled(rphy->grf, &rport->port_cfg->id_det_st))
+	if (!property_enabled(rphy->grf, &rport->port_cfg->disfall_st) &&
+	    !property_enabled(rphy->grf, &rport->port_cfg->disrise_st))
 		return IRQ_NONE;
 
-	/* clear id detect irq pending status */
-	property_enable(rphy->grf, &rport->port_cfg->id_det_clr, true);
+	mutex_lock(&rport->mutex);
+
+	/* clear disconnect fall or rise detect irq pending status */
+	if (property_enabled(rphy->grf, &rport->port_cfg->disfall_st)) {
+		property_enable(rphy->grf, &rport->port_cfg->disfall_clr,
+				true);
+		rport->host_disconnect = false;
+	} else if (property_enabled(rphy->grf, &rport->port_cfg->disrise_st)) {
+		property_enable(rphy->grf, &rport->port_cfg->disrise_clr,
+				true);
+		rport->host_disconnect = true;
+	}
 
-	id = property_enabled(rphy->grf, &rport->port_cfg->utmi_id);
-	extcon_set_state_sync(rphy->edev, EXTCON_USB_HOST, !id);
+	mutex_unlock(&rport->mutex);
 
 	return IRQ_HANDLED;
 }
@@ -960,8 +1746,9 @@ static irqreturn_t rockchip_usb2phy_otg_mux_irq(int irq, void *data)
 {
 	irqreturn_t ret = IRQ_NONE;
 
+	ret  = rockchip_usb2phy_id_irq(irq, data);
 	ret |= rockchip_usb2phy_bvalid_irq(irq, data);
-	ret |= rockchip_usb2phy_id_irq(irq, data);
+	ret |= rockchip_usb2phy_linestate_irq(irq, data);
 
 	return ret;
 }
@@ -972,12 +1759,21 @@ static irqreturn_t rockchip_usb2phy_irq(int irq, void *data)
 	struct rockchip_usb2phy_port *rport;
 	irqreturn_t ret = IRQ_NONE;
 	unsigned int index;
+	bool force_mode;
 
 	for (index = 0; index < rphy->phy_cfg->num_ports; index++) {
 		rport = &rphy->ports[index];
 		if (!rport->phy)
 			continue;
 
+		/*
+		 * Handle disc irq before linestate irq to set the disc
+		 * state for sm work scheduled in the linestate irq handler.
+		 */
+		if (rport->port_id == USB2PHY_PORT_HOST &&
+		    rport->port_cfg->disfall_en.offset)
+			ret |= rockchip_usb2phy_host_disc_irq(irq, rport);
+
 		switch (rport->port_id) {
 		case USB2PHY_PORT_OTG:
 			if (rport->mode != USB_DR_MODE_HOST &&
@@ -988,6 +1784,33 @@ static irqreturn_t rockchip_usb2phy_irq(int irq, void *data)
 			ret |= rockchip_usb2phy_linestate_irq(irq, rport);
 			break;
 		}
+
+		/*
+		 * Handle bvalid irq and id irq for otg port which
+		 * is assigned to otg controller.
+		 */
+		if (rport->port_id == USB2PHY_PORT_OTG &&
+		    rport->mode != USB_DR_MODE_UNKNOWN) {
+			if (rport->mode == USB_DR_MODE_HOST) {
+				/*
+				 * If otg port work as usb host mode and
+				 * force_mode is true, it means that the
+				 * otg port is forced to host mode by the
+				 * grf plug iddig indicator via the sys
+				 * interface "otg_mode". We need to handle
+				 * the bvalid irq and id irq in this case.
+				 */
+				force_mode = property_enabled(rphy->grf,
+						&rport->port_cfg->iddig_en);
+				if (!force_mode)
+					continue;
+			}
+
+			if (!rport->vbus_always_on)
+				ret |= rockchip_usb2phy_bvalid_irq(irq, rport);
+
+			ret |= rockchip_usb2phy_id_irq(irq, rport);
+		}
 	}
 
 	return ret;
@@ -1006,108 +1829,187 @@ static int rockchip_usb2phy_port_irq_init(struct rockchip_usb2phy *rphy,
 	if (rphy->irq > 0)
 		return 0;
 
-	switch (rport->port_id) {
-	case USB2PHY_PORT_HOST:
-		rport->ls_irq = of_irq_get_byname(child_np, "linestate");
-		if (rport->ls_irq < 0) {
-			dev_err(rphy->dev, "no linestate irq provided\n");
-			return rport->ls_irq;
+	/*
+	 * Some SoCs (e.g. RV1108) use one combined irq for all of
+	 * the irqs of otg port. So probe the otg-mux interrupt first,
+	 * if not found, then init the regular irqs one by one.
+	 */
+	rport->otg_mux_irq = of_irq_get_byname(child_np, "otg-mux");
+	if (rport->otg_mux_irq > 0) {
+		ret = devm_request_threaded_irq(rphy->dev, rport->otg_mux_irq,
+						NULL,
+						rockchip_usb2phy_otg_mux_irq,
+						IRQF_ONESHOT,
+						"rockchip_usb2phy_otg",
+						rport);
+		if (ret)
+			dev_err(rphy->dev,
+				"failed to request otg-mux irq handle\n");
+
+		return ret;
+	}
+
+	/* Init linestate irq for both otg port and host port */
+	rport->ls_irq = of_irq_get_byname(child_np, "linestate");
+	if (rport->ls_irq <= 0) {
+		dev_err(rphy->dev, "no linestate irq provided\n");
+		return -EINVAL;
+	}
+
+	ret = devm_request_threaded_irq(rphy->dev, rport->ls_irq, NULL,
+					rockchip_usb2phy_linestate_irq,
+					IRQF_ONESHOT,
+					"rockchip_usb2phy_ls", rport);
+	if (ret) {
+		dev_err(rphy->dev, "failed to request linestate irq handle\n");
+		return ret;
+	}
+
+	/*
+	 * If it's host port or it's otg port but only support
+	 * host mode, return immediately without init the bvalid
+	 * and id irqs/
+	 */
+	if (rport->port_id == USB2PHY_PORT_HOST ||
+	    rport->mode == USB_DR_MODE_HOST ||
+	    rport->mode == USB_DR_MODE_UNKNOWN)
+		return ret;
+
+	/* Init the bvalid irq for otg port */
+	if (!rport->vbus_always_on) {
+		rport->bvalid_irq = of_irq_get_byname(child_np,
+						      "otg-bvalid");
+		if (rport->bvalid_irq <= 0) {
+			dev_err(rphy->dev, "no bvalid irq provided\n");
+			return -EINVAL;
 		}
 
-		ret = devm_request_threaded_irq(rphy->dev, rport->ls_irq, NULL,
-						rockchip_usb2phy_linestate_irq,
+		ret = devm_request_threaded_irq(rphy->dev,
+						rport->bvalid_irq,
+						NULL,
+						rockchip_usb2phy_bvalid_irq,
 						IRQF_ONESHOT,
-						"rockchip_usb2phy", rport);
+						"rockchip_usb2phy_bvalid",
+						rport);
 		if (ret) {
-			dev_err(rphy->dev, "failed to request linestate irq handle\n");
+			dev_err(rphy->dev,
+				"failed to request otg-bvalid irq handle\n");
 			return ret;
 		}
-		break;
-	case USB2PHY_PORT_OTG:
-		/*
-		 * Some SoCs use one interrupt with otg-id/otg-bvalid/linestate
-		 * interrupts muxed together, so probe the otg-mux interrupt first,
-		 * if not found, then look for the regular interrupts one by one.
-		 */
-		rport->otg_mux_irq = of_irq_get_byname(child_np, "otg-mux");
-		if (rport->otg_mux_irq > 0) {
-			ret = devm_request_threaded_irq(rphy->dev, rport->otg_mux_irq,
-							NULL,
-							rockchip_usb2phy_otg_mux_irq,
-							IRQF_ONESHOT,
-							"rockchip_usb2phy_otg",
-							rport);
-			if (ret) {
-				dev_err(rphy->dev,
-					"failed to request otg-mux irq handle\n");
-				return ret;
-			}
-		} else {
-			rport->bvalid_irq = of_irq_get_byname(child_np, "otg-bvalid");
-			if (rport->bvalid_irq < 0) {
-				dev_err(rphy->dev, "no vbus valid irq provided\n");
-				ret = rport->bvalid_irq;
-				return ret;
-			}
-
-			ret = devm_request_threaded_irq(rphy->dev, rport->bvalid_irq,
-							NULL,
-							rockchip_usb2phy_bvalid_irq,
-							IRQF_ONESHOT,
-							"rockchip_usb2phy_bvalid",
-							rport);
-			if (ret) {
-				dev_err(rphy->dev,
-					"failed to request otg-bvalid irq handle\n");
-				return ret;
-			}
+	}
 
-			rport->id_irq = of_irq_get_byname(child_np, "otg-id");
-			if (rport->id_irq < 0) {
-				dev_err(rphy->dev, "no otg-id irq provided\n");
-				ret = rport->id_irq;
-				return ret;
-			}
+	/* Init the id irq for otg port */
+	if (rphy->edev_self) {
+		rport->id_irq = of_irq_get_byname(child_np, "otg-id");
+		if (rport->id_irq <= 0) {
+			dev_err(rphy->dev, "no otg id irq provided\n");
+			return -EINVAL;
+		}
 
-			ret = devm_request_threaded_irq(rphy->dev, rport->id_irq,
-							NULL,
-							rockchip_usb2phy_id_irq,
-							IRQF_ONESHOT,
-							"rockchip_usb2phy_id",
-							rport);
-			if (ret) {
-				dev_err(rphy->dev,
-					"failed to request otg-id irq handle\n");
-				return ret;
-			}
+		ret = devm_request_threaded_irq(rphy->dev,
+						rport->id_irq, NULL,
+						rockchip_usb2phy_id_irq,
+						IRQF_ONESHOT,
+						"rockchip_usb2phy_id",
+						rport);
+		if (ret) {
+			dev_err(rphy->dev,
+				"failed to request otg-id irq handle\n");
+			return ret;
 		}
-		break;
-	default:
-		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static void rockchip_usb2phy_usb_bvalid_enable(struct rockchip_usb2phy_port *rport,
+					       u8 enable)
+{
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);
+	const struct rockchip_usb2phy_port_cfg *cfg = rport->port_cfg;
+
+	if (cfg->bvalid_phy_con.enable)
+		property_enable(rphy->grf, &cfg->bvalid_phy_con, enable);
+
+	if (cfg->bvalid_grf_con.enable)
+		property_enable(rphy->grf, &cfg->bvalid_grf_con, enable);
+}
+
+static int rockchip_usb2phy_orien_sw_set(struct typec_switch_dev *sw,
+					 enum typec_orientation orien)
+{
+	struct rockchip_usb2phy_port *rport = typec_switch_get_drvdata(sw);
+
+	dev_dbg(&rport->phy->dev, "type-c orientation: %d\n", orien);
+
+	mutex_lock(&rport->mutex);
+	rockchip_usb2phy_usb_bvalid_enable(rport, orien != TYPEC_ORIENTATION_NONE);
+	mutex_unlock(&rport->mutex);
+
+	return 0;
+}
+
+static int
+rockchip_usb2phy_setup_orien_switch(struct rockchip_usb2phy *rphy,
+				    struct rockchip_usb2phy_port *rport)
+{
+	struct typec_switch_desc sw_desc = { };
+	struct device *dev = rphy->dev;
+
+	sw_desc.drvdata = rport;
+	sw_desc.fwnode = dev_fwnode(dev);
+	sw_desc.set = rockchip_usb2phy_orien_sw_set;
+
+	rport->sw = typec_switch_register(dev, &sw_desc);
+	if (IS_ERR(rport->sw)) {
+		dev_err(dev, "Error register typec orientation switch: %ld\n",
+			PTR_ERR(rport->sw));
+		return PTR_ERR(rport->sw);
 	}
 
 	return 0;
 }
 
+static void rockchip_usb2phy_orien_switch_unregister(void *data)
+{
+	struct rockchip_usb2phy_port *rport = data;
+
+	typec_switch_unregister(rport->sw);
+}
+
 static int rockchip_usb2phy_host_port_init(struct rockchip_usb2phy *rphy,
 					   struct rockchip_usb2phy_port *rport,
 					   struct device_node *child_np)
 {
 	int ret;
+	struct regmap *base = get_reg_base(rphy);
 
 	rport->port_id = USB2PHY_PORT_HOST;
 	rport->port_cfg = &rphy->phy_cfg->port_cfgs[USB2PHY_PORT_HOST];
-	rport->suspended = true;
+
+	/* enter lower power state when suspend */
+	rport->low_power_en =
+		of_property_read_bool(child_np, "rockchip,low-power-mode");
 
 	mutex_init(&rport->mutex);
 	INIT_DELAYED_WORK(&rport->sm_work, rockchip_usb2phy_sm_work);
 
 	ret = rockchip_usb2phy_port_irq_init(rphy, rport, child_np);
 	if (ret) {
-		dev_err(rphy->dev, "failed to setup host irq\n");
+		dev_err(rphy->dev, "failed to init irq for host port\n");
 		return ret;
 	}
 
+	/*
+	 * Let us put phy-port into suspend mode here for saving power
+	 * consumption, and usb controller will resume it during probe
+	 * time if needed.
+	 */
+	ret = property_enable(base, &rport->port_cfg->phy_sus, true);
+	if (ret)
+		return ret;
+	rport->suspended = true;
+
 	return 0;
 }
 
@@ -1126,39 +2028,124 @@ static int rockchip_usb2phy_otg_port_init(struct rockchip_usb2phy *rphy,
 					  struct rockchip_usb2phy_port *rport,
 					  struct device_node *child_np)
 {
-	int ret, id;
+	int ret;
+	int iddig;
+	struct regmap *base = get_reg_base(rphy);
 
 	rport->port_id = USB2PHY_PORT_OTG;
 	rport->port_cfg = &rphy->phy_cfg->port_cfgs[USB2PHY_PORT_OTG];
 	rport->state = OTG_STATE_UNDEFINED;
-
-	/*
-	 * set suspended flag to true, but actually don't
-	 * put phy in suspend mode, it aims to enable usb
-	 * phy and clock in power_on() called by usb controller
-	 * driver during probe.
-	 */
-	rport->suspended = true;
 	rport->vbus_attached = false;
+	rport->vbus_enabled = false;
+	rport->perip_connected = false;
+	rport->prev_iddig = true;
 
 	mutex_init(&rport->mutex);
 
-	rport->mode = of_usb_get_dr_mode_by_phy(child_np, -1);
-	if (rport->mode == USB_DR_MODE_HOST ||
-	    rport->mode == USB_DR_MODE_UNKNOWN) {
-		ret = 0;
-		goto out;
+	/* bypass uart function is only used in debug stage. */
+	rport->bypass_uart_en =
+		of_property_read_bool(child_np, "rockchip,bypass-uart");
+	rport->vbus_always_on =
+		of_property_read_bool(child_np, "rockchip,vbus-always-on");
+	rport->utmi_avalid =
+		of_property_read_bool(child_np, "rockchip,utmi-avalid");
+	rport->dis_u2_susphy =
+		of_property_read_bool(child_np, "rockchip,dis-u2-susphy");
+
+	/* enter lower power state when suspend */
+	rport->low_power_en =
+		of_property_read_bool(child_np, "rockchip,low-power-mode");
+
+	/* For type-c with vbus_det always pull up */
+	rport->typec_vbus_det =
+		of_property_read_bool(child_np, "rockchip,typec-vbus-det");
+
+	rport->sel_pipe_phystatus =
+		of_property_read_bool(child_np, "rockchip,sel-pipe-phystatus");
+
+	if (rport->sel_pipe_phystatus) {
+		rphy->usbctrl_grf =
+			syscon_regmap_lookup_by_phandle(rphy->dev->of_node,
+							"rockchip,usbctrl-grf");
+		if (IS_ERR(rphy->usbctrl_grf)) {
+			dev_err(rphy->dev, "Failed to map usbctrl-grf\n");
+			return PTR_ERR(rphy->usbctrl_grf);
+		}
 	}
 
-	INIT_DELAYED_WORK(&rport->chg_work, rockchip_chg_detect_work);
-	INIT_DELAYED_WORK(&rport->otg_sm_work, rockchip_usb2phy_otg_sm_work);
+	/* Get Vbus regulators */
+	rport->vbus = devm_regulator_get_optional(&rport->phy->dev, "vbus");
+	if (IS_ERR(rport->vbus)) {
+		ret = PTR_ERR(rport->vbus);
+		if (ret == -EPROBE_DEFER)
+			return ret;
+
+		if (rport->mode == USB_DR_MODE_OTG)
+			dev_warn(&rport->phy->dev, "No vbus specified for otg port\n");
+		rport->vbus = NULL;
+	}
+
+	rport->mode = of_usb_get_dr_mode_by_phy(child_np, -1);
+	iddig = property_enabled(rphy->grf, &rport->port_cfg->utmi_iddig);
+	if (rphy->edev_self && (rport->mode == USB_DR_MODE_HOST ||
+	    rport->mode == USB_DR_MODE_UNKNOWN || !iddig)) {
+		/* Enable VBUS supply for otg port */
+		extcon_set_state(rphy->edev, EXTCON_USB, false);
+		extcon_set_state(rphy->edev, EXTCON_USB_HOST, true);
+		extcon_set_state(rphy->edev, EXTCON_PROP_USB_VBUS, true);
+		ret = rockchip_set_vbus_power(rport, true);
+		if (ret)
+			return ret;
+	}
 
 	ret = rockchip_usb2phy_port_irq_init(rphy, rport, child_np);
 	if (ret) {
-		dev_err(rphy->dev, "failed to init irq for host port\n");
-		goto out;
+		dev_err(rphy->dev, "failed to init irq for otg port\n");
+		return ret;
 	}
 
+	if (IS_REACHABLE(CONFIG_TYPEC) &&
+	    device_property_present(rphy->dev, "orientation-switch")) {
+		ret = rockchip_usb2phy_setup_orien_switch(rphy, rport);
+		if (ret)
+			return ret;
+
+		ret = devm_add_action_or_reset(rphy->dev,
+					       rockchip_usb2phy_orien_switch_unregister,
+					       rport);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * Set the utmi bvalid come from the usb phy or grf.
+	 * For most of Rockchip SoCs, them have VBUSDET pin
+	 * for the usb phy to detect the USB VBUS and set
+	 * the bvalid signal, so select the bvalid from the
+	 * usb phy by default. And for those SoCs which don't
+	 * have VBUSDET pin (e.g. RV1103), it needs to select
+	 * the bvaid from the grf and set bvalid to be valid
+	 * (high) by default.
+	 */
+	if (rport->port_cfg->bvalid_grf_sel.enable != 0) {
+		if (of_machine_is_compatible("rockchip,rv1103"))
+			property_enable(base, &rport->port_cfg->bvalid_grf_sel, true);
+		else
+			property_enable(base, &rport->port_cfg->bvalid_grf_sel, false);
+	}
+
+	if (rport->vbus_always_on)
+		extcon_set_state(rphy->edev, EXTCON_USB, true);
+
+	if (rport->vbus_always_on || rport->mode == USB_DR_MODE_HOST ||
+	    rport->mode == USB_DR_MODE_UNKNOWN)
+		goto out;
+
+	INIT_DELAYED_WORK(&rport->bypass_uart_work,
+			  rockchip_usb_bypass_uart_work);
+	INIT_DELAYED_WORK(&rport->chg_work, rockchip_chg_detect_work);
+	INIT_DELAYED_WORK(&rport->otg_sm_work, rockchip_usb2phy_otg_sm_work);
+
 	if (!IS_ERR(rphy->edev)) {
 		rport->event_nb.notifier_call = rockchip_otg_event;
 
@@ -1166,17 +2153,24 @@ static int rockchip_usb2phy_otg_port_init(struct rockchip_usb2phy *rphy,
 					EXTCON_USB_HOST, &rport->event_nb);
 		if (ret) {
 			dev_err(rphy->dev, "register USB HOST notifier failed\n");
-			goto out;
-		}
-
-		if (!of_property_read_bool(rphy->dev->of_node, "extcon")) {
-			/* do initial sync of usb state */
-			id = property_enabled(rphy->grf, &rport->port_cfg->utmi_id);
-			extcon_set_state_sync(rphy->edev, EXTCON_USB_HOST, !id);
+			goto err;
 		}
 	}
 
 out:
+	/*
+	 * Let us put phy-port into suspend mode here for saving power
+	 * consumption, and usb controller will resume it during probe
+	 * time if needed.
+	 */
+	ret = property_enable(base, &rport->port_cfg->phy_sus, true);
+	if (ret)
+		return ret;
+	rport->suspended = true;
+
+	return 0;
+
+err:
 	return ret;
 }
 
@@ -1187,10 +2181,12 @@ static int rockchip_usb2phy_probe(struct platform_device *pdev)
 	struct device_node *child_np;
 	struct phy_provider *provider;
 	struct rockchip_usb2phy *rphy;
+	struct resource *res;
 	const struct rockchip_usb2phy_cfg *phy_cfgs;
 	const struct of_device_id *match;
 	unsigned int reg;
-	int index, ret;
+	unsigned int index;
+	int ret;
 
 	rphy = devm_kzalloc(dev, sizeof(*rphy), GFP_KERNEL);
 	if (!rphy)
@@ -1203,49 +2199,59 @@ static int rockchip_usb2phy_probe(struct platform_device *pdev)
 	}
 
 	if (!dev->parent || !dev->parent->of_node) {
-		rphy->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,usbgrf");
-		if (IS_ERR(rphy->grf)) {
-			dev_err(dev, "failed to locate usbgrf\n");
-			return PTR_ERR(rphy->grf);
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_err(dev, "missing memory resource\n");
+			return -ENODEV;
 		}
-	}
 
-	else {
-		rphy->grf = syscon_node_to_regmap(dev->parent->of_node);
+		rphy->phy_base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(rphy->phy_base))
+			return PTR_ERR(rphy->phy_base);
+
+		rphy->grf = syscon_regmap_lookup_by_phandle(np,
+							    "rockchip,usbgrf");
 		if (IS_ERR(rphy->grf))
 			return PTR_ERR(rphy->grf);
-	}
 
-	if (of_device_is_compatible(np, "rockchip,rv1108-usb2phy")) {
-		rphy->usbgrf =
-			syscon_regmap_lookup_by_phandle(dev->of_node,
-							"rockchip,usbgrf");
-		if (IS_ERR(rphy->usbgrf))
-			return PTR_ERR(rphy->usbgrf);
+		reg = res->start;
 	} else {
-		rphy->usbgrf = NULL;
-	}
+		rphy->grf = syscon_node_to_regmap(dev->parent->of_node);
+		if (IS_ERR(rphy->grf))
+			return PTR_ERR(rphy->grf);
 
-	if (of_property_read_u32_index(np, "reg", 0, &reg)) {
-		dev_err(dev, "the reg property is not assigned in %pOFn node\n",
-			np);
-		return -EINVAL;
-	}
+		if (of_device_is_compatible(np, "rockchip,rv1108-usb2phy")) {
+			rphy->usbgrf =
+				syscon_regmap_lookup_by_phandle(dev->of_node,
+							"rockchip,usbgrf");
+			if (IS_ERR(rphy->usbgrf))
+				return PTR_ERR(rphy->usbgrf);
+		} else {
+			rphy->usbgrf = NULL;
+		}
 
-	/* support address_cells=2 */
-	if (reg == 0) {
-		if (of_property_read_u32_index(np, "reg", 1, &reg)) {
+		if (of_property_read_u32_index(np, "reg", 0, &reg)) {
 			dev_err(dev, "the reg property is not assigned in %pOFn node\n",
 				np);
 			return -EINVAL;
 		}
+
+		/* support address_cells=2 */
+		if (reg == 0) {
+			if (of_property_read_u32_index(np, "reg", 1, &reg)) {
+				dev_err(dev, "the reg property is not assigned in %pOFn node\n",
+					np);
+				return -EINVAL;
+			}
+		}
 	}
 
 	rphy->dev = dev;
 	phy_cfgs = match->data;
 	rphy->chg_state = USB_CHG_STATE_UNDEFINED;
 	rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
-	rphy->irq = platform_get_irq_optional(pdev, 0);
+	rphy->edev_self = false;
+	rphy->irq = platform_get_irq(pdev, 0);
 	platform_set_drvdata(pdev, rphy);
 
 	ret = rockchip_usb2phy_extcon_register(rphy);
@@ -1254,133 +2260,903 @@ static int rockchip_usb2phy_probe(struct platform_device *pdev)
 
 	/* find out a proper config which can be matched with dt. */
 	index = 0;
-	while (phy_cfgs[index].reg) {
+	do {
 		if (phy_cfgs[index].reg == reg) {
 			rphy->phy_cfg = &phy_cfgs[index];
 			break;
 		}
 
-		++index;
-	}
+		++index;
+	} while (phy_cfgs[index].reg);
+
+	if (!rphy->phy_cfg) {
+		dev_err(dev, "no phy-config can be matched with %pOFn node\n",
+			np);
+		return -EINVAL;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+
+	rphy->phy_reset = devm_reset_control_get_optional(dev, "phy");
+	if (IS_ERR(rphy->phy_reset))
+		return PTR_ERR(rphy->phy_reset);
+
+	ret = devm_clk_bulk_get_all(dev, &rphy->clks);
+	if (ret == -EPROBE_DEFER)
+		return ret;
+
+	/* Clocks are optional */
+	if (ret < 0)
+		rphy->num_clks = 0;
+	else
+		rphy->num_clks = ret;
+
+	ret = clk_bulk_prepare_enable(rphy->num_clks, rphy->clks);
+	if (ret)
+		return ret;
+
+	if (rphy->phy_cfg->phy_tuning) {
+		ret = rphy->phy_cfg->phy_tuning(rphy);
+		if (ret)
+			goto disable_clks;
+	}
+
+	index = 0;
+	for_each_available_child_of_node(np, child_np) {
+		struct rockchip_usb2phy_port *rport = &rphy->ports[index];
+		struct phy *phy;
+
+		/* This driver aims to support both otg-port and host-port */
+		if (!of_node_name_eq(child_np, "host-port") &&
+		    !of_node_name_eq(child_np, "otg-port"))
+			goto next_child;
+
+		phy = devm_phy_create(dev, child_np, &rockchip_usb2phy_ops);
+		if (IS_ERR(phy)) {
+			dev_err_probe(dev, PTR_ERR(phy), "failed to create phy\n");
+			ret = PTR_ERR(phy);
+			goto put_child;
+		}
+
+		rport->phy = phy;
+		phy_set_drvdata(rport->phy, rport);
+
+		/* initialize otg/host port separately */
+		if (of_node_name_eq(child_np, "host-port")) {
+			ret = rockchip_usb2phy_host_port_init(rphy, rport,
+							      child_np);
+			if (ret)
+				goto put_child;
+		} else {
+			ret = rockchip_usb2phy_otg_port_init(rphy, rport,
+							     child_np);
+			if (ret)
+				goto put_child;
+		}
+
+next_child:
+		/* to prevent out of boundary */
+		if (++index >= rphy->phy_cfg->num_ports) {
+			of_node_put(child_np);
+			break;
+		}
+	}
+
+	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(provider)) {
+		dev_err(dev, "Failed to register phy provider\n");
+		ret = PTR_ERR(provider);
+		goto put_child;
+	}
+
+	/* Attributes */
+	ret = sysfs_create_group(&dev->kobj, &usb2_phy_attr_group);
+	if (ret) {
+		dev_err(dev, "Cannot create sysfs group: %d\n", ret);
+		goto put_child;
+	}
+
+	ret = rockchip_usb2phy_clk480m_register(rphy);
+	if (ret) {
+		dev_err(dev, "failed to register 480m output clock\n");
+		goto put_child;
+	}
+
+	if (rphy->irq > 0) {
+		ret = devm_request_threaded_irq(rphy->dev, rphy->irq, NULL,
+						rockchip_usb2phy_irq,
+						IRQF_ONESHOT,
+						"rockchip_usb2phy",
+						rphy);
+		if (ret) {
+			dev_err(rphy->dev,
+				"failed to request usb2 phy irq handle\n");
+			goto put_child;
+		}
+	}
+
+	if (of_property_read_bool(np, "wakeup-source"))
+		device_init_wakeup(rphy->dev, true);
+	else
+		device_init_wakeup(rphy->dev, false);
+
+	return 0;
+
+put_child:
+	of_node_put(child_np);
+disable_clks:
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+	clk_bulk_disable_unprepare(rphy->num_clks, rphy->clks);
+	return ret;
+}
+
+static int __maybe_unused
+rockchip_usb2phy_low_power_enable(struct rockchip_usb2phy *rphy,
+				  struct rockchip_usb2phy_port *rport,
+				  bool value)
+{
+	int ret = 0;
+
+	if (!rport->low_power_en)
+		return ret;
+
+	if (rport->port_id == USB2PHY_PORT_OTG) {
+		dev_info(&rport->phy->dev, "set otg port low power state %d\n",
+			 value);
+		ret = property_enable(rphy->grf, &rport->port_cfg->bypass_bc,
+				      value);
+		if (ret)
+			return ret;
+
+		ret = property_enable(rphy->grf, &rport->port_cfg->bypass_otg,
+				      value);
+		if (ret)
+			return ret;
+
+		ret = property_enable(rphy->grf, &rport->port_cfg->vbus_det_en,
+				      !value);
+	} else if (rport->port_id == USB2PHY_PORT_HOST) {
+		dev_info(&rport->phy->dev, "set host port low power state %d\n",
+			 value);
+
+		ret = property_enable(rphy->grf, &rport->port_cfg->bypass_host,
+				      value);
+	}
+
+	return ret;
+}
+
+static int rk312x_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret;
+
+	/* Turn off differential receiver in suspend mode */
+	ret = regmap_write(rphy->grf, 0x298, 0x00040000);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int rk3228_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret = 0;
+
+	/* Open pre-emphasize in non-chirp state for PHY0 otg port */
+	if (rphy->phy_cfg->reg == 0x760)
+		ret = regmap_write(rphy->grf, 0x76c, 0x00070004);
+
+	return ret;
+}
+
+static int rk3308_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret;
+
+	if (soc_is_rk3308bs()) {
+		/* Turn off differential receiver in suspend mode */
+		ret = regmap_update_bits(rphy->grf, 0x30, BIT(2), 0);
+		if (ret)
+			return ret;
+
+		/* Enable otg port pre-emphasis during non-chirp phase */
+		ret = regmap_update_bits(rphy->grf, 0, GENMASK(2, 0), BIT(2));
+		if (ret)
+			return ret;
+
+		/* Set otg port squelch trigger point configure to 100mv */
+		ret = regmap_update_bits(rphy->grf, 0x004, GENMASK(7, 5), 0x40);
+		if (ret)
+			return ret;
+
+		ret = regmap_update_bits(rphy->grf, 0x008, BIT(0), 0x1);
+		if (ret)
+			return ret;
+
+		/* Enable host port pre-emphasis during non-chirp phase */
+		ret = regmap_update_bits(rphy->grf, 0x400, GENMASK(2, 0), BIT(2));
+		if (ret)
+			return ret;
+
+		/* Set host port squelch trigger point configure to 100mv */
+		ret = regmap_update_bits(rphy->grf, 0x404, GENMASK(7, 5), 0x40);
+		if (ret)
+			return ret;
+
+		ret = regmap_update_bits(rphy->grf, 0x408, BIT(0), 0x1);
+		if (ret)
+			return ret;
+	} else {
+		/* Open pre-emphasize in non-chirp state for otg port */
+		ret = regmap_write(rphy->grf, 0x0, 0x00070004);
+		if (ret)
+			return ret;
+
+		/* Open pre-emphasize in non-chirp state for host port */
+		ret = regmap_write(rphy->grf, 0x30, 0x00070004);
+		if (ret)
+			return ret;
+
+		/* Turn off differential receiver in suspend mode */
+		ret = regmap_write(rphy->grf, 0x18, 0x00040000);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rk3328_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret;
+
+	if (soc_is_px30s()) {
+		/* Enable otg port pre-emphasis during non-chirp phase */
+		ret = regmap_update_bits(rphy->grf, 0x8000, GENMASK(2, 0), BIT(2));
+		if (ret)
+			return ret;
+
+		/* Set otg port squelch trigger point configure to 100mv */
+		ret = regmap_update_bits(rphy->grf, 0x8004, GENMASK(7, 5), 0x40);
+		if (ret)
+			return ret;
+
+		ret = regmap_update_bits(rphy->grf, 0x8008, BIT(0), 0x1);
+		if (ret)
+			return ret;
+
+		/* Turn off otg port differential reciver in suspend mode */
+		ret = regmap_update_bits(rphy->grf, 0x8030, BIT(2), 0);
+		if (ret)
+			return ret;
+
+		/* Enable host port pre-emphasis during non-chirp phase */
+		ret = regmap_update_bits(rphy->grf, 0x8400, GENMASK(2, 0), BIT(2));
+		if (ret)
+			return ret;
+
+		/* Set host port squelch trigger point configure to 100mv */
+		ret = regmap_update_bits(rphy->grf, 0x8404, GENMASK(7, 5), 0x40);
+		if (ret)
+			return ret;
+
+		ret = regmap_update_bits(rphy->grf, 0x8408, BIT(0), 0x1);
+		if (ret)
+			return ret;
+
+		/* Turn off host port differential reciver in suspend mode */
+		ret = regmap_update_bits(rphy->grf, 0x8430, BIT(2), 0);
+		if (ret)
+			return ret;
+	} else {
+		/* Open debug mode for tuning */
+		ret = regmap_write(rphy->grf, 0x2c, 0xffff0400);
+		if (ret)
+			return ret;
+
+		/* Open pre-emphasize in non-chirp state for otg port */
+		ret = regmap_write(rphy->grf, 0x0, 0x00070004);
+		if (ret)
+			return ret;
+
+		/* Open pre-emphasize in non-chirp state for host port */
+		ret = regmap_write(rphy->grf, 0x30, 0x00070004);
+		if (ret)
+			return ret;
+
+		/* Turn off differential receiver in suspend mode */
+		ret = regmap_write(rphy->grf, 0x18, 0x00040000);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static int rk3366_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	unsigned int open_pre_emphasize = 0xffff851f;
+	unsigned int eye_height_tuning = 0xffff68c8;
+	unsigned int compensation_tuning = 0xffff026e;
+	int ret = 0;
+
+	/* open HS pre-emphasize to expand HS slew rate for each port. */
+	ret |= regmap_write(rphy->grf, 0x0780, open_pre_emphasize);
+	ret |= regmap_write(rphy->grf, 0x079c, eye_height_tuning);
+	ret |= regmap_write(rphy->grf, 0x07b0, open_pre_emphasize);
+	ret |= regmap_write(rphy->grf, 0x07cc, eye_height_tuning);
+
+	/* compensate default tuning reference relate to ODT and etc. */
+	ret |= regmap_write(rphy->grf, 0x078c, compensation_tuning);
+
+	return ret;
+}
+
+static int rk3399_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	struct device_node *node = rphy->dev->of_node;
+	int ret = 0;
+
+	if (rphy->phy_cfg->reg == 0xe450) {
+		/*
+		 * Disable the pre-emphasize in eop state
+		 * and chirp state to avoid mis-trigger the
+		 * disconnect detection and also avoid hs
+		 * handshake fail for PHY0.
+		 */
+		ret |= regmap_write(rphy->grf, 0x4480,
+				    GENMASK(17, 16) | 0x0);
+		ret |= regmap_write(rphy->grf, 0x44b4,
+				    GENMASK(17, 16) | 0x0);
+	} else {
+		/*
+		 * Disable the pre-emphasize in eop state
+		 * and chirp state to avoid mis-trigger the
+		 * disconnect detection and also avoid hs
+		 * handshake fail for PHY1.
+		 */
+		ret |= regmap_write(rphy->grf, 0x4500,
+				    GENMASK(17, 16) | 0x0);
+		ret |= regmap_write(rphy->grf, 0x4534,
+				    GENMASK(17, 16) | 0x0);
+	}
+
+	if (!of_property_read_bool(node, "rockchip,u2phy-tuning"))
+		return ret;
+
+	if (rphy->phy_cfg->reg == 0xe450) {
+		/*
+		 * Set max ODT compensation voltage and
+		 * current tuning reference for PHY0.
+		 */
+		ret |= regmap_write(rphy->grf, 0x448c,
+				    GENMASK(23, 16) | 0xe3);
+
+		/* Set max pre-emphasis level for PHY0 */
+		ret |= regmap_write(rphy->grf, 0x44b0,
+				    GENMASK(18, 16) | 0x07);
+
+		/*
+		 * Set PHY0 A port squelch trigger point to 125mv
+		 */
+		ret |= regmap_write(rphy->grf, 0x4480,
+				    GENMASK(30, 30) | 0x4000);
+	} else {
+		/*
+		 * Set max ODT compensation voltage and
+		 * current tuning reference for PHY1.
+		 */
+		ret |= regmap_write(rphy->grf, 0x450c,
+				    GENMASK(23, 16) | 0xe3);
+
+		/* Set max pre-emphasis level for PHY1 */
+		ret |= regmap_write(rphy->grf, 0x4530,
+				    GENMASK(18, 16) | 0x07);
+
+		/*
+		 * Set PHY1 A port squelch trigger point to 125mv
+		 */
+		ret |= regmap_write(rphy->grf, 0x4500,
+				    GENMASK(30, 30) | 0x4000);
+	}
+
+	return ret;
+}
+
+static int rk3568_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret = 0;
+
+	/* Turn off differential receiver by default to save power */
+	phy_clear_bits(rphy->phy_base + 0x30, BIT(2));
+
+	/* Enable otg port pre-emphasis during non-chirp phase */
+	phy_update_bits(rphy->phy_base, GENMASK(2, 0), 0x04);
+
+	/* Enable host port pre-emphasis during non-chirp phase */
+	phy_update_bits(rphy->phy_base + 0x0400, GENMASK(2, 0), 0x04);
+
+	if (rphy->phy_cfg->reg == 0xfe8a0000) {
+		/* Set otg port HS eye height to 437.5mv(default is 400mv) */
+		phy_update_bits(rphy->phy_base + 0x30, GENMASK(6, 4), (0x06 << 4));
+
+		/*
+		 * Set the bvalid filter time to 10ms
+		 * based on the usb2 phy grf pclk 100MHz.
+		 */
+		ret |= regmap_write(rphy->grf, 0x0048, FILTER_COUNTER);
+
+		/*
+		 * Set the id filter time to 10ms based
+		 * on the usb2 phy grf pclk 100MHz.
+		 */
+		ret |= regmap_write(rphy->grf, 0x004c, FILTER_COUNTER);
+	}
+
+	/* Enable host port (usb3 host1 and usb2 host1) wakeup irq */
+	ret |= regmap_write(rphy->grf, 0x000c, 0x80008000);
+
+	return ret;
+}
+
+static int rv1106_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	/* Always enable pre-emphasis in SOF & EOP & chirp & non-chirp state */
+	phy_update_bits(rphy->phy_base + 0x30, GENMASK(2, 0), 0x07);
+
+	if (rockchip_get_cpu_version()) {
+		/* Set Tx HS pre_emphasize strength to 3'b001 */
+		phy_update_bits(rphy->phy_base + 0x40, GENMASK(5, 3), (0x01 << 3));
+	} else {
+		/* Set Tx HS pre_emphasize strength to 3'b011 */
+		phy_update_bits(rphy->phy_base + 0x40, GENMASK(5, 3), (0x03 << 3));
+	}
+
+	/* Set RX Squelch trigger point configure to 4'b0000(112.5 mV) */
+	phy_update_bits(rphy->phy_base + 0x64, GENMASK(6, 3), (0x00 << 3));
+
+	/* Turn off differential receiver by default to save power */
+	phy_clear_bits(rphy->phy_base + 0x100, BIT(6));
+
+	/* Set 45ohm HS ODT value to 5'b10111 to increase driver strength */
+	phy_update_bits(rphy->phy_base + 0x11c, GENMASK(4, 0), 0x17);
+
+	/* Set Tx HS eye height tuning to 3'b011(462 mV)*/
+	phy_update_bits(rphy->phy_base + 0x124, GENMASK(4, 2), (0x03 << 2));
+
+	/* Bypass Squelch detector calibration */
+	phy_update_bits(rphy->phy_base + 0x1a4, GENMASK(7, 4), (0x01 << 4));
+	phy_update_bits(rphy->phy_base + 0x1b4, GENMASK(7, 4), (0x01 << 4));
+
+	return 0;
+}
+
+static int rk3568_vbus_detect_control(struct rockchip_usb2phy *rphy, bool en)
+{
+	if (en) {
+		/* Enable vbus voltage level detection function */
+		phy_clear_bits(rphy->phy_base + 0x3c, BIT(7));
+	} else {
+		/* Disable vbus voltage level detection function */
+		phy_set_bits(rphy->phy_base + 0x3c, BIT(7));
+	}
+
+	return 0;
+}
+
+static int rk3588_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	unsigned int reg;
+	int ret = 0;
+
+	/* Read the SIDDQ control register */
+	ret = regmap_read(rphy->grf, 0x0008, &reg);
+	if (ret)
+		return ret;
+
+	if (reg & BIT(13)) {
+		/* Deassert SIDDQ to power on analog block */
+		ret = regmap_write(rphy->grf, 0x0008,
+				   GENMASK(29, 29) | 0x0000);
+		if (ret)
+			return ret;
+
+		/* Do reset after exit IDDQ mode */
+		ret = rockchip_usb2phy_reset(rphy);
+		if (ret)
+			return ret;
+	}
+
+	if (rphy->phy_cfg->reg == 0x0000) {
+		/*
+		 * Set USB2 PHY0 suspend configuration for USB3_0
+		 * 1. Set utmi_termselect to 1'b1 (en FS terminations)
+		 * 2. Set utmi_xcvrselect to 2'b01 (FS transceiver)
+		 * 3. Set utmi_opmode to 2'b01 (no-driving)
+		 */
+		ret |= regmap_write(rphy->grf, 0x000c,
+				    GENMASK(20, 16) | 0x0015);
+
+		/* HS DC Voltage Level Adjustment 4'b1001 : +5.89% */
+		ret |= regmap_write(rphy->grf, 0x0004,
+				   GENMASK(27, 24) | 0x0900);
+
+		/* HS Transmitter Pre-Emphasis Current Control 2'b10 : 2x */
+		ret |= regmap_write(rphy->grf, 0x0008,
+				   GENMASK(20, 19) | 0x0010);
+
+		/* Pullup iddig pin for USB3_0 OTG mode */
+		ret |= regmap_write(rphy->grf, 0x0010,
+				    GENMASK(17, 16) | 0x0003);
+	} else if (rphy->phy_cfg->reg == 0x4000) {
+		/*
+		 * Set USB2 PHY1 suspend configuration for USB3_1
+		 * 1. Set utmi_termselect to 1'b1 (en FS terminations)
+		 * 2. Set utmi_xcvrselect to 2'b01(FS transceiver)
+		 * 3. Set utmi_opmode to 2'b01 (no-driving)
+		 */
+		ret |= regmap_write(rphy->grf, 0x000c,
+				    GENMASK(20, 16) | 0x0015);
+
+		/* HS DC Voltage Level Adjustment 4'b1001 : +5.89% */
+		ret |= regmap_write(rphy->grf, 0x0004,
+				   GENMASK(27, 24) | 0x0900);
+
+		/* HS Transmitter Pre-Emphasis Current Control 2'b10 : 2x */
+		ret |= regmap_write(rphy->grf, 0x0008,
+				   GENMASK(20, 19) | 0x0010);
+
+		/* Pullup iddig pin for USB3_1 OTG mode */
+		ret |= regmap_write(rphy->grf, 0x0010,
+				    GENMASK(17, 16) | 0x0003);
+	} else if (rphy->phy_cfg->reg == 0x8000) {
+		/*
+		 * Set USB2 PHY2 suspend configuration for USB2_0
+		 * 1. Set utmi_termselect to 1'b1 (en FS terminations)
+		 * 2. Set utmi_xcvrselect to 2'b01(FS transceiver)
+		 * 3. Set utmi_opmode to 2'b00 (normal)
+		 */
+		ret |= regmap_write(rphy->grf, 0x000c,
+				    GENMASK(20, 16) | 0x0014);
+
+		/* HS DC Voltage Level Adjustment 4'b1001 : +5.89% */
+		ret |= regmap_write(rphy->grf, 0x0004,
+				   GENMASK(27, 24) | 0x0900);
+
+		/* HS Transmitter Pre-Emphasis Current Control 2'b10 : 2x */
+		ret |= regmap_write(rphy->grf, 0x0008,
+				   GENMASK(20, 19) | 0x0010);
+	} else if (rphy->phy_cfg->reg == 0xc000) {
+		/*
+		 * Set USB2 PHY3 suspend configuration for USB2_1
+		 * 1. Set utmi_termselect to 1'b1 (en FS terminations)
+		 * 2. Set utmi_xcvrselect to 2'b01(FS transceiver)
+		 * 3. Set utmi_opmode to 2'b00 (normal)
+		 */
+		ret |= regmap_write(rphy->grf, 0x000c,
+				    GENMASK(20, 16) | 0x0014);
+
+		/* HS DC Voltage Level Adjustment 4'b1001 : +5.89% */
+		ret |= regmap_write(rphy->grf, 0x0004,
+				   GENMASK(27, 24) | 0x0900);
+
+		/* HS Transmitter Pre-Emphasis Current Control 2'b10 : 2x */
+		ret |= regmap_write(rphy->grf, 0x0008,
+				   GENMASK(20, 19) | 0x0010);
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_usb2phy_pm_suspend(struct device *dev)
+{
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(dev);
+	const struct rockchip_usb2phy_cfg *phy_cfg = rphy->phy_cfg;
+	struct rockchip_usb2phy_port *rport;
+	unsigned int index;
+	int ret = 0;
+	bool wakeup_enable = false;
+
+	if (device_may_wakeup(rphy->dev))
+		wakeup_enable = true;
+
+	/*
+	 * Set the linestate filter time to 1ms based
+	 * on the usb2 phy grf pclk 32KHz on suspend.
+	 */
+	if (phy_cfg->ls_filter_con.enable) {
+		ret = regmap_write(rphy->grf, phy_cfg->ls_filter_con.offset,
+				   phy_cfg->ls_filter_con.enable);
+		if (ret)
+			dev_err(rphy->dev, "failed to set ls filter %d\n", ret);
+	}
+
+	for (index = 0; index < phy_cfg->num_ports; index++) {
+		rport = &rphy->ports[index];
+		if (!rport->phy)
+			continue;
+
+		if (rport->port_id == USB2PHY_PORT_OTG &&
+		    (rport->id_irq > 0 || rphy->irq > 0)) {
+			mutex_lock(&rport->mutex);
+			rport->prev_iddig = property_enabled(rphy->grf,
+						&rport->port_cfg->utmi_iddig);
+			ret = rockchip_usb2phy_enable_id_irq(rphy, rport,
+							     false);
+			mutex_unlock(&rport->mutex);
+			if (ret) {
+				dev_err(rphy->dev,
+					"failed to disable id irq\n");
+				return ret;
+			}
+		}
+
+		if (rport->port_id == USB2PHY_PORT_OTG && wakeup_enable &&
+		    rport->bvalid_irq > 0)
+			enable_irq_wake(rport->bvalid_irq);
 
-	if (!rphy->phy_cfg) {
-		dev_err(dev, "no phy-config can be matched with %pOFn node\n",
-			np);
-		return -EINVAL;
-	}
+		/* activate the linestate to detect the next interrupt. */
+		mutex_lock(&rport->mutex);
+		ret = rockchip_usb2phy_enable_line_irq(rphy, rport, true);
+		mutex_unlock(&rport->mutex);
+		if (ret) {
+			dev_err(rphy->dev, "failed to enable linestate irq\n");
+			return ret;
+		}
 
-	rphy->clk = of_clk_get_by_name(np, "phyclk");
-	if (!IS_ERR(rphy->clk)) {
-		clk_prepare_enable(rphy->clk);
-	} else {
-		dev_info(&pdev->dev, "no phyclk specified\n");
-		rphy->clk = NULL;
-	}
+		if (wakeup_enable && rport->ls_irq > 0)
+			enable_irq_wake(rport->ls_irq);
 
-	ret = rockchip_usb2phy_clk480m_register(rphy);
-	if (ret) {
-		dev_err(dev, "failed to register 480m output clock\n");
-		goto disable_clks;
+		/* enter low power state */
+		rockchip_usb2phy_low_power_enable(rphy, rport, true);
 	}
 
-	index = 0;
-	for_each_available_child_of_node(np, child_np) {
-		struct rockchip_usb2phy_port *rport = &rphy->ports[index];
-		struct phy *phy;
+	if (wakeup_enable && rphy->irq > 0)
+		enable_irq_wake(rphy->irq);
 
-		/* This driver aims to support both otg-port and host-port */
-		if (!of_node_name_eq(child_np, "host-port") &&
-		    !of_node_name_eq(child_np, "otg-port"))
-			goto next_child;
+	return ret;
+}
 
-		phy = devm_phy_create(dev, child_np, &rockchip_usb2phy_ops);
-		if (IS_ERR(phy)) {
-			dev_err_probe(dev, PTR_ERR(phy), "failed to create phy\n");
-			ret = PTR_ERR(phy);
-			goto put_child;
-		}
+static int rockchip_usb2phy_pm_resume(struct device *dev)
+{
+	struct rockchip_usb2phy *rphy = dev_get_drvdata(dev);
+	const struct rockchip_usb2phy_cfg *phy_cfg = rphy->phy_cfg;
+	struct rockchip_usb2phy_port *rport;
+	unsigned int index;
+	bool iddig;
+	int ret = 0;
+	bool wakeup_enable = false;
 
-		rport->phy = phy;
-		phy_set_drvdata(rport->phy, rport);
+	if (device_may_wakeup(rphy->dev))
+		wakeup_enable = true;
 
-		/* initialize otg/host port separately */
-		if (of_node_name_eq(child_np, "host-port")) {
-			ret = rockchip_usb2phy_host_port_init(rphy, rport,
-							      child_np);
-			if (ret)
-				goto put_child;
-		} else {
-			ret = rockchip_usb2phy_otg_port_init(rphy, rport,
-							     child_np);
-			if (ret)
-				goto put_child;
-		}
+	/*
+	 * PHY lost power in suspend, it needs to reset
+	 * PHY to recovery clock to usb controller.
+	 */
+	if (!wakeup_enable)
+		rockchip_usb2phy_reset(rphy);
 
-next_child:
-		/* to prevent out of boundary */
-		if (++index >= rphy->phy_cfg->num_ports) {
-			of_node_put(child_np);
-			break;
-		}
+	if (phy_cfg->phy_tuning)
+		ret = phy_cfg->phy_tuning(rphy);
+
+	if (phy_cfg->ls_filter_con.disable) {
+		ret = regmap_write(rphy->grf, phy_cfg->ls_filter_con.offset,
+				   phy_cfg->ls_filter_con.disable);
+		if (ret)
+			dev_err(rphy->dev, "failed to set ls filter %d\n", ret);
 	}
 
-	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	for (index = 0; index < phy_cfg->num_ports; index++) {
+		rport = &rphy->ports[index];
+		if (!rport->phy)
+			continue;
 
-	if (rphy->irq > 0) {
-		ret = devm_request_threaded_irq(rphy->dev, rphy->irq, NULL,
-						rockchip_usb2phy_irq,
-						IRQF_ONESHOT,
-						"rockchip_usb2phy",
-						rphy);
-		if (ret) {
-			dev_err(rphy->dev,
-				"failed to request usb2phy irq handle\n");
-			goto put_child;
+		if (rport->port_id == USB2PHY_PORT_OTG &&
+		    (rport->id_irq > 0 || rphy->irq > 0)) {
+			mutex_lock(&rport->mutex);
+			iddig = property_enabled(rphy->grf,
+						 &rport->port_cfg->utmi_iddig);
+			ret = rockchip_usb2phy_enable_id_irq(rphy, rport,
+							     true);
+			mutex_unlock(&rport->mutex);
+			if (ret) {
+				dev_err(rphy->dev,
+					"failed to enable id irq\n");
+				return ret;
+			}
+
+			if (iddig != rport->prev_iddig) {
+				dev_dbg(&rport->phy->dev,
+					"iddig changed during resume\n");
+				rport->prev_iddig = iddig;
+				extcon_set_state_sync(rphy->edev,
+						      EXTCON_USB_HOST,
+						      !iddig);
+				extcon_set_state_sync(rphy->edev,
+						      EXTCON_PROP_USB_VBUS,
+						      !iddig);
+				ret = rockchip_set_vbus_power(rport, !iddig);
+				if (ret)
+					return ret;
+			}
 		}
-	}
 
-	return PTR_ERR_OR_ZERO(provider);
+		if (rport->port_id == USB2PHY_PORT_OTG && wakeup_enable &&
+		    rport->bvalid_irq > 0)
+			disable_irq_wake(rport->bvalid_irq);
 
-put_child:
-	of_node_put(child_np);
-disable_clks:
-	if (rphy->clk) {
-		clk_disable_unprepare(rphy->clk);
-		clk_put(rphy->clk);
+		if (wakeup_enable && rport->ls_irq > 0)
+			disable_irq_wake(rport->ls_irq);
+
+		/* exit low power state */
+		rockchip_usb2phy_low_power_enable(rphy, rport, false);
 	}
+
+	if (wakeup_enable && rphy->irq > 0)
+		disable_irq_wake(rphy->irq);
+
 	return ret;
 }
 
+static const struct dev_pm_ops rockchip_usb2phy_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_usb2phy_pm_suspend,
+				rockchip_usb2phy_pm_resume)
+};
+
+#define ROCKCHIP_USB2PHY_DEV_PM	(&rockchip_usb2phy_dev_pm_ops)
+#else
+#define ROCKCHIP_USB2PHY_DEV_PM	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct rockchip_usb2phy_cfg rk1808_phy_cfgs[] = {
+	{
+		.reg = 0x100,
+		.num_ports	= 2,
+		.clkout_ctl	= { 0x108, 4, 4, 1, 0 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x0100, 8, 0, 0, 0x1d1 },
+				.bvalid_det_en	= { 0x0110, 2, 2, 0, 1 },
+				.bvalid_det_st	= { 0x0114, 2, 2, 0, 1 },
+				.bvalid_det_clr = { 0x0118, 2, 2, 0, 1 },
+				.bypass_dm_en	= { 0x0108, 2, 2, 0, 1},
+				.bypass_sel	= { 0x0108, 3, 3, 0, 1},
+				.iddig_output	= { 0x0100, 10, 10, 0, 1 },
+				.iddig_en	= { 0x0100, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0110, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x0114, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x0118, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x0110, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x0114, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x0118, 4, 4, 0, 1 },
+				.ls_det_en	= { 0x0110, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0114, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0118, 0, 0, 0, 1 },
+				.utmi_avalid	= { 0x0120, 10, 10, 0, 1 },
+				.utmi_bvalid	= { 0x0120, 9, 9, 0, 1 },
+				.utmi_iddig	= { 0x0120, 6, 6, 0, 1 },
+				.utmi_ls	= { 0x0120, 5, 4, 0, 1 },
+				.vbus_det_en	= { 0x001c, 15, 15, 1, 0 },
+			},
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x104, 8, 0, 0, 0x1d1 },
+				.ls_det_en	= { 0x110, 1, 1, 0, 1 },
+				.ls_det_st	= { 0x114, 1, 1, 0, 1 },
+				.ls_det_clr	= { 0x118, 1, 1, 0, 1 },
+				.utmi_ls	= { 0x120, 17, 16, 0, 1 },
+				.utmi_hstdet	= { 0x120, 19, 19, 0, 1 }
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x0100, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0x0120, 24, 24, 0, 1 },
+			.dcp_det	= { 0x0120, 23, 23, 0, 1 },
+			.dp_det		= { 0x0120, 25, 25, 0, 1 },
+			.idm_sink_en	= { 0x0108, 8, 8, 0, 1 },
+			.idp_sink_en	= { 0x0108, 7, 7, 0, 1 },
+			.idp_src_en	= { 0x0108, 9, 9, 0, 1 },
+			.rdm_pdwn_en	= { 0x0108, 10, 10, 0, 1 },
+			.vdm_src_en	= { 0x0108, 12, 12, 0, 1 },
+			.vdp_src_en	= { 0x0108, 11, 11, 0, 1 },
+		},
+	},
+	{ /* sentinel */ }
+};
+
+static const struct rockchip_usb2phy_cfg rk312x_phy_cfgs[] = {
+	{
+		.reg = 0x17c,
+		.num_ports	= 2,
+		.phy_tuning	= rk312x_usb2phy_tuning,
+		.clkout_ctl	= { 0x0190, 15, 15, 1, 0 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x017c, 8, 0, 0, 0x1d1 },
+				.bvalid_det_en	= { 0x017c, 14, 14, 0, 1 },
+				.bvalid_det_st	= { 0x017c, 15, 15, 0, 1 },
+				.bvalid_det_clr	= { 0x017c, 15, 15, 0, 1 },
+				.bypass_dm_en	= { 0x0190, 12, 12, 0, 1},
+				.bypass_sel	= { 0x0190, 13, 13, 0, 1},
+				.iddig_output	= { 0x017c, 10, 10, 0, 1 },
+				.iddig_en	= { 0x017c, 9, 9, 0, 1 },
+				.idfall_det_en  = { 0x01a0, 2, 2, 0, 1 },
+				.idfall_det_st  = { 0x01a0, 3, 3, 0, 1 },
+				.idfall_det_clr = { 0x01a0, 3, 3, 0, 1 },
+				.idrise_det_en  = { 0x01a0, 0, 0, 0, 1 },
+				.idrise_det_st  = { 0x01a0, 1, 1, 0, 1 },
+				.idrise_det_clr = { 0x01a0, 1, 1, 0, 1 },
+				.ls_det_en	= { 0x017c, 12, 12, 0, 1 },
+				.ls_det_st	= { 0x017c, 13, 13, 0, 1 },
+				.ls_det_clr	= { 0x017c, 13, 13, 0, 1 },
+				.utmi_bvalid	= { 0x014c, 5, 5, 0, 1 },
+				.utmi_iddig	= { 0x014c, 8, 8, 0, 1 },
+				.utmi_ls	= { 0x014c, 7, 6, 0, 1 },
+			},
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x0194, 8, 0, 0, 0x1d1 },
+				.ls_det_en	= { 0x0194, 14, 14, 0, 1 },
+				.ls_det_st	= { 0x0194, 15, 15, 0, 1 },
+				.ls_det_clr	= { 0x0194, 15, 15, 0, 1 }
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x017c, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0x02c0, 6, 6, 0, 1 },
+			.dcp_det	= { 0x02c0, 5, 5, 0, 1 },
+			.dp_det		= { 0x02c0, 7, 7, 0, 1 },
+			.idm_sink_en	= { 0x0184, 8, 8, 0, 1 },
+			.idp_sink_en	= { 0x0184, 7, 7, 0, 1 },
+			.idp_src_en	= { 0x0184, 9, 9, 0, 1 },
+			.rdm_pdwn_en	= { 0x0184, 10, 10, 0, 1 },
+			.vdm_src_en	= { 0x0184, 12, 12, 0, 1 },
+			.vdp_src_en	= { 0x0184, 11, 11, 0, 1 },
+		},
+	},
+	{ /* sentinel */ }
+};
+
 static const struct rockchip_usb2phy_cfg rk3228_phy_cfgs[] = {
 	{
 		.reg = 0x760,
 		.num_ports	= 2,
+		.phy_tuning	= rk3228_usb2phy_tuning,
 		.clkout_ctl	= { 0x0768, 4, 4, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
-				.phy_sus	= { 0x0760, 15, 0, 0, 0x1d1 },
+				.phy_sus	= { 0x0760, 8, 0, 0, 0x1d1 },
 				.bvalid_det_en	= { 0x0680, 3, 3, 0, 1 },
 				.bvalid_det_st	= { 0x0690, 3, 3, 0, 1 },
 				.bvalid_det_clr	= { 0x06a0, 3, 3, 0, 1 },
-				.id_det_en	= { 0x0680, 6, 5, 0, 3 },
-				.id_det_st	= { 0x0690, 6, 5, 0, 3 },
-				.id_det_clr	= { 0x06a0, 6, 5, 0, 3 },
+				.iddig_output   = { 0x0760, 10, 10, 0, 1 },
+				.iddig_en       = { 0x0760, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0680, 6, 6, 0, 1 },
+				.idfall_det_st	= { 0x0690, 6, 6, 0, 1 },
+				.idfall_det_clr	= { 0x06a0, 6, 6, 0, 1 },
+				.idrise_det_en	= { 0x0680, 5, 5, 0, 1 },
+				.idrise_det_st	= { 0x0690, 5, 5, 0, 1 },
+				.idrise_det_clr	= { 0x06a0, 5, 5, 0, 1 },
 				.ls_det_en	= { 0x0680, 2, 2, 0, 1 },
 				.ls_det_st	= { 0x0690, 2, 2, 0, 1 },
 				.ls_det_clr	= { 0x06a0, 2, 2, 0, 1 },
 				.utmi_bvalid	= { 0x0480, 4, 4, 0, 1 },
-				.utmi_id	= { 0x0480, 1, 1, 0, 1 },
+				.utmi_iddig	= { 0x0480, 1, 1, 0, 1 },
 				.utmi_ls	= { 0x0480, 3, 2, 0, 1 },
+				.vbus_det_en	= { 0x0788, 15, 15, 1, 0 },
 			},
 			[USB2PHY_PORT_HOST] = {
-				.phy_sus	= { 0x0764, 15, 0, 0, 0x1d1 },
+				.phy_sus	= { 0x0764, 8, 0, 0, 0x1d1 },
 				.ls_det_en	= { 0x0680, 4, 4, 0, 1 },
 				.ls_det_st	= { 0x0690, 4, 4, 0, 1 },
 				.ls_det_clr	= { 0x06a0, 4, 4, 0, 1 }
 			}
 		},
 		.chg_det = {
-			.opmode		= { 0x0760, 3, 0, 5, 1 },
+			.chg_mode	= { 0x0760, 8, 0, 0, 0x1d7 },
 			.cp_det		= { 0x0884, 4, 4, 0, 1 },
 			.dcp_det	= { 0x0884, 3, 3, 0, 1 },
 			.dp_det		= { 0x0884, 5, 5, 0, 1 },
@@ -1398,16 +3174,16 @@ static const struct rockchip_usb2phy_cfg rk3228_phy_cfgs[] = {
 		.clkout_ctl	= { 0x0808, 4, 4, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
-				.phy_sus	= { 0x800, 15, 0, 0, 0x1d1 },
-				.ls_det_en	= { 0x0684, 0, 0, 0, 1 },
-				.ls_det_st	= { 0x0694, 0, 0, 0, 1 },
-				.ls_det_clr	= { 0x06a4, 0, 0, 0, 1 }
-			},
-			[USB2PHY_PORT_HOST] = {
-				.phy_sus	= { 0x804, 15, 0, 0, 0x1d1 },
+				.phy_sus	= { 0x804, 8, 0, 0, 0x1d1 },
 				.ls_det_en	= { 0x0684, 1, 1, 0, 1 },
 				.ls_det_st	= { 0x0694, 1, 1, 0, 1 },
 				.ls_det_clr	= { 0x06a4, 1, 1, 0, 1 }
+			},
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x800, 8, 0, 0, 0x1d1 },
+				.ls_det_en	= { 0x0684, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0694, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x06a4, 0, 0, 0, 1 }
 			}
 		},
 	},
@@ -1418,35 +3194,42 @@ static const struct rockchip_usb2phy_cfg rk3308_phy_cfgs[] = {
 	{
 		.reg = 0x100,
 		.num_ports	= 2,
-		.clkout_ctl	= { 0x108, 4, 4, 1, 0 },
+		.phy_tuning	= rk3308_usb2phy_tuning,
+		.clkout_ctl	= { 0x0108, 4, 4, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
 				.phy_sus	= { 0x0100, 8, 0, 0, 0x1d1 },
 				.bvalid_det_en	= { 0x3020, 3, 2, 0, 3 },
 				.bvalid_det_st	= { 0x3024, 3, 2, 0, 3 },
 				.bvalid_det_clr = { 0x3028, 3, 2, 0, 3 },
-				.id_det_en	= { 0x3020, 5, 4, 0, 3 },
-				.id_det_st	= { 0x3024, 5, 4, 0, 3 },
-				.id_det_clr	= { 0x3028, 5, 4, 0, 3 },
+				.iddig_output	= { 0x0100, 10, 10, 0, 1 },
+				.iddig_en	= { 0x0100, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x3020, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x3024, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x3028, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x3020, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x3024, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x3028, 4, 4, 0, 1 },
 				.ls_det_en	= { 0x3020, 0, 0, 0, 1 },
 				.ls_det_st	= { 0x3024, 0, 0, 0, 1 },
 				.ls_det_clr	= { 0x3028, 0, 0, 0, 1 },
 				.utmi_avalid	= { 0x0120, 10, 10, 0, 1 },
 				.utmi_bvalid	= { 0x0120, 9, 9, 0, 1 },
-				.utmi_id	= { 0x0120, 6, 6, 0, 1 },
+				.utmi_iddig	= { 0x0120, 6, 6, 0, 1 },
 				.utmi_ls	= { 0x0120, 5, 4, 0, 1 },
+				.vbus_det_en	= { 0x001c, 15, 15, 1, 0 },
 			},
 			[USB2PHY_PORT_HOST] = {
 				.phy_sus	= { 0x0104, 8, 0, 0, 0x1d1 },
 				.ls_det_en	= { 0x3020, 1, 1, 0, 1 },
 				.ls_det_st	= { 0x3024, 1, 1, 0, 1 },
 				.ls_det_clr	= { 0x3028, 1, 1, 0, 1 },
-				.utmi_ls	= { 0x0120, 17, 16, 0, 1 },
-				.utmi_hstdet	= { 0x0120, 19, 19, 0, 1 }
+				.utmi_ls	= { 0x120, 17, 16, 0, 1 },
+				.utmi_hstdet	= { 0x120, 19, 19, 0, 1 }
 			}
 		},
 		.chg_det = {
-			.opmode		= { 0x0100, 3, 0, 5, 1 },
+			.chg_mode	= { 0x0100, 8, 0, 0, 0x1d7 },
 			.cp_det		= { 0x0120, 24, 24, 0, 1 },
 			.dcp_det	= { 0x0120, 23, 23, 0, 1 },
 			.dp_det		= { 0x0120, 25, 25, 0, 1 },
@@ -1465,26 +3248,36 @@ static const struct rockchip_usb2phy_cfg rk3328_phy_cfgs[] = {
 	{
 		.reg = 0x100,
 		.num_ports	= 2,
+		.phy_tuning = rk3328_usb2phy_tuning,
 		.clkout_ctl	= { 0x108, 4, 4, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
-				.phy_sus	= { 0x0100, 15, 0, 0, 0x1d1 },
+				.phy_sus	= { 0x0100, 8, 0, 0, 0x1d1 },
 				.bvalid_det_en	= { 0x0110, 3, 2, 0, 3 },
 				.bvalid_det_st	= { 0x0114, 3, 2, 0, 3 },
 				.bvalid_det_clr = { 0x0118, 3, 2, 0, 3 },
-				.id_det_en	= { 0x0110, 5, 4, 0, 3 },
-				.id_det_st	= { 0x0114, 5, 4, 0, 3 },
-				.id_det_clr	= { 0x0118, 5, 4, 0, 3 },
+				.bypass_bc      = { 0x0008, 14, 14, 0, 1 },
+				.bypass_otg     = { 0x0018, 15, 15, 1, 0 },
+				.iddig_output   = { 0x0100, 10, 10, 0, 1 },
+				.iddig_en       = { 0x0100, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0110, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x0114, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x0118, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x0110, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x0114, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x0118, 4, 4, 0, 1 },
 				.ls_det_en	= { 0x0110, 0, 0, 0, 1 },
 				.ls_det_st	= { 0x0114, 0, 0, 0, 1 },
 				.ls_det_clr	= { 0x0118, 0, 0, 0, 1 },
 				.utmi_avalid	= { 0x0120, 10, 10, 0, 1 },
 				.utmi_bvalid	= { 0x0120, 9, 9, 0, 1 },
-				.utmi_id	= { 0x0120, 6, 6, 0, 1 },
+				.utmi_iddig	= { 0x0120, 6, 6, 0, 1 },
 				.utmi_ls	= { 0x0120, 5, 4, 0, 1 },
+				.vbus_det_en	= { 0x001c, 15, 15, 1, 0 },
 			},
 			[USB2PHY_PORT_HOST] = {
-				.phy_sus	= { 0x104, 15, 0, 0, 0x1d1 },
+				.phy_sus	= { 0x104, 8, 0, 0, 0x1d1 },
+				.bypass_host	= { 0x048, 15, 15, 1, 0 },
 				.ls_det_en	= { 0x110, 1, 1, 0, 1 },
 				.ls_det_st	= { 0x114, 1, 1, 0, 1 },
 				.ls_det_clr	= { 0x118, 1, 1, 0, 1 },
@@ -1493,7 +3286,7 @@ static const struct rockchip_usb2phy_cfg rk3328_phy_cfgs[] = {
 			}
 		},
 		.chg_det = {
-			.opmode		= { 0x0100, 3, 0, 5, 1 },
+			.chg_mode	= { 0x0100, 8, 0, 0, 0x1d7 },
 			.cp_det		= { 0x0120, 24, 24, 0, 1 },
 			.dcp_det	= { 0x0120, 23, 23, 0, 1 },
 			.dp_det		= { 0x0120, 25, 25, 0, 1 },
@@ -1512,10 +3305,11 @@ static const struct rockchip_usb2phy_cfg rk3366_phy_cfgs[] = {
 	{
 		.reg = 0x700,
 		.num_ports	= 2,
+		.phy_tuning	= rk3366_usb2phy_tuning,
 		.clkout_ctl	= { 0x0724, 15, 15, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_HOST] = {
-				.phy_sus	= { 0x0728, 15, 0, 0, 0x1d1 },
+				.phy_sus	= { 0x0728, 8, 0, 0, 0x1d1 },
 				.ls_det_en	= { 0x0680, 4, 4, 0, 1 },
 				.ls_det_st	= { 0x0690, 4, 4, 0, 1 },
 				.ls_det_clr	= { 0x06a0, 4, 4, 0, 1 },
@@ -1527,23 +3321,86 @@ static const struct rockchip_usb2phy_cfg rk3366_phy_cfgs[] = {
 	{ /* sentinel */ }
 };
 
+static const struct rockchip_usb2phy_cfg rk3368_phy_cfgs[] = {
+	{
+		.reg = 0x700,
+		.num_ports	= 2,
+		.clkout_ctl	= { 0x0724, 15, 15, 1, 0 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x0700, 8, 0, 0, 0x1d1 },
+				.bvalid_det_en	= { 0x0680, 3, 3, 0, 1 },
+				.bvalid_det_st	= { 0x0690, 3, 3, 0, 1 },
+				.bvalid_det_clr = { 0x06a0, 3, 3, 0, 1 },
+				.iddig_output	= { 0x0700, 10, 10, 0, 1 },
+				.iddig_en	= { 0x0700, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0680, 6, 6, 0, 1 },
+				.idfall_det_st	= { 0x0690, 6, 6, 0, 1 },
+				.idfall_det_clr	= { 0x06a0, 6, 6, 0, 1 },
+				.idrise_det_en	= { 0x0680, 5, 5, 0, 1 },
+				.idrise_det_st	= { 0x0690, 5, 5, 0, 1 },
+				.idrise_det_clr	= { 0x06a0, 5, 5, 0, 1 },
+				.ls_det_en	= { 0x0680, 2, 2, 0, 1 },
+				.ls_det_st	= { 0x0690, 2, 2, 0, 1 },
+				.ls_det_clr	= { 0x06a0, 2, 2, 0, 1 },
+				.utmi_bvalid	= { 0x04bc, 23, 23, 0, 1 },
+				.utmi_iddig     = { 0x04bc, 26, 26, 0, 1 },
+				.utmi_ls	= { 0x04bc, 25, 24, 0, 1 },
+				.vbus_det_en    = { 0x079c, 15, 15, 1, 0 },
+			},
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x0728, 15, 0, 0, 0x1d1 },
+				.ls_det_en	= { 0x0680, 4, 4, 0, 1 },
+				.ls_det_st	= { 0x0690, 4, 4, 0, 1 },
+				.ls_det_clr	= { 0x06a0, 4, 4, 0, 1 }
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x0700, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0x04b8, 30, 30, 0, 1 },
+			.dcp_det	= { 0x04b8, 29, 29, 0, 1 },
+			.dp_det		= { 0x04b8, 31, 31, 0, 1 },
+			.idm_sink_en	= { 0x0718, 8, 8, 0, 1 },
+			.idp_sink_en	= { 0x0718, 7, 7, 0, 1 },
+			.idp_src_en	= { 0x0718, 9, 9, 0, 1 },
+			.rdm_pdwn_en	= { 0x0718, 10, 10, 0, 1 },
+			.vdm_src_en	= { 0x0718, 12, 12, 0, 1 },
+			.vdp_src_en	= { 0x0718, 11, 11, 0, 1 },
+		},
+	},
+	{ /* sentinel */ }
+};
+
 static const struct rockchip_usb2phy_cfg rk3399_phy_cfgs[] = {
 	{
 		.reg		= 0xe450,
 		.num_ports	= 2,
+		.phy_tuning	= rk3399_usb2phy_tuning,
 		.clkout_ctl	= { 0xe450, 4, 4, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
-				.phy_sus	= { 0xe454, 1, 0, 2, 1 },
+				.phy_sus = { 0xe454, 8, 0, 0x052, 0x1d1 },
 				.bvalid_det_en	= { 0xe3c0, 3, 3, 0, 1 },
 				.bvalid_det_st	= { 0xe3e0, 3, 3, 0, 1 },
 				.bvalid_det_clr	= { 0xe3d0, 3, 3, 0, 1 },
-				.id_det_en	= { 0xe3c0, 5, 4, 0, 3 },
-				.id_det_st	= { 0xe3e0, 5, 4, 0, 3 },
-				.id_det_clr	= { 0xe3d0, 5, 4, 0, 3 },
+				.bypass_dm_en   = { 0xe450, 2, 2, 0, 1 },
+				.bypass_sel     = { 0xe450, 3, 3, 0, 1 },
+				.iddig_output	= { 0xe454, 10, 10, 0, 1 },
+				.iddig_en	= { 0xe454, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0xe3c0, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0xe3e0, 5, 5, 0, 1 },
+				.idfall_det_clr	= { 0xe3d0, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0xe3c0, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0xe3e0, 4, 4, 0, 1 },
+				.idrise_det_clr	= { 0xe3d0, 4, 4, 0, 1 },
+				.ls_det_en	= { 0xe3c0, 2, 2, 0, 1 },
+				.ls_det_st	= { 0xe3e0, 2, 2, 0, 1 },
+				.ls_det_clr	= { 0xe3d0, 2, 2, 0, 1 },
 				.utmi_avalid	= { 0xe2ac, 7, 7, 0, 1 },
 				.utmi_bvalid	= { 0xe2ac, 12, 12, 0, 1 },
-				.utmi_id	= { 0xe2ac, 8, 8, 0, 1 },
+				.utmi_iddig     = { 0xe2ac, 8, 8, 0, 1 },
+				.utmi_ls	= { 0xe2ac, 14, 13, 0, 1 },
+				.vbus_det_en    = { 0x449c, 15, 15, 1, 0 },
 			},
 			[USB2PHY_PORT_HOST] = {
 				.phy_sus	= { 0xe458, 1, 0, 0x2, 0x1 },
@@ -1555,7 +3412,7 @@ static const struct rockchip_usb2phy_cfg rk3399_phy_cfgs[] = {
 			}
 		},
 		.chg_det = {
-			.opmode		= { 0xe454, 3, 0, 5, 1 },
+			.chg_mode	= { 0xe454, 8, 0, 0, 0x1d7 },
 			.cp_det		= { 0xe2ac, 2, 2, 0, 1 },
 			.dcp_det	= { 0xe2ac, 1, 1, 0, 1 },
 			.dp_det		= { 0xe2ac, 0, 0, 0, 1 },
@@ -1570,19 +3427,30 @@ static const struct rockchip_usb2phy_cfg rk3399_phy_cfgs[] = {
 	{
 		.reg		= 0xe460,
 		.num_ports	= 2,
+		.phy_tuning	= rk3399_usb2phy_tuning,
 		.clkout_ctl	= { 0xe460, 4, 4, 1, 0 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
-				.phy_sus        = { 0xe464, 1, 0, 2, 1 },
+				.phy_sus = { 0xe464, 8, 0, 0x052, 0x1d1 },
 				.bvalid_det_en  = { 0xe3c0, 8, 8, 0, 1 },
 				.bvalid_det_st  = { 0xe3e0, 8, 8, 0, 1 },
 				.bvalid_det_clr = { 0xe3d0, 8, 8, 0, 1 },
-				.id_det_en	= { 0xe3c0, 10, 9, 0, 3 },
-				.id_det_st	= { 0xe3e0, 10, 9, 0, 3 },
-				.id_det_clr	= { 0xe3d0, 10, 9, 0, 3 },
+				.iddig_output	= { 0xe464, 10, 10, 0, 1 },
+				.iddig_en	= { 0xe464, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0xe3c0, 10, 10, 0, 1 },
+				.idfall_det_st	= { 0xe3e0, 10, 10, 0, 1 },
+				.idfall_det_clr	= { 0xe3d0, 10, 10, 0, 1 },
+				.idrise_det_en	= { 0xe3c0, 9, 9, 0, 1 },
+				.idrise_det_st	= { 0xe3e0, 9, 9, 0, 1 },
+				.idrise_det_clr	= { 0xe3d0, 9, 9, 0, 1 },
+				.ls_det_en	= { 0xe3c0, 7, 7, 0, 1 },
+				.ls_det_st	= { 0xe3e0, 7, 7, 0, 1 },
+				.ls_det_clr	= { 0xe3d0, 7, 7, 0, 1 },
 				.utmi_avalid	= { 0xe2ac, 10, 10, 0, 1 },
 				.utmi_bvalid    = { 0xe2ac, 16, 16, 0, 1 },
-				.utmi_id	= { 0xe2ac, 11, 11, 0, 1 },
+				.utmi_iddig     = { 0xe2ac, 11, 11, 0, 1 },
+				.utmi_ls	= { 0xe2ac, 18, 17, 0, 1 },
+				.vbus_det_en    = { 0x451c, 15, 15, 1, 0 },
 			},
 			[USB2PHY_PORT_HOST] = {
 				.phy_sus	= { 0xe468, 1, 0, 0x2, 0x1 },
@@ -1593,6 +3461,18 @@ static const struct rockchip_usb2phy_cfg rk3399_phy_cfgs[] = {
 				.utmi_hstdet	= { 0xe2ac, 27, 27, 0, 1 }
 			}
 		},
+		.chg_det = {
+			.chg_mode	= { 0xe464, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0xe2ac, 5, 5, 0, 1 },
+			.dcp_det	= { 0xe2ac, 4, 4, 0, 1 },
+			.dp_det		= { 0xe2ac, 3, 3, 0, 1 },
+			.idm_sink_en	= { 0xe460, 8, 8, 0, 1 },
+			.idp_sink_en	= { 0xe460, 7, 7, 0, 1 },
+			.idp_src_en	= { 0xe460, 9, 9, 0, 1 },
+			.rdm_pdwn_en	= { 0xe460, 10, 10, 0, 1 },
+			.vdm_src_en	= { 0xe460, 12, 12, 0, 1 },
+			.vdp_src_en	= { 0xe460, 11, 11, 0, 1 },
+		},
 	},
 	{ /* sentinel */ }
 };
@@ -1601,19 +3481,34 @@ static const struct rockchip_usb2phy_cfg rk3568_phy_cfgs[] = {
 	{
 		.reg = 0xfe8a0000,
 		.num_ports	= 2,
+		.phy_tuning	= rk3568_usb2phy_tuning,
+		.vbus_detect	= rk3568_vbus_detect_control,
 		.clkout_ctl	= { 0x0008, 4, 4, 1, 0 },
+		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
 				.phy_sus	= { 0x0000, 8, 0, 0, 0x1d1 },
 				.bvalid_det_en	= { 0x0080, 3, 2, 0, 3 },
 				.bvalid_det_st	= { 0x0084, 3, 2, 0, 3 },
 				.bvalid_det_clr = { 0x0088, 3, 2, 0, 3 },
-				.id_det_en	= { 0x0080, 5, 4, 0, 3 },
-				.id_det_st	= { 0x0084, 5, 4, 0, 3 },
-				.id_det_clr	= { 0x0088, 5, 4, 0, 3 },
+				.bvalid_grf_sel	= { 0x0008, 15, 14, 0, 3 },
+				.bypass_dm_en	= { 0x0008, 2, 2, 0, 1},
+				.bypass_sel	= { 0x0008, 3, 3, 0, 1},
+				.iddig_output	= { 0x0000, 10, 10, 0, 1 },
+				.iddig_en	= { 0x0000, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0080, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x0084, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x0088, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x0080, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x0084, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x0088, 4, 4, 0, 1 },
+				.ls_det_en	= { 0x0080, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0084, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0088, 0, 0, 0, 1 },
 				.utmi_avalid	= { 0x00c0, 10, 10, 0, 1 },
 				.utmi_bvalid	= { 0x00c0, 9, 9, 0, 1 },
-				.utmi_id	= { 0x00c0, 6, 6, 0, 1 },
+				.utmi_iddig	= { 0x00c0, 6, 6, 0, 1 },
+				.utmi_ls	= { 0x00c0, 5, 4, 0, 1 },
 			},
 			[USB2PHY_PORT_HOST] = {
 				/* Select suspend control from controller */
@@ -1626,7 +3521,7 @@ static const struct rockchip_usb2phy_cfg rk3568_phy_cfgs[] = {
 			}
 		},
 		.chg_det = {
-			.opmode		= { 0x0000, 3, 0, 5, 1 },
+			.chg_mode	= { 0x0000, 8, 0, 0, 0x1d7 },
 			.cp_det		= { 0x00c0, 24, 24, 0, 1 },
 			.dcp_det	= { 0x00c0, 23, 23, 0, 1 },
 			.dp_det		= { 0x00c0, 25, 25, 0, 1 },
@@ -1641,7 +3536,9 @@ static const struct rockchip_usb2phy_cfg rk3568_phy_cfgs[] = {
 	{
 		.reg = 0xfe8b0000,
 		.num_ports	= 2,
+		.phy_tuning	= rk3568_usb2phy_tuning,
 		.clkout_ctl	= { 0x0008, 4, 4, 1, 0 },
+		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
 		.port_cfgs	= {
 			[USB2PHY_PORT_OTG] = {
 				.phy_sus	= { 0x0000, 8, 0, 0x1d2, 0x1d1 },
@@ -1664,6 +3561,208 @@ static const struct rockchip_usb2phy_cfg rk3568_phy_cfgs[] = {
 	{ /* sentinel */ }
 };
 
+static const struct rockchip_usb2phy_cfg rk3588_phy_cfgs[] = {
+	{
+		.reg = 0x0000,
+		.num_ports	= 1,
+		.phy_tuning	= rk3588_usb2phy_tuning,
+		.clkout_ctl	= { 0x0000, 0, 0, 1, 0 },
+		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x000c, 11, 11, 0, 1 },
+				.pipe_phystatus	= { 0x001c, 3, 2, 0, 2 },
+				.bvalid_det_en	= { 0x0080, 1, 1, 0, 1 },
+				.bvalid_det_st	= { 0x0084, 1, 1, 0, 1 },
+				.bvalid_det_clr = { 0x0088, 1, 1, 0, 1 },
+				.bvalid_grf_sel	= { 0x0010, 3, 3, 0, 1 },
+				.bvalid_grf_con	= { 0x0010, 3, 2, 2, 3 },
+				.bvalid_phy_con	= { 0x0008, 1, 0, 2, 3 },
+				.bypass_dm_en	= { 0x000c, 5, 5, 0, 1 },
+				.bypass_sel	= { 0x000c, 6, 6, 0, 1 },
+				.iddig_output	= { 0x0010, 0, 0, 0, 1 },
+				.iddig_en	= { 0x0010, 1, 1, 0, 1 },
+				.idfall_det_en	= { 0x0080, 4, 4, 0, 1 },
+				.idfall_det_st	= { 0x0084, 4, 4, 0, 1 },
+				.idfall_det_clr = { 0x0088, 4, 4, 0, 1 },
+				.idrise_det_en	= { 0x0080, 3, 3, 0, 1 },
+				.idrise_det_st	= { 0x0084, 3, 3, 0, 1 },
+				.idrise_det_clr = { 0x0088, 3, 3, 0, 1 },
+				.ls_det_en	= { 0x0080, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0084, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0088, 0, 0, 0, 1 },
+				.disfall_en	= { 0x0080, 6, 6, 0, 1 },
+				.disfall_st	= { 0x0084, 6, 6, 0, 1 },
+				.disfall_clr	= { 0x0088, 6, 6, 0, 1 },
+				.disrise_en	= { 0x0080, 5, 5, 0, 1 },
+				.disrise_st	= { 0x0084, 5, 5, 0, 1 },
+				.disrise_clr	= { 0x0088, 5, 5, 0, 1 },
+				.utmi_avalid	= { 0x00c0, 7, 7, 0, 1 },
+				.utmi_bvalid	= { 0x00c0, 6, 6, 0, 1 },
+				.utmi_iddig	= { 0x00c0, 5, 5, 0, 1 },
+				.utmi_ls	= { 0x00c0, 10, 9, 0, 1 },
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x0008, 2, 2, 0, 1 },
+			.cp_det		= { 0x00c0, 0, 0, 0, 1 },
+			.dcp_det	= { 0x00c0, 0, 0, 0, 1 },
+			.dp_det		= { 0x00c0, 1, 1, 1, 0 },
+			.idm_sink_en	= { 0x0008, 5, 5, 1, 0 },
+			.idp_sink_en	= { 0x0008, 5, 5, 0, 1 },
+			.idp_src_en	= { 0x0008, 14, 14, 0, 1 },
+			.rdm_pdwn_en	= { 0x0008, 14, 14, 0, 1 },
+			.vdm_src_en	= { 0x0008, 7, 6, 0, 3 },
+			.vdp_src_en	= { 0x0008, 7, 6, 0, 3 },
+		},
+	},
+	{
+		.reg = 0x4000,
+		.num_ports	= 1,
+		.phy_tuning	= rk3588_usb2phy_tuning,
+		.clkout_ctl	= { 0x0000, 0, 0, 1, 0 },
+		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x000c, 11, 11, 0, 1 },
+				.pipe_phystatus	= { 0x0034, 3, 2, 0, 2 },
+				.bvalid_det_en	= { 0x0080, 1, 1, 0, 1 },
+				.bvalid_det_st	= { 0x0084, 1, 1, 0, 1 },
+				.bvalid_det_clr = { 0x0088, 1, 1, 0, 1 },
+				.bvalid_grf_sel	= { 0x0010, 3, 3, 0, 1 },
+				.bvalid_grf_con	= { 0x0010, 3, 2, 2, 3 },
+				.bvalid_phy_con = { 0x0008, 1, 0, 2, 3 },
+				.bypass_dm_en	= { 0x000c, 5, 5, 0, 1 },
+				.bypass_sel	= { 0x000c, 6, 6, 0, 1 },
+				.iddig_output	= { 0x0010, 0, 0, 0, 1 },
+				.iddig_en	= { 0x0010, 1, 1, 0, 1 },
+				.idfall_det_en	= { 0x0080, 4, 4, 0, 1 },
+				.idfall_det_st	= { 0x0084, 4, 4, 0, 1 },
+				.idfall_det_clr = { 0x0088, 4, 4, 0, 1 },
+				.idrise_det_en	= { 0x0080, 3, 3, 0, 1 },
+				.idrise_det_st	= { 0x0084, 3, 3, 0, 1 },
+				.idrise_det_clr = { 0x0088, 3, 3, 0, 1 },
+				.ls_det_en	= { 0x0080, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0084, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0088, 0, 0, 0, 1 },
+				.disfall_en	= { 0x0080, 6, 6, 0, 1 },
+				.disfall_st	= { 0x0084, 6, 6, 0, 1 },
+				.disfall_clr	= { 0x0088, 6, 6, 0, 1 },
+				.disrise_en	= { 0x0080, 5, 5, 0, 1 },
+				.disrise_st	= { 0x0084, 5, 5, 0, 1 },
+				.disrise_clr	= { 0x0088, 5, 5, 0, 1 },
+				.utmi_avalid	= { 0x00c0, 7, 7, 0, 1 },
+				.utmi_bvalid	= { 0x00c0, 6, 6, 0, 1 },
+				.utmi_iddig	= { 0x00c0, 5, 5, 0, 1 },
+				.utmi_ls	= { 0x00c0, 10, 9, 0, 1 },
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x0008, 2, 2, 0, 1 },
+			.cp_det		= { 0x00c0, 0, 0, 0, 1 },
+			.dcp_det	= { 0x00c0, 0, 0, 0, 1 },
+			.dp_det		= { 0x00c0, 1, 1, 1, 0 },
+			.idm_sink_en	= { 0x0008, 5, 5, 1, 0 },
+			.idp_sink_en	= { 0x0008, 5, 5, 0, 1 },
+			.idp_src_en	= { 0x0008, 14, 14, 0, 1 },
+			.rdm_pdwn_en	= { 0x0008, 14, 14, 0, 1 },
+			.vdm_src_en	= { 0x0008, 7, 6, 0, 3 },
+			.vdp_src_en	= { 0x0008, 7, 6, 0, 3 },
+		},
+	},
+	{
+		.reg = 0x8000,
+		.num_ports	= 1,
+		.phy_tuning	= rk3588_usb2phy_tuning,
+		.clkout_ctl	= { 0x0000, 0, 0, 0, 0 },
+		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x0008, 2, 2, 0, 1 },
+				.ls_det_en	= { 0x0080, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0084, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0088, 0, 0, 0, 1 },
+				.disfall_en	= { 0x0080, 6, 6, 0, 1 },
+				.disfall_st	= { 0x0084, 6, 6, 0, 1 },
+				.disfall_clr	= { 0x0088, 6, 6, 0, 1 },
+				.disrise_en	= { 0x0080, 5, 5, 0, 1 },
+				.disrise_st	= { 0x0084, 5, 5, 0, 1 },
+				.disrise_clr	= { 0x0088, 5, 5, 0, 1 },
+				.utmi_ls	= { 0x00c0, 10, 9, 0, 1 },
+			}
+		},
+	},
+	{
+		.reg = 0xc000,
+		.num_ports	= 1,
+		.phy_tuning	= rk3588_usb2phy_tuning,
+		.clkout_ctl	= { 0x0000, 0, 0, 0, 0 },
+		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x0008, 2, 2, 0, 1 },
+				.ls_det_en	= { 0x0080, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0084, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0088, 0, 0, 0, 1 },
+				.disfall_en	= { 0x0080, 6, 6, 0, 1 },
+				.disfall_st	= { 0x0084, 6, 6, 0, 1 },
+				.disfall_clr	= { 0x0088, 6, 6, 0, 1 },
+				.disrise_en	= { 0x0080, 5, 5, 0, 1 },
+				.disrise_st	= { 0x0084, 5, 5, 0, 1 },
+				.disrise_clr	= { 0x0088, 5, 5, 0, 1 },
+				.utmi_ls	= { 0x00c0, 10, 9, 0, 1 },
+			}
+		},
+	},
+	{ /* sentinel */ }
+};
+
+static const struct rockchip_usb2phy_cfg rv1106_phy_cfgs[] = {
+	{
+		.reg = 0xff3e0000,
+		.num_ports	= 1,
+		.phy_tuning	= rv1106_usb2phy_tuning,
+		.clkout_ctl	= { 0x0058, 4, 4, 1, 0 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x0050, 8, 0, 0, 0x1d1 },
+				.bvalid_det_en	= { 0x0100, 2, 2, 0, 1 },
+				.bvalid_det_st	= { 0x0104, 2, 2, 0, 1 },
+				.bvalid_det_clr = { 0x0108, 2, 2, 0, 1 },
+				.bvalid_grf_sel	= { 0x0058, 15, 14, 0, 3 },
+				.iddig_output	= { 0x0050, 10, 10, 0, 1 },
+				.iddig_en	= { 0x0050, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0100, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x0104, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x0108, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x0100, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x0104, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x0108, 4, 4, 0, 1 },
+				.ls_det_en	= { 0x0100, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0104, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0108, 0, 0, 0, 1 },
+				.utmi_avalid	= { 0x0060, 10, 10, 0, 1 },
+				.utmi_bvalid	= { 0x0060, 9, 9, 0, 1 },
+				.utmi_iddig	= { 0x0060, 6, 6, 0, 1 },
+				.utmi_ls	= { 0x0060, 5, 4, 0, 1 },
+			},
+		},
+		.chg_det = {
+			.chg_mode	= { 0x0050, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0x0060, 13, 13, 0, 1 },
+			.dcp_det	= { 0x0060, 12, 12, 0, 1 },
+			.dp_det		= { 0x0060, 14, 14, 0, 1 },
+			.idm_sink_en	= { 0x0058, 8, 8, 0, 1 },
+			.idp_sink_en	= { 0x0058, 7, 7, 0, 1 },
+			.idp_src_en	= { 0x0058, 9, 9, 0, 1 },
+			.rdm_pdwn_en	= { 0x0058, 10, 10, 0, 1 },
+			.vdm_src_en	= { 0x0058, 12, 12, 0, 1 },
+			.vdp_src_en	= { 0x0058, 11, 11, 0, 1 },
+		},
+	},
+	{ /* sentinel */ }
+};
+
 static const struct rockchip_usb2phy_cfg rv1108_phy_cfgs[] = {
 	{
 		.reg = 0x100,
@@ -1691,7 +3790,7 @@ static const struct rockchip_usb2phy_cfg rv1108_phy_cfgs[] = {
 			}
 		},
 		.chg_det = {
-			.opmode		= { 0x0100, 3, 0, 5, 1 },
+			.chg_mode	= { 0x0100, 8, 0, 0, 0x1d7 },
 			.cp_det		= { 0x0804, 1, 1, 0, 1 },
 			.dcp_det	= { 0x0804, 0, 0, 0, 1 },
 			.dp_det		= { 0x0804, 2, 2, 0, 1 },
@@ -1708,12 +3807,29 @@ static const struct rockchip_usb2phy_cfg rv1108_phy_cfgs[] = {
 
 static const struct of_device_id rockchip_usb2phy_dt_match[] = {
 	{ .compatible = "rockchip,px30-usb2phy", .data = &rk3328_phy_cfgs },
+
+	{ .compatible = "rockchip,rk1808-usb2phy", .data = &rk1808_phy_cfgs },
+
+	{ .compatible = "rockchip,rk3128-usb2phy", .data = &rk312x_phy_cfgs },
+
 	{ .compatible = "rockchip,rk3228-usb2phy", .data = &rk3228_phy_cfgs },
+
 	{ .compatible = "rockchip,rk3308-usb2phy", .data = &rk3308_phy_cfgs },
+
 	{ .compatible = "rockchip,rk3328-usb2phy", .data = &rk3328_phy_cfgs },
+
 	{ .compatible = "rockchip,rk3366-usb2phy", .data = &rk3366_phy_cfgs },
+
+	{ .compatible = "rockchip,rk3368-usb2phy", .data = &rk3368_phy_cfgs },
+
 	{ .compatible = "rockchip,rk3399-usb2phy", .data = &rk3399_phy_cfgs },
+
 	{ .compatible = "rockchip,rk3568-usb2phy", .data = &rk3568_phy_cfgs },
+
+	{ .compatible = "rockchip,rk3588-usb2phy", .data = &rk3588_phy_cfgs },
+
+	{ .compatible = "rockchip,rv1106-usb2phy", .data = &rv1106_phy_cfgs },
+
 	{ .compatible = "rockchip,rv1108-usb2phy", .data = &rv1108_phy_cfgs },
 	{}
 };
@@ -1723,6 +3839,7 @@ static struct platform_driver rockchip_usb2phy_driver = {
 	.probe		= rockchip_usb2phy_probe,
 	.driver		= {
 		.name	= "rockchip-usb2phy",
+		.pm	= ROCKCHIP_USB2PHY_DEV_PM,
 		.of_match_table = rockchip_usb2phy_dt_match,
 	},
 };
diff --git a/drivers/phy/rockchip/phy-rockchip-naneng-combphy.c b/drivers/phy/rockchip/phy-rockchip-naneng-combphy.c
index 7b213825fb5..7b8b001e4f9 100644
--- a/drivers/phy/rockchip/phy-rockchip-naneng-combphy.c
+++ b/drivers/phy/rockchip/phy-rockchip-naneng-combphy.c
@@ -63,6 +63,9 @@
 #define PHYREG18			0x44
 #define PHYREG18_PLL_LOOP		0x32
 
+#define PHYREG27			0x6C
+#define PHYREG27_RX_TRIM_RK3588		0x4C
+
 #define PHYREG32			0x7C
 #define PHYREG32_SSC_MASK		GENMASK(7, 4)
 #define PHYREG32_SSC_DIR_SHIFT		4
@@ -114,7 +117,10 @@ struct rockchip_combphy_grfcfg {
 	struct combphy_reg con2_for_sata;
 	struct combphy_reg con3_for_sata;
 	struct combphy_reg pipe_con0_for_sata;
+	struct combphy_reg pipe_con1_for_sata;
 	struct combphy_reg pipe_xpcs_phy_ready;
+	struct combphy_reg pipe_pcie1l0_sel;
+	struct combphy_reg pipe_pcie1l1_sel;
 };
 
 struct rockchip_combphy_cfg {
@@ -559,11 +565,189 @@ static const struct rockchip_combphy_cfg rk3568_combphy_cfgs = {
 	.combphy_cfg	= rk3568_combphy_cfg,
 };
 
+static int rk3588_combphy_cfg(struct rockchip_combphy_priv *priv)
+{
+	const struct rockchip_combphy_grfcfg *cfg = priv->cfg->grfcfg;
+	unsigned long rate;
+	u32 val;
+
+	switch (priv->type) {
+	case PHY_TYPE_PCIE:
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con0_for_pcie, true);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con1_for_pcie, true);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con2_for_pcie, true);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con3_for_pcie, true);
+		rockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_pcie1l0_sel, true);
+		rockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_pcie1l1_sel, true);
+		break;
+	case PHY_TYPE_USB3:
+		/* Set SSC downward spread spectrum */
+		rockchip_combphy_updatel(priv, PHYREG32_SSC_MASK,
+					 PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT,
+					 PHYREG32);
+
+		/* Enable adaptive CTLE for USB3.0 Rx. */
+		val = readl(priv->mmio + PHYREG15);
+		val |= PHYREG15_CTLE_EN;
+		writel(val, priv->mmio + PHYREG15);
+
+		/* Set PLL KVCO fine tuning signals. */
+		rockchip_combphy_updatel(priv, PHYREG33_PLL_KVCO_MASK,
+					 PHYREG33_PLL_KVCO_VALUE << PHYREG33_PLL_KVCO_SHIFT,
+					 PHYREG33);
+
+		/* Enable controlling random jitter. */
+		writel(PHYREG12_PLL_LPF_ADJ_VALUE, priv->mmio + PHYREG12);
+
+		/* Set PLL input clock divider 1/2. */
+		rockchip_combphy_updatel(priv, PHYREG6_PLL_DIV_MASK,
+					 PHYREG6_PLL_DIV_2 << PHYREG6_PLL_DIV_SHIFT,
+					 PHYREG6);
+
+		writel(PHYREG18_PLL_LOOP, priv->mmio + PHYREG18);
+		writel(PHYREG11_SU_TRIM_0_7, priv->mmio + PHYREG11);
+
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_txcomp_sel, false);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_txelec_sel, false);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->usb_mode_set, true);
+		break;
+	case PHY_TYPE_SATA:
+		/* Enable adaptive CTLE for SATA Rx. */
+		val = readl(priv->mmio + PHYREG15);
+		val |= PHYREG15_CTLE_EN;
+		writel(val, priv->mmio + PHYREG15);
+		/*
+		 * Set tx_rterm=50ohm and rx_rterm=44ohm for SATA.
+		 * 0: 60ohm, 8: 50ohm 15: 44ohm (by step abort 1ohm)
+		 */
+		val = PHYREG7_TX_RTERM_50OHM << PHYREG7_TX_RTERM_SHIFT;
+		val |= PHYREG7_RX_RTERM_44OHM << PHYREG7_RX_RTERM_SHIFT;
+		writel(val, priv->mmio + PHYREG7);
+
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con0_for_sata, true);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con1_for_sata, true);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con2_for_sata, true);
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->con3_for_sata, true);
+		rockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_con0_for_sata, true);
+		rockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_con1_for_sata, true);
+		break;
+	case PHY_TYPE_SGMII:
+	case PHY_TYPE_QSGMII:
+	default:
+		dev_err(priv->dev, "incompatible PHY type\n");
+		return -EINVAL;
+	}
+
+	rate = clk_get_rate(priv->refclk);
+
+	switch (rate) {
+	case REF_CLOCK_24MHz:
+		if (priv->type == PHY_TYPE_USB3 || priv->type == PHY_TYPE_SATA) {
+			/* Set ssc_cnt[9:0]=0101111101 & 31.5KHz. */
+			val = PHYREG15_SSC_CNT_VALUE << PHYREG15_SSC_CNT_SHIFT;
+			rockchip_combphy_updatel(priv, PHYREG15_SSC_CNT_MASK,
+						 val, PHYREG15);
+
+			writel(PHYREG16_SSC_CNT_VALUE, priv->mmio + PHYREG16);
+		}
+		break;
+
+	case REF_CLOCK_25MHz:
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_25m, true);
+		break;
+	case REF_CLOCK_100MHz:
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_100m, true);
+		if (priv->type == PHY_TYPE_PCIE) {
+			/* PLL KVCO fine tuning. */
+			val = 4 << PHYREG33_PLL_KVCO_SHIFT;
+			rockchip_combphy_updatel(priv, PHYREG33_PLL_KVCO_MASK,
+						 val, PHYREG33);
+
+			/* Enable controlling random jitter. */
+			writel(PHYREG12_PLL_LPF_ADJ_VALUE, priv->mmio + PHYREG12);
+
+			/* Set up rx_trim: PLL LPF C1 85pf R1 1.25kohm */
+			writel(PHYREG27_RX_TRIM_RK3588, priv->mmio + PHYREG27);
+
+			/* Set up su_trim:  */
+			writel(PHYREG11_SU_TRIM_0_7, priv->mmio + PHYREG11);
+		} else if (priv->type == PHY_TYPE_SATA) {
+			/* downward spread spectrum +500ppm */
+			val = PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT;
+			val |= PHYREG32_SSC_OFFSET_500PPM << PHYREG32_SSC_OFFSET_SHIFT;
+			rockchip_combphy_updatel(priv, PHYREG32_SSC_MASK, val, PHYREG32);
+		}
+		break;
+	default:
+		dev_err(priv->dev, "Unsupported rate: %lu\n", rate);
+		return -EINVAL;
+	}
+
+	if (priv->ext_refclk) {
+		rockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_ext, true);
+		if (priv->type == PHY_TYPE_PCIE && rate == REF_CLOCK_100MHz) {
+			val = PHYREG13_RESISTER_HIGH_Z << PHYREG13_RESISTER_SHIFT;
+			val |= PHYREG13_CKRCV_AMP0;
+			rockchip_combphy_updatel(priv, PHYREG13_RESISTER_MASK, val, PHYREG13);
+
+			val = readl(priv->mmio + PHYREG14);
+			val |= PHYREG14_CKRCV_AMP1;
+			writel(val, priv->mmio + PHYREG14);
+		}
+	}
+
+	if (priv->enable_ssc) {
+		val = readl(priv->mmio + PHYREG8);
+		val |= PHYREG8_SSC_EN;
+		writel(val, priv->mmio + PHYREG8);
+	}
+
+	return 0;
+}
+
+static const struct rockchip_combphy_grfcfg rk3588_combphy_grfcfgs = {
+	/* pipe-phy-grf */
+	.pcie_mode_set		= { 0x0000, 5, 0, 0x00, 0x11 },
+	.usb_mode_set		= { 0x0000, 5, 0, 0x00, 0x04 },
+	.pipe_rxterm_set	= { 0x0000, 12, 12, 0x00, 0x01 },
+	.pipe_txelec_set	= { 0x0004, 1, 1, 0x00, 0x01 },
+	.pipe_txcomp_set	= { 0x0004, 4, 4, 0x00, 0x01 },
+	.pipe_clk_25m		= { 0x0004, 14, 13, 0x00, 0x01 },
+	.pipe_clk_100m		= { 0x0004, 14, 13, 0x00, 0x02 },
+	.pipe_rxterm_sel	= { 0x0008, 8, 8, 0x00, 0x01 },
+	.pipe_txelec_sel	= { 0x0008, 12, 12, 0x00, 0x01 },
+	.pipe_txcomp_sel	= { 0x0008, 15, 15, 0x00, 0x01 },
+	.pipe_clk_ext		= { 0x000c, 9, 8, 0x02, 0x01 },
+	.pipe_phy_status	= { 0x0034, 6, 6, 0x01, 0x00 },
+	.con0_for_pcie		= { 0x0000, 15, 0, 0x00, 0x1000 },
+	.con1_for_pcie		= { 0x0004, 15, 0, 0x00, 0x0000 },
+	.con2_for_pcie		= { 0x0008, 15, 0, 0x00, 0x0101 },
+	.con3_for_pcie		= { 0x000c, 15, 0, 0x00, 0x0200 },
+	.con0_for_sata		= { 0x0000, 15, 0, 0x00, 0x0129 },
+	.con1_for_sata		= { 0x0004, 15, 0, 0x00, 0x0000 },
+	.con2_for_sata		= { 0x0008, 15, 0, 0x00, 0x80c1 },
+	.con3_for_sata		= { 0x000c, 15, 0, 0x00, 0x0407 },
+	/* pipe-grf */
+	.pipe_con0_for_sata	= { 0x0000, 11, 5, 0x00, 0x22 },
+	.pipe_con1_for_sata	= { 0x0000, 2, 0, 0x00, 0x2 },
+	.pipe_pcie1l0_sel	= { 0x0100, 0, 0, 0x01, 0x0 },
+	.pipe_pcie1l1_sel	= { 0x0100, 1, 1, 0x01, 0x0 },
+};
+
+static const struct rockchip_combphy_cfg rk3588_combphy_cfgs = {
+	.grfcfg		= &rk3588_combphy_grfcfgs,
+	.combphy_cfg	= rk3588_combphy_cfg,
+};
+
 static const struct of_device_id rockchip_combphy_of_match[] = {
 	{
 		.compatible = "rockchip,rk3568-naneng-combphy",
 		.data = &rk3568_combphy_cfgs,
 	},
+	{
+		.compatible = "rockchip,rk3588-naneng-combphy",
+		.data = &rk3588_combphy_cfgs,
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, rockchip_combphy_of_match);
diff --git a/drivers/phy/rockchip/phy-rockchip-snps-pcie3.c b/drivers/phy/rockchip/phy-rockchip-snps-pcie3.c
index 1d355b32ba5..c80a82f4749 100644
--- a/drivers/phy/rockchip/phy-rockchip-snps-pcie3.c
+++ b/drivers/phy/rockchip/phy-rockchip-snps-pcie3.c
@@ -38,7 +38,7 @@
 
 #define RK3588_BIFURCATION_LANE_0_1		BIT(0)
 #define RK3588_BIFURCATION_LANE_2_3		BIT(1)
-#define RK3588_LANE_AGGREGATION		BIT(2)
+#define RK3588_LANE_AGGREGATION			BIT(2)
 
 struct rockchip_p3phy_ops;
 
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 38e6c540155..83a63c6daec 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -414,6 +414,15 @@ config PINCTRL_RK805
 	help
 	  This selects the pinctrl driver for RK805.
 
+config PINCTRL_RK806
+	tristate "Pinctrl and GPIO driver for RK806 PMIC"
+	depends on MFD_RK806
+	select GPIOLIB
+	select PINMUX
+	select GENERIC_PINCONF
+	help
+	  This selects the pinctrl driver for RK806
+
 config PINCTRL_ROCKCHIP
 	tristate "Rockchip gpio and pinctrl driver"
 	depends on ARCH_ROCKCHIP || COMPILE_TEST
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index d5939840bb2..922b3172697 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_PINCTRL_PALMAS)	+= pinctrl-palmas.o
 obj-$(CONFIG_PINCTRL_PIC32)	+= pinctrl-pic32.o
 obj-$(CONFIG_PINCTRL_PISTACHIO)	+= pinctrl-pistachio.o
 obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
+obj-$(CONFIG_PINCTRL_RK806)	+= pinctrl-rk806.o
 obj-$(CONFIG_PINCTRL_ROCKCHIP)	+= pinctrl-rockchip.o
 obj-$(CONFIG_PINCTRL_SINGLE)	+= pinctrl-single.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
diff --git a/drivers/pinctrl/pinctrl-rk806.c b/drivers/pinctrl/pinctrl-rk806.c
new file mode 100644
index 00000000000..ba4626993bc
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-rk806.c
@@ -0,0 +1,577 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pinctrl driver for Rockchip RK806 PMIC
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ * Author: Xu Shengfei <xsf@rock-chips.com>
+ */
+
+#include <linux/gpio/driver.h>
+#include <linux/kernel.h>
+#include <linux/mfd/rk806.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include "pinctrl-utils.h"
+
+struct rk806_pin_function {
+	const char *name;
+	const char *const *groups;
+	unsigned int ngroups;
+	int mux_option;
+};
+
+struct rk806_pin_group {
+	const char *name;
+	const unsigned int pins[1];
+	unsigned int npins;
+};
+
+/*
+ * @reg: gpio setting register;
+ * @fun_mask: functions select mask value, when set is gpio;
+ * @dir_mask: input or output mask value, when set is output, otherwise input;
+ * @val_mask: gpio set value, when set is level high, otherwise low;
+ *
+ * Different PMIC has different pin features, belowing 3 mask members are not
+ * all necessary for every PMIC. For example, RK805 has 2 pins that can be used
+ * as output only GPIOs, so func_mask and dir_mask are not needed. RK816 has 1
+ * pin that can be used as TS/GPIO, so fun_mask, dir_mask and val_mask are all
+ * necessary.
+ */
+struct rk806_pin_config {
+	u8 fun_reg;
+	u8 fun_msk;
+	u8 reg;
+	u8 dir_msk;
+	u8 val_msk;
+};
+
+struct rk806_pctrl_info {
+	struct rk806 *rk806;
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	struct gpio_chip gpio_chip;
+	struct pinctrl_desc pinctrl_desc;
+	const struct rk806_pin_function *functions;
+	unsigned int num_functions;
+	const struct rk806_pin_group *groups;
+	int num_pin_groups;
+	const struct pinctrl_pin_desc *pins;
+	unsigned int num_pins;
+	const struct rk806_pin_config *pin_cfg;
+};
+
+#define RK806_PWRCTRL1_DR	BIT(0)
+#define RK806_PWRCTRL2_DR	BIT(1)
+#define RK806_PWRCTRL3_DR	BIT(2)
+#define RK806_PWRCTRL1_DATA	BIT(4)
+#define RK806_PWRCTRL2_DATA	BIT(5)
+#define RK806_PWRCTRL3_DATA	BIT(6)
+#define RK806_PWRCTRL1_FUN	0x07
+#define RK806_PWRCTRL2_FUN	0x70
+#define RK806_PWRCTRL3_FUN	0x07
+
+enum rk806_pinmux_option {
+	RK806_PINMUX_FUN0 = 0,
+	RK806_PINMUX_FUN1,
+	RK806_PINMUX_FUN2,
+	RK806_PINMUX_FUN3,
+	RK806_PINMUX_FUN4,
+	RK806_PINMUX_FUN5,
+};
+
+enum {
+	RK806_GPIO_DVS1,
+	RK806_GPIO_DVS2,
+	RK806_GPIO_DVS3
+};
+
+static const char *const rk806_gpio_groups[] = {
+	"gpio_pwrctrl1",
+	"gpio_pwrctrl2",
+	"gpio_pwrctrl3",
+};
+
+static const struct pinctrl_pin_desc rk806_pins_desc[] = {
+	PINCTRL_PIN(RK806_GPIO_DVS1, "gpio_pwrctrl1"), /* dvs1 pin */
+	PINCTRL_PIN(RK806_GPIO_DVS2, "gpio_pwrctrl2"), /* dvs2 pin */
+	PINCTRL_PIN(RK806_GPIO_DVS3, "gpio_pwrctrl3") /* dvs3 pin */
+};
+
+static const struct rk806_pin_function rk806_pin_functions[] = {
+	{
+		.name = "pin_fun0",
+		.groups = rk806_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk806_gpio_groups),
+		.mux_option = RK806_PINMUX_FUN0,
+	},
+	{
+		.name = "pin_fun1",
+		.groups = rk806_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk806_gpio_groups),
+		.mux_option = RK806_PINMUX_FUN1,
+	},
+	{
+		.name = "pin_fun2",
+		.groups = rk806_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk806_gpio_groups),
+		.mux_option = RK806_PINMUX_FUN2,
+	},
+	{
+		.name = "pin_fun3",
+		.groups = rk806_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk806_gpio_groups),
+		.mux_option = RK806_PINMUX_FUN3,
+	},
+	{
+		.name = "pin_fun4",
+		.groups = rk806_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk806_gpio_groups),
+		.mux_option = RK806_PINMUX_FUN4,
+	},
+	{
+		.name = "pin_fun5",
+		.groups = rk806_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk806_gpio_groups),
+		.mux_option = RK806_PINMUX_FUN5,
+	},
+
+};
+
+static const struct rk806_pin_group rk806_pin_groups[] = {
+	{
+		.name = "gpio_pwrctrl1",
+		.pins = { RK806_GPIO_DVS1 },
+		.npins = 1,
+	},
+	{
+		.name = "gpio_pwrctrl2",
+		.pins = { RK806_GPIO_DVS2 },
+		.npins = 1,
+	},
+	{
+		.name = "gpio_pwrctrl3",
+		.pins = { RK806_GPIO_DVS3 },
+		.npins = 1,
+	}
+};
+
+static struct rk806_pin_config rk806_gpio_cfgs[] = {
+	{
+		.fun_reg = RK806_SLEEP_CONFIG0,
+		.fun_msk = RK806_PWRCTRL1_FUN,
+		.reg = RK806_SLEEP_GPIO,
+		.val_msk = RK806_PWRCTRL1_DATA,
+		.dir_msk = RK806_PWRCTRL1_DR,
+	},
+	{
+		.fun_reg = RK806_SLEEP_CONFIG0,
+		.fun_msk = RK806_PWRCTRL2_FUN,
+		.reg = RK806_SLEEP_GPIO,
+		.val_msk = RK806_PWRCTRL2_DATA,
+		.dir_msk = RK806_PWRCTRL2_DR,
+	},
+	{
+		.fun_reg = RK806_SLEEP_CONFIG1,
+		.fun_msk = RK806_PWRCTRL3_FUN,
+		.reg = RK806_SLEEP_GPIO,
+		.val_msk = RK806_PWRCTRL3_DATA,
+		.dir_msk = RK806_PWRCTRL3_DR,
+	}
+};
+
+/* generic gpio chip */
+static int rk806_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct rk806_pctrl_info *pci = gpiochip_get_data(chip);
+	int ret, val;
+
+	if (!pci->pin_cfg[offset].val_msk) {
+		dev_dbg(pci->dev, "getting gpio%d value is not support\n",
+			offset);
+		return -1;
+	}
+
+	ret = regmap_read(pci->rk806->regmap, pci->pin_cfg[offset].reg, &val);
+	if (ret) {
+		dev_err(pci->dev, "get gpio%d value failed\n", offset);
+		return ret;
+	}
+
+	return !!(val & pci->pin_cfg[offset].val_msk);
+}
+
+static void rk806_gpio_set(struct gpio_chip *chip,
+			   unsigned int offset,
+			   int value)
+{
+	struct rk806_pctrl_info *pci = gpiochip_get_data(chip);
+	int ret;
+
+	if (!pci->pin_cfg[offset].val_msk)
+		return;
+
+	ret = regmap_update_bits(pci->rk806->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].val_msk,
+				 value ? pci->pin_cfg[offset].val_msk : 0);
+	if (ret)
+		dev_err(pci->dev, "set gpio%d value %d failed\n",
+			offset, value);
+}
+
+static int rk806_gpio_direction_input(struct gpio_chip *chip,
+				      unsigned int offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int rk806_gpio_direction_output(struct gpio_chip *chip,
+				       unsigned int offset,
+				       int value)
+{
+	rk806_gpio_set(chip, offset, value);
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static int rk806_gpio_get_direction(struct gpio_chip *chip,
+				    unsigned int offset)
+{
+	struct rk806_pctrl_info *pci = gpiochip_get_data(chip);
+	unsigned int val;
+	int ret;
+
+	/* default output */
+	if (!pci->pin_cfg[offset].dir_msk)
+		return 0;
+
+	ret = regmap_read(pci->rk806->regmap,
+			  pci->pin_cfg[offset].reg,
+			  &val);
+	if (ret) {
+		dev_err(pci->dev, "get gpio%d direction failed\n", offset);
+		return ret;
+	}
+
+	return !(val & pci->pin_cfg[offset].dir_msk);
+}
+
+static struct gpio_chip rk806_gpio_chip = {
+	.label			= "rk806-gpio",
+	.request		= gpiochip_generic_request,
+	.free			= gpiochip_generic_free,
+	.get_direction		= rk806_gpio_get_direction,
+	.get			= rk806_gpio_get,
+	.set			= rk806_gpio_set,
+	.direction_input	= rk806_gpio_direction_input,
+	.direction_output	= rk806_gpio_direction_output,
+	.can_sleep		= true,
+	.base			= -1,
+	.owner			= THIS_MODULE,
+};
+
+/* generic pinctrl */
+static int rk806_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->num_pin_groups;
+}
+
+static const char *rk806_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+						unsigned int group)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->groups[group].name;
+}
+
+static int rk806_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					unsigned int group,
+					const unsigned int **pins,
+					unsigned int *num_pins)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	*pins = pci->groups[group].pins;
+	*num_pins = pci->groups[group].npins;
+
+	return 0;
+}
+
+static const struct pinctrl_ops rk806_pinctrl_ops = {
+	.get_groups_count = rk806_pinctrl_get_groups_count,
+	.get_group_name = rk806_pinctrl_get_group_name,
+	.get_group_pins = rk806_pinctrl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+static int rk806_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->num_functions;
+}
+
+static const char *rk806_pinctrl_get_func_name(struct pinctrl_dev *pctldev,
+					       unsigned int function)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->functions[function].name;
+}
+
+static int rk806_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,
+					 unsigned int function,
+					 const char *const **groups,
+					 unsigned int *const num_groups)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = pci->functions[function].groups;
+	*num_groups = pci->functions[function].ngroups;
+
+	return 0;
+}
+
+static int _rk806_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				  unsigned int offset,
+				  int mux)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	if (!pci->pin_cfg[offset].fun_msk)
+		return 0;
+
+	mux <<= ffs(pci->pin_cfg[offset].fun_msk) - 1;
+	ret = regmap_update_bits(pci->rk806->regmap,
+				 pci->pin_cfg[offset].fun_reg,
+				 pci->pin_cfg[offset].fun_msk, mux);
+
+	if (ret)
+		dev_err(pci->dev, "set gpio%d func%d failed\n", offset, mux);
+
+	return ret;
+}
+
+static int rk806_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				 unsigned int function,
+				 unsigned int group)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int mux = pci->functions[function].mux_option;
+	int offset = group;
+
+	return _rk806_pinctrl_set_mux(pctldev, offset, mux);
+}
+
+static int rk806_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+					struct pinctrl_gpio_range *range,
+					unsigned int offset, bool input)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	/* set direction */
+	if (!pci->pin_cfg[offset].dir_msk)
+		return 0;
+
+	ret = regmap_update_bits(pci->rk806->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].dir_msk,
+				 input ? 0 : pci->pin_cfg[offset].dir_msk);
+	if (ret) {
+		dev_err(pci->dev, "set gpio%d direction failed\n", offset);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rk806_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,
+					     struct pinctrl_gpio_range *range,
+					     unsigned int offset)
+{
+	return _rk806_pinctrl_set_mux(pctldev, offset, RK806_PINMUX_FUN5);
+}
+
+static const struct pinmux_ops rk806_pinmux_ops = {
+	.gpio_request_enable	= rk806_pinctrl_gpio_request_enable,
+	.get_functions_count	= rk806_pinctrl_get_funcs_count,
+	.get_function_name	= rk806_pinctrl_get_func_name,
+	.get_function_groups	= rk806_pinctrl_get_func_groups,
+	.set_mux		= rk806_pinctrl_set_mux,
+	.gpio_set_direction	= rk806_pmx_gpio_set_direction,
+};
+
+static int rk806_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned int pin,
+			     unsigned long *config)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param = pinconf_to_config_param(*config);
+	u32 arg = 0;
+
+	switch (param) {
+	case PIN_CONFIG_OUTPUT:
+	case PIN_CONFIG_INPUT_ENABLE:
+		arg = rk806_gpio_get(&pci->gpio_chip, pin);
+		break;
+	default:
+		dev_err(pci->dev, "Properties not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, (u16)arg);
+
+	return 0;
+}
+
+static int rk806_pinconf_set(struct pinctrl_dev *pctldev,
+			     unsigned int pin,
+			     unsigned long *configs,
+			     unsigned int num_configs)
+{
+	struct rk806_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param;
+	u32 i, arg = 0;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_OUTPUT:
+			rk806_pmx_gpio_set_direction(pctldev, NULL, pin, false);
+			rk806_gpio_set(&pci->gpio_chip, pin, arg);
+		break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			if (arg)
+				rk806_pmx_gpio_set_direction(pctldev,
+							     NULL,
+							     pin,
+							     true);
+		break;
+		default:
+			dev_err(pci->dev, "Properties not supported\n");
+			return -EOPNOTSUPP;
+		}
+	}
+
+	return 0;
+}
+
+static const struct pinconf_ops rk806_pinconf_ops = {
+	.pin_config_get = rk806_pinconf_get,
+	.pin_config_set = rk806_pinconf_set,
+};
+
+static struct pinctrl_desc rk806_pinctrl_desc = {
+	.name = "rk806-pinctrl",
+	.pctlops = &rk806_pinctrl_ops,
+	.pmxops = &rk806_pinmux_ops,
+	.confops = &rk806_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static int rk806_pinctrl_probe(struct platform_device *pdev)
+{
+	struct rk806_pctrl_info *pci;
+	struct device_node *np;
+	int ret;
+
+	pci = devm_kzalloc(&pdev->dev, sizeof(*pci), GFP_KERNEL);
+	if (!pci)
+		return -ENOMEM;
+
+	pci->dev = &pdev->dev;
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "pinctrl_rk806");
+	if (np)
+		pci->dev->of_node = np;
+	else
+		pci->dev->of_node = pdev->dev.parent->of_node;
+	pci->rk806 = dev_get_drvdata(pdev->dev.parent);
+
+	platform_set_drvdata(pdev, pci);
+
+	pci->pinctrl_desc = rk806_pinctrl_desc;
+	pci->gpio_chip = rk806_gpio_chip;
+	pci->pins = rk806_pins_desc;
+	pci->num_pins = ARRAY_SIZE(rk806_pins_desc);
+	pci->functions = rk806_pin_functions;
+	pci->num_functions = ARRAY_SIZE(rk806_pin_functions);
+	pci->groups = rk806_pin_groups;
+	pci->num_pin_groups = ARRAY_SIZE(rk806_pin_groups);
+	pci->pinctrl_desc.pins = rk806_pins_desc;
+	pci->pinctrl_desc.npins = ARRAY_SIZE(rk806_pins_desc);
+	pci->pin_cfg = rk806_gpio_cfgs;
+	pci->gpio_chip.ngpio = ARRAY_SIZE(rk806_gpio_cfgs);
+
+	pci->gpio_chip.parent = &pdev->dev;
+
+	if (np)
+		pci->gpio_chip.of_node = np;
+	else
+		pci->gpio_chip.of_node = pdev->dev.parent->of_node;
+
+	/* Add gpiochip */
+	ret = devm_gpiochip_add_data(&pdev->dev, &pci->gpio_chip, pci);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Couldn't add gpiochip\n");
+		return ret;
+	}
+
+	/* Add pinctrl */
+	pci->pctl = devm_pinctrl_register(&pdev->dev, &pci->pinctrl_desc, pci);
+	if (IS_ERR(pci->pctl)) {
+		dev_err(&pdev->dev, "Couldn't add pinctrl\n");
+		return PTR_ERR(pci->pctl);
+	}
+
+	/* Add pin range */
+	ret = gpiochip_add_pin_range(&pci->gpio_chip,
+				     dev_name(&pdev->dev),
+				     0,
+				     0,
+				     pci->gpio_chip.ngpio);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Couldn't add gpiochip pin range\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver rk806_pinctrl_driver = {
+	.probe = rk806_pinctrl_probe,
+	.driver = {
+		.name = "rk806-pinctrl",
+	},
+};
+
+static int __init rk806_pinctrl_driver_register(void)
+{
+	return platform_driver_register(&rk806_pinctrl_driver);
+}
+#ifdef CONFIG_ROCKCHIP_THUNDER_BOOT
+subsys_initcall(rk806_pinctrl_driver_register);
+#else
+fs_initcall_sync(rk806_pinctrl_driver_register);
+#endif
+
+MODULE_DESCRIPTION("RK806 pin control and GPIO driver");
+MODULE_AUTHOR("Xu Shengfei <xsf@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 7f479753de5..69a36787ac1 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -1054,6 +1054,14 @@ config REGULATOR_RC5T583
 	  through regulator interface. The device supports multiple DCDC/LDO
 	  outputs which can be controlled by i2c communication.
 
+config REGULATOR_RK806
+	tristate "Rockchip RK806 Power regulator"
+	depends on MFD_RK806
+	help
+	  Select this option to enable the power regulator of ROCKCHIP
+	  PMIC RK806. The device supports multiple DCDC/LDO
+	  outputs which can be controlled by spi communication.
+
 config REGULATOR_RK808
 	tristate "Rockchip RK805/RK808/RK809/RK817/RK818 Power regulators"
 	depends on MFD_RK8XX
@@ -1064,6 +1072,17 @@ config REGULATOR_RK808
 	  through regulator interface. The device supports multiple DCDC/LDO
 	  outputs which can be controlled by i2c communication.
 
+config REGULATOR_RK860X
+	tristate "Rockchip RK860X Regulator"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  This driver supports Rockchip RK860X Digitally Programmable
+	  Buck Regulator. The RK860X is a step-down switching voltage
+	  regulator that delivers a digitally programmable output from an
+	  input voltage supply of 2.5V to 5.5V. The output voltage is
+	  programmed through an I2C interface.
+
 config REGULATOR_RN5T618
 	tristate "Ricoh RN5T567/618 voltage regulators"
 	depends on MFD_RN5T618
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index ee383d8fc83..9ef068ae104 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -126,7 +126,9 @@ obj-$(CONFIG_REGULATOR_PCAP) += pcap-regulator.o
 obj-$(CONFIG_REGULATOR_PCF50633) += pcf50633-regulator.o
 obj-$(CONFIG_REGULATOR_RASPBERRYPI_TOUCHSCREEN_ATTINY)  += rpi-panel-attiny-regulator.o
 obj-$(CONFIG_REGULATOR_RC5T583)  += rc5t583-regulator.o
+obj-$(CONFIG_REGULATOR_RK806)	+= rk806-regulator.o
 obj-$(CONFIG_REGULATOR_RK808)   += rk808-regulator.o
+obj-$(CONFIG_REGULATOR_RK860X)	+= rk860x-regulator.o
 obj-$(CONFIG_REGULATOR_RN5T618) += rn5t618-regulator.o
 obj-$(CONFIG_REGULATOR_ROHM)	+= rohm-regulator.o
 obj-$(CONFIG_REGULATOR_RT4801)	+= rt4801-regulator.o
diff --git a/drivers/regulator/rk806-regulator.c b/drivers/regulator/rk806-regulator.c
new file mode 100644
index 00000000000..c7201559089
--- /dev/null
+++ b/drivers/regulator/rk806-regulator.c
@@ -0,0 +1,1210 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Regulator driver for Rockchip RK806
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ * Author: Xu Shengfei <xsf@rock-chips.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mfd/rk806.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include "internal.h"
+
+static int dbg_enable;
+
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define REG_DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define RK806_BUCK_MIN0		500000
+#define RK806_BUCK_MAX0		1500000
+#define RK806_BUCK_MIN1		1500000
+#define RK806_BUCK_MAX1		3400000
+#define RK806_BUCK_STP0		6250
+#define RK806_BUCK_STP1		25000
+
+#define RK806_NLDO_MIN		500000
+#define RK806_NLDO_MAX		3400000
+#define RK806_NLDO_STP0		1250
+#define RK806_NLDO_SEL		((RK806_NLDO_MAX - RK806_NLDO_MIN) / RK806_NLDO_STP0 + 1)
+
+#define ENABLE_MASK(id)		(BIT(id) | BIT(4 + (id)))
+#define DISABLE_VAL(id)		(BIT(4 + (id)))
+#define PWM_MODE_MSK		BIT(0)
+#define FPWM_MODE		BIT(0)
+#define AUTO_PWM_MODE		0
+
+#define RK806_DCDC_SLP_REG_OFFSET	0x0A
+#define RK806_NLDO_SLP_REG_OFFSET	0x05
+#define RK806_PLDO_SLP_REG_OFFSET	0x06
+
+#define RK806_BUCK_SEL_CNT		0xff
+#define RK806_LDO_SEL_CNT		0xff
+
+#define RK806_RAMP_RATE_4LSB_PER_1CLK	0x00/* LDO 100mV/uS buck 50mV/us */
+#define RK806_RAMP_RATE_2LSB_PER_1CLK	0x01/* LDO 50mV/uS buck 25mV/us */
+#define RK806_RAMP_RATE_1LSB_PER_1CLK	0x02/* LDO 25mV/uS buck 12.5mV/us */
+#define RK806_RAMP_RATE_1LSB_PER_2CLK	0x03/* LDO 12.5mV/uS buck 6.25mV/us */
+
+#define RK806_RAMP_RATE_1LSB_PER_4CLK	0x04/* LDO 6.28/2mV/uS buck 3.125mV/us */
+#define RK806_RAMP_RATE_1LSB_PER_8CLK	0x05/* LDO 3.12mV/uS buck 1.56mV/us */
+#define RK806_RAMP_RATE_1LSB_PER_13CLK	0x06/* LDO 1.9mV/uS buck 961mV/us */
+#define RK806_RAMP_RATE_1LSB_PER_32CLK	0x07/* LDO 0.78mV/uS buck 0.39mV/us */
+
+static int vsel_ctr_sel_id[RK806_ID_END] = {
+	BUCK1_VSEL_CTR_SEL,
+	BUCK2_VSEL_CTR_SEL,
+	BUCK3_VSEL_CTR_SEL,
+	BUCK4_VSEL_CTR_SEL,
+	BUCK5_VSEL_CTR_SEL,
+	BUCK6_VSEL_CTR_SEL,
+	BUCK7_VSEL_CTR_SEL,
+	BUCK8_VSEL_CTR_SEL,
+	BUCK9_VSEL_CTR_SEL,
+	BUCK10_VSEL_CTR_SEL,
+	NLDO1_VSEL_CTR_SEL,
+	NLDO2_VSEL_CTR_SEL,
+	NLDO3_VSEL_CTR_SEL,
+	NLDO4_VSEL_CTR_SEL,
+	NLDO5_VSEL_CTR_SEL,
+	PLDO1_VSEL_CTR_SEL,
+	PLDO2_VSEL_CTR_SEL,
+	PLDO3_VSEL_CTR_SEL,
+	PLDO4_VSEL_CTR_SEL,
+	PLDO5_VSEL_CTR_SEL,
+	PLDO6_VSEL_CTR_SEL,
+};
+
+static int start_dvs_id[RK806_ID_END] = {
+	BUCK1_DVS_CTR_SEL,
+	BUCK2_DVS_CTR_SEL,
+	BUCK3_DVS_CTR_SEL,
+	BUCK4_DVS_CTR_SEL,
+	BUCK5_DVS_CTR_SEL,
+	BUCK6_DVS_CTR_SEL,
+	BUCK7_DVS_CTR_SEL,
+	BUCK8_DVS_CTR_SEL,
+	BUCK9_DVS_CTR_SEL,
+	BUCK10_DVS_CTR_SEL,
+	NLDO1_DVS_CTR_SEL,
+	NLDO2_DVS_CTR_SEL,
+	NLDO3_DVS_CTR_SEL,
+	NLDO4_DVS_CTR_SEL,
+	NLDO5_DVS_CTR_SEL,
+	PLDO1_DVS_CTR_SEL,
+	PLDO2_DVS_CTR_SEL,
+	PLDO3_DVS_CTR_SEL,
+	PLDO4_DVS_CTR_SEL,
+	PLDO5_DVS_CTR_SEL,
+	PLDO6_DVS_CTR_SEL,
+};
+
+static const int rk806_buck_rate_config_field[10][2] = {
+	{ BUCK1_RATE, BUCK1_RATE2 },
+	{ BUCK2_RATE, BUCK2_RATE2 },
+	{ BUCK3_RATE, BUCK3_RATE2 },
+	{ BUCK4_RATE, BUCK4_RATE2 },
+	{ BUCK5_RATE, BUCK5_RATE2 },
+	{ BUCK6_RATE, BUCK6_RATE2 },
+	{ BUCK7_RATE, BUCK7_RATE2 },
+	{ BUCK8_RATE, BUCK8_RATE2 },
+	{ BUCK9_RATE, BUCK9_RATE2 },
+	{ BUCK10_RATE, BUCK10_RATE2 },
+};
+
+struct rk806_dvs_field {
+	int en_reg;
+	int en_bit;
+	int sleep_en;
+	int on_vsel;
+	int sleep_vsel;
+	int vsel_ctrl_sel;
+};
+
+struct rk806_dvs_status {
+	int en_reg_val;
+	int en_bit_val;
+	int sleep_en_val;
+	int on_vsel_val;
+	int sleep_vsel_val;
+	int vsel_ctrl_sel_val;
+	int dvs_gpio_level[3];
+};
+
+struct rk806_regulator_data {
+	struct device_node *dvs_dn[RK806_DVS_END][RK806_ID_END];
+	struct rk806_dvs_field dvs_field[RK806_ID_END];
+	struct rk806_dvs_status dvs_mode[RK806_ID_END];
+	struct rk806_dvs_status sleep_mode[RK806_ID_END];
+
+	int dvs_ctrl_mode_init[RK806_ID_END];
+	int dvs_ctrl_mode[RK806_ID_END];
+	int dvs_ctrl_id[RK806_ID_END];
+	int vsel_ctrl_id[RK806_ID_END];
+
+	int dvs_flag[RK806_DVS_END];
+	int dvs_used[RK806_DVS_END];
+	int dvs_count[RK806_DVS_END];
+
+	int regulator_init;
+	int support_dvs;
+	struct gpio_desc *dvs_gpios[3];
+	struct rk806 *rk806;
+};
+
+#define INIT_DVS_FIELD(_en_reg, _en_bit, _sleep_en, _on_vsel,	\
+			_sleep_vsel, _vsel_ctrl_sel)	\
+{	\
+	.en_reg = _en_reg,	\
+	.en_bit = _en_bit,	\
+	.sleep_en = _sleep_en,	\
+	.on_vsel = _on_vsel,	\
+	.sleep_vsel = _sleep_vsel,	\
+	.vsel_ctrl_sel = _vsel_ctrl_sel,	\
+}
+
+static const struct rk806_dvs_field rk806_dvs_fields[RK806_ID_END] = {
+	INIT_DVS_FIELD(POWER_EN0, BIT(0), BUCK1_SLP_EN,
+		       BUCK1_ON_VSEL, BUCK1_SLP_VSEL, BUCK1_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN0, BIT(1), BUCK2_SLP_EN,
+		       BUCK2_ON_VSEL, BUCK2_SLP_VSEL, BUCK2_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN0, BIT(2), BUCK3_SLP_EN,
+		       BUCK3_ON_VSEL, BUCK3_SLP_VSEL, BUCK3_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN0, BIT(3), BUCK4_SLP_EN,
+		       BUCK4_ON_VSEL, BUCK4_SLP_VSEL, BUCK4_VSEL_CTR_SEL),
+
+	INIT_DVS_FIELD(POWER_EN1, BIT(0), BUCK5_SLP_EN,
+		       BUCK5_ON_VSEL, BUCK5_SLP_VSEL, BUCK5_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN1, BIT(1), BUCK6_SLP_EN,
+		       BUCK6_ON_VSEL, BUCK6_SLP_VSEL, BUCK6_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN1, BIT(2), BUCK7_SLP_EN,
+		       BUCK7_ON_VSEL, BUCK7_SLP_VSEL, BUCK7_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN1, BIT(3), BUCK8_SLP_EN,
+		       BUCK8_ON_VSEL, BUCK8_SLP_VSEL, BUCK8_VSEL_CTR_SEL),
+
+	INIT_DVS_FIELD(POWER_EN2, BIT(0), BUCK9_SLP_EN,
+		       BUCK9_ON_VSEL, BUCK9_SLP_VSEL, BUCK9_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN2, BIT(1), BUCK10_SLP_EN,
+		       BUCK10_ON_VSEL, BUCK10_SLP_VSEL, BUCK10_VSEL_CTR_SEL),
+
+	INIT_DVS_FIELD(POWER_EN3, BIT(0), NLDO1_SLP_EN,
+		       NLDO1_ON_VSEL, NLDO1_SLP_VSEL, NLDO1_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN3, BIT(1), NLDO2_SLP_EN,
+		       NLDO2_ON_VSEL, NLDO2_SLP_VSEL, NLDO2_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN3, BIT(2), NLDO3_SLP_EN,
+		       NLDO3_ON_VSEL, NLDO3_SLP_VSEL, NLDO3_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN3, BIT(3), NLDO4_SLP_EN,
+		       NLDO4_ON_VSEL, NLDO4_SLP_VSEL, NLDO4_VSEL_CTR_SEL),
+
+	INIT_DVS_FIELD(POWER_EN5, BIT(2), NLDO5_SLP_EN,
+		       NLDO5_ON_VSEL, NLDO5_SLP_VSEL, NLDO5_VSEL_CTR_SEL),
+
+	INIT_DVS_FIELD(POWER_EN4, BIT(1), PLDO1_SLP_EN,
+		       PLDO1_ON_VSEL, PLDO1_SLP_VSEL, PLDO1_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN4, BIT(2), PLDO2_SLP_EN,
+		       PLDO2_ON_VSEL, PLDO2_SLP_VSEL, PLDO2_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN4, BIT(3), PLDO3_SLP_EN,
+		       PLDO3_ON_VSEL, PLDO3_SLP_VSEL, PLDO3_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN5, BIT(0), PLDO4_SLP_EN,
+		       PLDO4_ON_VSEL, PLDO4_SLP_VSEL, PLDO4_VSEL_CTR_SEL),
+
+	INIT_DVS_FIELD(POWER_EN5, BIT(1), PLDO5_SLP_EN,
+		       PLDO5_ON_VSEL, PLDO5_SLP_VSEL, PLDO5_VSEL_CTR_SEL),
+	INIT_DVS_FIELD(POWER_EN4, BIT(0), PLDO6_SLP_EN,
+		       PLDO6_ON_VSEL, PLDO6_SLP_VSEL, PLDO6_VSEL_CTR_SEL),
+};
+
+static const struct linear_range rk806_buck_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0, 159, 6250), /* 500mV ~ 1500mV */
+	REGULATOR_LINEAR_RANGE(1500000, 160, 236, 25000), /* 1500mV ~ 3400mV */
+	REGULATOR_LINEAR_RANGE(3400000, 237, 255, 0),
+};
+
+static const struct linear_range rk806_ldo_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0, 232, 12500), /* 500mV ~ 3400mV */
+	REGULATOR_LINEAR_RANGE(3400000, 233, 255, 0), /* 500mV ~ 3400mV */
+};
+
+static int get_count(int value)
+{
+	int count = 0;
+
+	while (value != 0) {
+		if (value % 2 == 1)
+			count++;
+		value >>= 1;
+	}
+
+	return count;
+}
+
+static void rk806_dvs_start_fun_init(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+
+	rk806_field_write(rk806,
+			  pdata->dvs_ctrl_id[rid],
+			  pdata->dvs_ctrl_mode[rid]);
+}
+
+static void rk806_dvs_pwrctrl_fun_init(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int offset;
+
+	/* init dvs pin function */
+	offset = pdata->dvs_ctrl_mode[rid] - RK806_DVS_PWRCTRL1;
+	rk806_field_write(rk806, PWRCTRL1_FUN + offset, PWRCTRL_DVS_FUN);
+
+	rk806_field_write(rk806,
+			  pdata->dvs_ctrl_id[rid],
+			  pdata->dvs_ctrl_mode[rid] - RK806_DVS_START3);
+}
+
+static void rk806_dvs_start_pwrctrl_fun_init(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int offset;
+
+	/* init dvs pin function */
+	offset = pdata->dvs_ctrl_mode[rid] - RK806_DVS_START_PWRCTR1;
+	/*set pin polarity, active high */
+	rk806_field_write(rk806, PWRCTRL1_POL + offset, POL_HIGH);
+	rk806_field_write(rk806, PWRCTRL1_FUN + offset, PWRCTRL_DVS_FUN);
+
+	/* enable start bit dvs  function */
+	rk806_field_write(rk806,
+			  pdata->dvs_ctrl_id[rid],
+			  pdata->dvs_ctrl_mode[rid] - RK806_DVS_PWRCTRL3);
+	rk806_field_write(rk806,
+			  pdata->vsel_ctrl_id[rid],
+			  pdata->dvs_ctrl_mode[rid] - RK806_DVS_PWRCTRL3);
+
+}
+
+static int rk806_dvs_mode_init(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	int rid = rdev_get_id(rdev);
+	int mode, j;
+
+	for (mode = RK806_DVS_START1; mode < RK806_DVS_END; mode++) {
+		for (j = 0; j < RK806_ID_END; j++) {
+			if ((pdata->dvs_dn[mode][j] == NULL) ||
+			    (strcmp(pdata->dvs_dn[mode][j]->name, rdev->desc->name)))
+				continue;
+
+			pdata->dvs_ctrl_mode[rid] = mode;
+			pdata->dvs_ctrl_mode_init[rid] = 1;
+			pdata->dvs_flag[mode] |= BIT(rid);
+
+			/* init dvs function, dvs-pin or start bit */
+			if (mode <= RK806_DVS_START3)
+				rk806_dvs_start_fun_init(rdev);
+			else if (mode <= RK806_DVS_PWRCTRL3)
+				rk806_dvs_pwrctrl_fun_init(rdev);
+			else if (mode <= RK806_DVS_START_PWRCTR3)
+				rk806_dvs_start_pwrctrl_fun_init(rdev);
+			return pdata->dvs_ctrl_mode[rid];
+		}
+	}
+
+	return pdata->dvs_ctrl_mode[rid];
+}
+
+static int get_dvs_mode(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	int rid = rdev_get_id(rdev);
+
+	if (!pdata->support_dvs)
+		return RK806_DVS_NOT_SUPPORT;
+
+	if (pdata->dvs_ctrl_mode_init[rid] || pdata->regulator_init)
+		return pdata->dvs_ctrl_mode[rid];
+
+	return rk806_dvs_mode_init(rdev);
+}
+
+static int get_gpio_id(int mode)
+{
+	int pid = -1;
+
+	if ((mode >= RK806_DVS_PWRCTRL1) && (mode <= RK806_DVS_PWRCTRL3))
+		pid = mode - RK806_DVS_PWRCTRL1;
+
+	return pid;
+}
+
+static int rk806_get_reg_offset(int id)
+{
+	int reg_offset = 0;
+
+	if (id >= RK806_ID_DCDC1 && id <= RK806_ID_DCDC10)
+		reg_offset = RK806_DCDC_SLP_REG_OFFSET;
+	else if ((id >= RK806_ID_NLDO1 && id <= RK806_ID_NLDO4) ||
+		 (id == RK806_ID_NLDO5))
+		reg_offset = RK806_NLDO_SLP_REG_OFFSET;
+	else if (id >= RK806_ID_PLDO1 && id <= RK806_ID_PLDO6)
+		reg_offset = RK806_PLDO_SLP_REG_OFFSET;
+
+	return reg_offset;
+}
+
+static int rk806_get_read_vsel_register(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	int level, vsel_reg, pid;
+	int rid = rdev_get_id(rdev);
+	int mode;
+
+	vsel_reg = rdev->desc->vsel_reg;
+	if (!pdata->support_dvs)
+		return vsel_reg;
+
+	mode = get_dvs_mode(rdev);
+	pid = get_gpio_id(mode);
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		level = gpiod_get_value(pdata->dvs_gpios[pid]);
+		/* level == 0, the Output high level, the SLP_VSEL output */
+		if (level == 0)
+			vsel_reg = rdev->desc->vsel_reg + rk806_get_reg_offset(rid);
+	}
+
+	return vsel_reg;
+}
+
+static int rk806_get_write_vsel_register(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	int level, vsel_reg, pid;
+	int rid = rdev_get_id(rdev);
+	int mode;
+
+	vsel_reg = rdev->desc->vsel_reg;
+	if (!pdata->support_dvs)
+		return vsel_reg;
+
+	mode = get_dvs_mode(rdev);
+	pid = get_gpio_id(mode);
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		level = gpiod_get_value(pdata->dvs_gpios[pid]);
+		/* level == 1, output low level, the ON_VSEL output, next SLP_VSEL */
+		if (level == 1)
+			vsel_reg = rdev->desc->vsel_reg + rk806_get_reg_offset(rid);
+	}
+
+	return vsel_reg;
+}
+
+static void rk806_do_gpio_dvs(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	char dvs_ctrl_name[10][32] = {
+					"dvs_default",
+					"start_dvs1_ctrl",
+					"start_dvs2_ctrl",
+					"start_dvs3_ctrl",
+					"dvs_pin1_ctrl",
+					"dvs_pin2_ctrl",
+					"dvs_pin3_ctrl",
+					"start_and_pwrctrl1",
+					"start_and_pwrctrl2",
+					"start_and_pwrctrl3"};
+	int rid = rdev_get_id(rdev);
+	int gpio_level, pid;
+	int mode, count;
+
+	mode = get_dvs_mode(rdev);
+	pdata->dvs_used[mode] |= BIT(rid);
+	count = get_count(pdata->dvs_used[mode]);
+
+	if ((pdata->dvs_used[mode] != pdata->dvs_flag[mode]) ||
+	    (count != pdata->dvs_count[mode]))
+		return;
+
+	pdata->dvs_used[mode] = 0;
+
+	pid = get_gpio_id(mode);
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		gpio_level = gpiod_get_value(pdata->dvs_gpios[pid]);
+		if (gpio_level == 1)
+			gpiod_set_value(pdata->dvs_gpios[pid], 0);
+		else
+			gpiod_set_value(pdata->dvs_gpios[pid], 1);
+	}
+	REG_DBG("pin: name: %s, %s\n", dvs_ctrl_name[mode], rdev->desc->name);
+}
+
+static void rk806_do_soft_dvs(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	char dvs_ctrl_name[10][32] = {
+					"dvs_default",
+					"start_dvs1_ctrl",
+					"start_dvs2_ctrl",
+					"start_dvs3_ctrl",
+					"dvs_pin1_ctrl",
+					"dvs_pin2_ctrl",
+					"dvs_pin3_ctrl",
+					"start_and_pwrctrl1",
+					"start_and_pwrctrl2",
+					"start_and_pwrctrl3"};
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int soft_mode, count;
+	int offset;
+
+	soft_mode = get_dvs_mode(rdev);
+	pdata->dvs_used[soft_mode] |= BIT(rid);
+	count = get_count(pdata->dvs_used[soft_mode]);
+
+	if ((pdata->dvs_used[soft_mode] != pdata->dvs_flag[soft_mode]) ||
+	    (count != pdata->dvs_count[soft_mode]))
+		return;
+
+	pdata->dvs_used[soft_mode] = 0;
+
+	if (soft_mode < RK806_DVS_START_PWRCTR1)
+		offset = soft_mode - RK806_DVS_START1;
+	else
+		offset = soft_mode - RK806_DVS_START_PWRCTR1;
+
+	rk806_field_write(rk806, DVS_START1 + offset, 0x01);
+	REG_DBG("soft:%s, %s\n", dvs_ctrl_name[soft_mode], rdev->desc->name);
+}
+
+static void rk806_regulator_sync_voltage(struct regulator_dev *rdev)
+{
+	int mode;
+
+	mode = get_dvs_mode(rdev);
+	if (mode == RK806_DVS_NOT_SUPPORT)
+		return;
+
+	if ((mode >= RK806_DVS_PWRCTRL1) && (mode <= RK806_DVS_PWRCTRL3))
+		rk806_do_gpio_dvs(rdev);
+	else
+		rk806_do_soft_dvs(rdev);
+}
+
+static unsigned int rk806_regulator_of_map_mode(unsigned int mode)
+{
+	switch (mode) {
+	case 1:
+		return REGULATOR_MODE_FAST;
+	case 2:
+		return REGULATOR_MODE_NORMAL;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int rk806_set_suspend_enable_ctrl(struct regulator_dev *rdev,
+					 unsigned int en)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	unsigned int val;
+
+	if (en)
+		val = 1;
+	else
+		val = 0;
+
+	if ((get_dvs_mode(rdev) < RK806_DVS_PWRCTRL1) ||
+	    (get_dvs_mode(rdev) > RK806_DVS_PWRCTRL3))
+		return rk806_field_write(rk806, pdata->dvs_field[rid].sleep_en, val);
+
+	pdata->sleep_mode[rid].sleep_en_val = val;
+
+	return 0;
+}
+
+static int rk806_set_suspend_enable(struct regulator_dev *rdev)
+{
+	return rk806_set_suspend_enable_ctrl(rdev, 1);
+}
+
+static int rk806_set_suspend_disable(struct regulator_dev *rdev)
+{
+	return rk806_set_suspend_enable_ctrl(rdev, 0);
+}
+
+static int rk806_set_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	int rid = rdev_get_id(rdev);
+	int ctr_bit, reg;
+
+	if (rid > RK806_ID_DCDC10)
+		return 0;
+
+	reg = RK806_POWER_FPWM_EN0 + rid / 8;
+	ctr_bit = rid % 8;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return regmap_update_bits(rdev->regmap, reg,
+					  PWM_MODE_MSK << ctr_bit,
+					  FPWM_MODE << ctr_bit);
+	case REGULATOR_MODE_NORMAL:
+		return regmap_update_bits(rdev->regmap, reg,
+					  PWM_MODE_MSK << ctr_bit,
+					  AUTO_PWM_MODE << ctr_bit);
+	default:
+		dev_err(&rdev->dev, "do not support this mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int rk806_get_mode(struct regulator_dev *rdev)
+{
+	int rid = rdev_get_id(rdev);
+	int ctr_bit, reg;
+	unsigned int val;
+	int err;
+
+	if (rid > RK806_ID_DCDC10)
+		return 0;
+
+	reg = RK806_POWER_FPWM_EN0 + rid / 8;
+	ctr_bit = rid % 8;
+
+	err = regmap_read(rdev->regmap, reg, &val);
+	if (err)
+		return err;
+
+	if ((val >> ctr_bit) & FPWM_MODE)
+		return REGULATOR_MODE_FAST;
+	else
+		return REGULATOR_MODE_NORMAL;
+}
+
+static int rk806_regulator_sleep2dvs_mode(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int mode = get_dvs_mode(rdev);
+	int rid = rdev_get_id(rdev);
+	int pid = get_gpio_id(mode);
+	int gpio_level, j;
+
+	/* set slp_fun NULL*/
+	if (pdata->dvs_ctrl_mode[rid] == RK806_DVS_PWRCTRL1)
+		rk806_field_write(rk806, PWRCTRL1_FUN, PWRCTRL_DVS_FUN);
+	else if (pdata->dvs_ctrl_mode[rid] == RK806_DVS_PWRCTRL2)
+		rk806_field_write(rk806, PWRCTRL2_FUN, PWRCTRL_DVS_FUN);
+	else if (pdata->dvs_ctrl_mode[rid] == RK806_DVS_PWRCTRL3)
+		rk806_field_write(rk806, PWRCTRL3_FUN, PWRCTRL_DVS_FUN);
+
+
+	/* 3.check the used count 1*/
+	pdata->dvs_used[mode] |= BIT(rid);
+	if (pdata->dvs_used[mode] != pdata->dvs_flag[mode])
+		return 0;
+
+	pdata->dvs_used[mode] = 0;
+	/* 5.clear the SLP_CTRL_SEL */
+	for (j = 0; j < RK806_ID_END; j++)
+		if (pdata->dvs_ctrl_mode[j] == mode)
+			rk806_field_write(rk806,
+					  pdata->dvs_field[j].vsel_ctrl_sel,
+					  pdata->dvs_ctrl_mode[j]);
+
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		gpio_level = pdata->dvs_mode[rid].dvs_gpio_level[pid];
+		if (gpio_level == 1) {
+			gpiod_set_value(pdata->dvs_gpios[pid], 0);
+			rk806_field_write(rk806,
+					  pdata->dvs_field[rid].on_vsel,
+					  pdata->dvs_mode[rid].on_vsel_val);
+			rk806_field_write(rk806,
+					  pdata->dvs_field[rid].en_reg,
+					  pdata->dvs_mode[rid].en_reg_val | (pdata->dvs_field[rid].en_bit << 4));
+		}
+	}
+	return 0;
+}
+
+static int rk806_regulator_resume(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int j;
+
+	if (!pdata->support_dvs)
+		return 0;
+
+	if (rid == RK806_ID_DCDC1) {
+		for (j = 0; j < RK806_ID_END; j++) {
+			rk806_field_write(rk806,
+					  pdata->dvs_field[j].vsel_ctrl_sel,
+					  0x00);
+			rk806_field_write(rk806,
+					  pdata->dvs_field[j].sleep_vsel,
+					  pdata->dvs_mode[j].sleep_vsel_val);
+			rk806_field_write(rk806,
+					  pdata->dvs_field[j].sleep_en,
+					  pdata->dvs_mode[j].sleep_en_val);
+		}
+	}
+
+	if ((get_dvs_mode(rdev) >= RK806_DVS_PWRCTRL1) &&
+	    (get_dvs_mode(rdev) <= RK806_DVS_PWRCTRL3))
+		rk806_regulator_sleep2dvs_mode(rdev);
+	return 0;
+}
+
+static int rk806_set_suspend_voltage_range(struct regulator_dev *rdev, int uv)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	int sel = regulator_map_voltage_linear_range(rdev, uv, uv);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int reg_offset;
+	unsigned int reg;
+
+	if (sel < 0)
+		return -EINVAL;
+
+	reg_offset = rk806_get_reg_offset(rid);
+	reg = rdev->desc->vsel_reg + reg_offset;
+
+	return regmap_update_bits(rk806->regmap, reg,
+				  rdev->desc->vsel_mask,
+				  sel);
+}
+
+static int rk806_get_voltage_sel_regmap(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int vsel_reg;
+	int ret;
+
+	vsel_reg = rk806_get_read_vsel_register(rdev);
+
+	ret = regmap_read(rdev->regmap, vsel_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	val &= rdev->desc->vsel_mask;
+	val >>= ffs(rdev->desc->vsel_mask) - 1;
+
+	return val;
+}
+
+static int rk806_set_voltage(struct regulator_dev *rdev,
+			     int req_min_uV, int req_max_uV,
+			     unsigned int *selector)
+{
+	int vsel_reg;
+	int mode;
+	int ret;
+	int sel;
+
+	ret = regulator_map_voltage_linear_range(rdev, req_min_uV, req_max_uV);
+	if (ret >= 0) {
+		*selector = ret;
+		sel = ret;
+	} else {
+		return -EINVAL;
+	}
+
+	vsel_reg = rk806_get_write_vsel_register(rdev);
+
+	sel <<= ffs(rdev->desc->vsel_mask) - 1;
+
+	ret = regmap_update_bits(rdev->regmap, vsel_reg,
+				 rdev->desc->vsel_mask, sel);
+
+	mode = get_dvs_mode(rdev);
+	if (mode == RK806_DVS_NOT_SUPPORT)
+		return ret;
+
+	if ((mode >= RK806_DVS_PWRCTRL1) &&
+	    (mode <= RK806_DVS_PWRCTRL3))
+		rk806_do_gpio_dvs(rdev);
+	else
+		rk806_do_soft_dvs(rdev);
+
+	return ret;
+}
+
+static int rk806_regulator_is_enabled_regmap(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int gpio_level, pid;
+	unsigned int val;
+	int mode;
+
+	mode = get_dvs_mode(rdev);
+	pid = get_gpio_id(mode);
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		gpio_level = gpiod_get_value(pdata->dvs_gpios[pid]);
+		if (gpio_level == 0)
+			return rk806_field_read(rk806, pdata->dvs_field[rid].sleep_en);
+	}
+
+	val = rk806_field_read(rk806, pdata->dvs_field[rid].en_reg);
+	return (val & rdev->desc->enable_val) != 0;
+}
+
+static int rk806_regulator_enable_regmap(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int gpio_level, pid;
+	int mode;
+
+	mode = get_dvs_mode(rdev);
+	pid = get_gpio_id(mode);
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		gpio_level = gpiod_get_value(pdata->dvs_gpios[pid]);
+		if (gpio_level == 0)
+			return rk806_field_write(rk806,
+						 pdata->dvs_field[rid].sleep_en,
+						 0x01);
+	}
+
+	return rk806_field_write(rk806,
+				 pdata->dvs_field[rid].en_reg,
+				 rdev->desc->enable_val);
+}
+
+static int rk806_regulator_disable_regmap(struct regulator_dev *rdev)
+{
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+	int gpio_level, pid;
+	int mode;
+
+	mode = get_dvs_mode(rdev);
+	pid = get_gpio_id(mode);
+	if ((pid >= 0) && (pdata->dvs_gpios[pid] != NULL)) {
+		gpio_level = gpiod_get_value(pdata->dvs_gpios[pid]);
+		if (gpio_level == 0)
+			return rk806_field_write(rk806,
+						 pdata->dvs_field[rid].sleep_en,
+						 0x00);
+	}
+
+	return rk806_field_write(rk806,
+				 pdata->dvs_field[rid].en_reg,
+				 rdev->desc->disable_val);
+}
+
+static int rk806_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
+{
+	unsigned int ramp_value = RK806_RAMP_RATE_2LSB_PER_1CLK;
+	struct rk806_regulator_data *pdata = rdev_get_drvdata(rdev);
+	struct rk806 *rk806 = pdata->rk806;
+	int rid = rdev_get_id(rdev);
+
+	if (rid <= RK806_ID_DCDC10) {
+		switch (ramp_delay) {
+		case 1 ... 390:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_32CLK;
+			break;
+		case 391 ... 961:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_13CLK;
+			break;
+		case 962 ... 1560:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_8CLK;
+			break;
+		case 1561 ... 3125:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_4CLK;
+			break;
+		case 3126 ... 6250:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_2CLK;
+			break;
+		case 6251 ... 12500:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_1CLK;
+			break;
+		case 12501 ... 25000:
+			ramp_value = RK806_RAMP_RATE_2LSB_PER_1CLK;
+			break;
+		case 25001 ... 50000: /* 50mV/us */
+			ramp_value = RK806_RAMP_RATE_4LSB_PER_1CLK;
+			break;
+		default:
+			pr_warn("%s ramp_delay: %d not supported, setting 10000\n",
+				rdev->desc->name, ramp_delay);
+		}
+
+		rk806_field_write(rk806,
+				  rk806_buck_rate_config_field[rid][0],
+				  ramp_value & 0x03);
+		return rk806_field_write(rk806,
+					 rk806_buck_rate_config_field[rid][1],
+					 (ramp_value & 0x4) >> 2);
+	} else {
+		switch (ramp_delay) {
+		case 1 ... 780:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_32CLK;
+			break;
+		case 781 ... 1900:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_13CLK;
+			break;
+		case 1901 ... 3120:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_8CLK;
+			break;
+		case 3121 ... 6280:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_4CLK;
+			break;
+		case 6281 ... 12500:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_2CLK;
+			break;
+		case 12501 ... 25000:
+			ramp_value = RK806_RAMP_RATE_1LSB_PER_1CLK;
+			break;
+		case 25001 ... 50000:
+			ramp_value = RK806_RAMP_RATE_2LSB_PER_1CLK;
+			break;
+		case 50001 ... 100000:
+			ramp_value = RK806_RAMP_RATE_4LSB_PER_1CLK;
+			break;
+		default:
+			pr_warn("%s ramp_delay: %d not supported, setting 10000\n",
+				rdev->desc->name, ramp_delay);
+		}
+		return rk806_field_write(rk806, LDO_RATE, ramp_value);
+	}
+}
+
+static const struct regulator_ops rk806_ops_dcdc = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+
+	.get_voltage_sel	= rk806_get_voltage_sel_regmap,
+	.set_voltage		= rk806_set_voltage,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.set_mode		= rk806_set_mode,
+	.get_mode		= rk806_get_mode,
+
+	.enable			= rk806_regulator_enable_regmap,
+	.disable		= rk806_regulator_disable_regmap,
+	.is_enabled		= rk806_regulator_is_enabled_regmap,
+
+	.set_suspend_mode	= rk806_set_mode,
+	.set_ramp_delay		= rk806_set_ramp_delay,
+
+	.set_suspend_voltage	= rk806_set_suspend_voltage_range,
+	.resume			= rk806_regulator_resume,
+	.set_suspend_enable	= rk806_set_suspend_enable,
+	.set_suspend_disable	= rk806_set_suspend_disable,
+};
+
+static const struct regulator_ops rk806_ops_ldo = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+
+	.get_voltage_sel	= rk806_get_voltage_sel_regmap,
+	.set_voltage		= rk806_set_voltage,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+
+	.enable			= rk806_regulator_enable_regmap,
+	.disable		= rk806_regulator_disable_regmap,
+	.is_enabled		= rk806_regulator_is_enabled_regmap,
+
+	.set_suspend_mode	= rk806_set_mode,
+	.set_ramp_delay		= rk806_set_ramp_delay,
+
+	.set_suspend_voltage	= rk806_set_suspend_voltage_range,
+	.resume			= rk806_regulator_resume,
+	.set_suspend_enable	= rk806_set_suspend_enable,
+	.set_suspend_disable	= rk806_set_suspend_disable,
+};
+
+#define RK806_REGULATOR(_name, _supply_name, _id, _ops,\
+			_n_voltages, _vr, _er, _lr, ctrl_bit)\
+[_id] = {\
+		.name = _name,\
+		.supply_name = _supply_name,\
+		.of_match = of_match_ptr(_name),\
+		.regulators_node = of_match_ptr("regulators"),\
+		.id = _id,\
+		.ops = &_ops,\
+		.type = REGULATOR_VOLTAGE,\
+		.n_voltages = _n_voltages,\
+		.linear_ranges = _lr,\
+		.n_linear_ranges = ARRAY_SIZE(_lr),\
+		.vsel_reg = _vr,\
+		.vsel_mask = 0xff,\
+		.enable_reg = _er,\
+		.enable_mask = ENABLE_MASK(ctrl_bit),\
+		.enable_val = ENABLE_MASK(ctrl_bit),\
+		.disable_val = DISABLE_VAL(ctrl_bit),\
+		.of_map_mode = rk806_regulator_of_map_mode,\
+		.owner = THIS_MODULE,\
+	}
+
+static const struct regulator_desc rk806_regulators[] = {
+	RK806_REGULATOR("DCDC_REG1", "vcc1", RK806_ID_DCDC1, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK1_ON_VSEL,
+			RK806_POWER_EN0, rk806_buck_voltage_ranges, 0),
+	RK806_REGULATOR("DCDC_REG2", "vcc2", RK806_ID_DCDC2, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK2_ON_VSEL,
+			RK806_POWER_EN0, rk806_buck_voltage_ranges, 1),
+	RK806_REGULATOR("DCDC_REG3", "vcc3", RK806_ID_DCDC3, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK3_ON_VSEL,
+			RK806_POWER_EN0, rk806_buck_voltage_ranges, 2),
+	RK806_REGULATOR("DCDC_REG4", "vcc4", RK806_ID_DCDC4, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK4_ON_VSEL,
+			RK806_POWER_EN0, rk806_buck_voltage_ranges, 3),
+
+	RK806_REGULATOR("DCDC_REG5", "vcc5", RK806_ID_DCDC5, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK5_ON_VSEL,
+			RK806_POWER_EN1, rk806_buck_voltage_ranges, 0),
+	RK806_REGULATOR("DCDC_REG6", "vcc6", RK806_ID_DCDC6, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK6_ON_VSEL,
+			RK806_POWER_EN1, rk806_buck_voltage_ranges, 1),
+	RK806_REGULATOR("DCDC_REG7", "vcc7", RK806_ID_DCDC7, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK7_ON_VSEL,
+			RK806_POWER_EN1, rk806_buck_voltage_ranges, 2),
+	RK806_REGULATOR("DCDC_REG8", "vcc8", RK806_ID_DCDC8, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK8_ON_VSEL,
+			RK806_POWER_EN1, rk806_buck_voltage_ranges, 3),
+
+	RK806_REGULATOR("DCDC_REG9", "vcc9", RK806_ID_DCDC9, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK9_ON_VSEL,
+			RK806_POWER_EN2, rk806_buck_voltage_ranges, 0),
+	RK806_REGULATOR("DCDC_REG10", "vcc10", RK806_ID_DCDC10, rk806_ops_dcdc,
+			RK806_BUCK_SEL_CNT, RK806_BUCK10_ON_VSEL,
+			RK806_POWER_EN2, rk806_buck_voltage_ranges, 1),
+
+	RK806_REGULATOR("NLDO_REG1", "vcc13", RK806_ID_NLDO1, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_NLDO1_ON_VSEL,
+			RK806_POWER_EN3, rk806_ldo_voltage_ranges, 0),
+	RK806_REGULATOR("NLDO_REG2", "vcc13", RK806_ID_NLDO2, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_NLDO2_ON_VSEL,
+			RK806_POWER_EN3, rk806_ldo_voltage_ranges, 1),
+	RK806_REGULATOR("NLDO_REG3", "vcc13", RK806_ID_NLDO3, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_NLDO3_ON_VSEL,
+			RK806_POWER_EN3, rk806_ldo_voltage_ranges, 2),
+	RK806_REGULATOR("NLDO_REG4", "vcc14", RK806_ID_NLDO4, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_NLDO4_ON_VSEL,
+			RK806_POWER_EN3, rk806_ldo_voltage_ranges, 3),
+
+	RK806_REGULATOR("NLDO_REG5", "vcc14", RK806_ID_NLDO5, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_NLDO5_ON_VSEL,
+			RK806_POWER_EN5, rk806_ldo_voltage_ranges, 2),
+
+	RK806_REGULATOR("PLDO_REG1", "vcc11", RK806_ID_PLDO1, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_PLDO1_ON_VSEL,
+			RK806_POWER_EN4, rk806_ldo_voltage_ranges, 1),
+	RK806_REGULATOR("PLDO_REG2", "vcc11", RK806_ID_PLDO2, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_PLDO2_ON_VSEL,
+			RK806_POWER_EN4, rk806_ldo_voltage_ranges, 2),
+	RK806_REGULATOR("PLDO_REG3", "vcc11", RK806_ID_PLDO3, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_PLDO3_ON_VSEL,
+			RK806_POWER_EN4, rk806_ldo_voltage_ranges, 3),
+
+	RK806_REGULATOR("PLDO_REG4", "vcc12", RK806_ID_PLDO4, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_PLDO4_ON_VSEL,
+			RK806_POWER_EN5, rk806_ldo_voltage_ranges, 0),
+	RK806_REGULATOR("PLDO_REG5", "vcc12", RK806_ID_PLDO5, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_PLDO5_ON_VSEL,
+			RK806_POWER_EN5, rk806_ldo_voltage_ranges, 1),
+
+	RK806_REGULATOR("PLDO_REG6", "vcca", RK806_ID_PLDO6, rk806_ops_ldo,
+			RK806_LDO_SEL_CNT, RK806_PLDO6_ON_VSEL,
+			RK806_POWER_EN4, rk806_ldo_voltage_ranges, 0),
+};
+
+static void rk806_regulator_dt_parse_pdata(struct rk806 *rk806,
+					   struct regmap *map,
+					   struct rk806_regulator_data *pdata)
+
+{
+	char dvs_ctrl_name[10][32] = {
+					"dvs_default",
+					"start_dvs1_ctrl",
+					"start_dvs2_ctrl",
+					"start_dvs3_ctrl",
+					"dvs_pin1_ctrl",
+					"dvs_pin2_ctrl",
+					"dvs_pin3_ctrl",
+					"start_and_pwrctrl1",
+					"start_and_pwrctrl2",
+					"start_and_pwrctrl3"};
+	char dvs_pin_name[3][30] = { "rk806,pmic-dvs-gpio1",
+				     "rk806,pmic-dvs-gpio2",
+				     "rk806,pmic-dvs-gpio3" };
+	struct device_node *np = rk806->dev->of_node;
+	struct device_node *dn;
+	int i, j;
+
+	pdata->support_dvs = 0;
+
+	for (i = 0; i < RK806_ID_END; i++) {
+		pdata->dvs_field[i] = rk806_dvs_fields[i];
+		pdata->dvs_ctrl_id[i] = start_dvs_id[i];
+		pdata->vsel_ctrl_id[i] = vsel_ctr_sel_id[i];
+	}
+
+	for (j = 1; j < RK806_DVS_END; j++) {
+		if (device_property_present(rk806->dev, dvs_ctrl_name[j])) {
+			REG_DBG("%s:\n", dvs_ctrl_name[j]);
+			for (i = 0;
+			     (dn = of_parse_phandle(np, dvs_ctrl_name[j], i));
+			     i++) {
+				REG_DBG("\t%s\n", dn->name);
+				pdata->support_dvs = 1;
+				pdata->dvs_dn[j][i] = dn;
+				pdata->dvs_count[j]++;
+
+				of_node_put(dn);
+				if (i >= RK806_ID_END)
+					break;
+			}
+		}
+	}
+	if (!pdata->support_dvs)
+		return;
+
+	for (i = 0; i < 3; i++) {
+		pdata->dvs_gpios[i] = devm_gpiod_get_optional(rk806->dev,
+							      dvs_pin_name[i],
+							      GPIOD_OUT_HIGH);
+		if (IS_ERR(pdata->dvs_gpios[i])) {
+			pdata->dvs_gpios[i] = NULL;
+			dev_info(rk806->dev, "Failed to get %s\n", dvs_pin_name[i]);
+		}
+	}
+}
+
+static int rk806_regulator_probe(struct platform_device *pdev)
+{
+	struct rk806 *rk806 = dev_get_drvdata(pdev->dev.parent);
+	struct rk806_regulator_data *pdata;
+	struct regulator_config config = { };
+	struct regulator_dev *rdev;
+	int i;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	rk806_regulator_dt_parse_pdata(rk806, rk806->regmap, pdata);
+
+	pdata->rk806 = rk806;
+	platform_set_drvdata(pdev, pdata);
+
+	config.dev = &pdev->dev;
+	config.driver_data = pdata;
+	config.dev->of_node = rk806->dev->of_node;
+	config.regmap = rk806->regmap;
+
+	for (i = 0; i < ARRAY_SIZE(rk806_regulators); i++) {
+		rdev = devm_regulator_register(&pdev->dev,
+					       &rk806_regulators[i],
+					       &config);
+		if (IS_ERR(rdev)) {
+			dev_err(rk806->dev, "failed to register %s regulator\n",
+				pdev->name);
+			return PTR_ERR(rdev);
+		}
+
+		rk806_regulator_sync_voltage(rdev);
+	}
+
+	pdata->regulator_init = 1;
+
+	return 0;
+}
+
+static int __maybe_unused rk806_suspend(struct device *dev)
+{
+	struct rk806 *rk806 = dev_get_drvdata(dev->parent);
+	int i;
+
+	rk806_field_write(rk806, PWRCTRL1_FUN, PWRCTRL_NULL_FUN);
+	rk806_field_write(rk806, PWRCTRL2_FUN, PWRCTRL_NULL_FUN);
+	rk806_field_write(rk806, PWRCTRL3_FUN, PWRCTRL_NULL_FUN);
+
+	for (i = RK806_ID_DCDC1; i < RK806_ID_END; i++)
+		rk806_field_write(rk806, BUCK1_VSEL_CTR_SEL + i, CTR_BY_NO_EFFECT);
+
+	rk806_field_write(rk806, PWRCTRL1_FUN, PWRCTRL_DVS_FUN);
+
+	for (i = RK806_ID_DCDC1; i < RK806_ID_END; i++)
+		rk806_field_write(rk806, BUCK1_VSEL_CTR_SEL + i, CTR_BY_PWRCTRL1);
+
+	return 0;
+}
+
+static int __maybe_unused rk806_resume(struct device *dev)
+{
+	struct rk806 *rk806 = dev_get_drvdata(dev->parent);
+	int i;
+
+	for (i = RK806_ID_DCDC1; i < RK806_ID_END; i++)
+		rk806_field_write(rk806, BUCK1_VSEL_CTR_SEL + i, CTR_BY_NO_EFFECT);
+
+	rk806_field_write(rk806, PWRCTRL1_FUN, PWRCTRL_NULL_FUN);
+
+	return 0;
+}
+SIMPLE_DEV_PM_OPS(rk806_pm_ops, rk806_suspend, rk806_resume);
+
+static void rk806_regulator_shutdown(struct platform_device *pdev)
+{
+	struct rk806 *rk806 = dev_get_drvdata(pdev->dev.parent);
+
+	if (system_state == SYSTEM_POWER_OFF)
+		if ((rk806->pins->p) && (rk806->pins->power_off))
+			pinctrl_select_state(rk806->pins->p, rk806->pins->power_off);
+
+	if (system_state == SYSTEM_RESTART)
+		if ((rk806->pins->p) && (rk806->pins->power_off))
+			pinctrl_select_state(rk806->pins->p, rk806->pins->reset);
+
+}
+
+static const struct platform_device_id rk806_regulator_id_table[] = {
+	{ "rk806-regulator", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(platform, rk806_regulator_id_table);
+
+static struct platform_driver rk806_regulator_driver = {
+	.driver = {
+		.name = "rk806-regulator",
+		.pm = &rk806_pm_ops,
+	},
+	.probe = rk806_regulator_probe,
+	.id_table = rk806_regulator_id_table,
+	.shutdown = rk806_regulator_shutdown,
+};
+module_platform_driver(rk806_regulator_driver);
+
+MODULE_AUTHOR("Xu Shengfei <xsf@rock-chips.com>");
+MODULE_DESCRIPTION("rk806 voltage regulator driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/rk860x-regulator.c b/drivers/regulator/rk860x-regulator.c
new file mode 100644
index 00000000000..4596761bdb4
--- /dev/null
+++ b/drivers/regulator/rk860x-regulator.c
@@ -0,0 +1,607 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/param.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+/* Voltage setting */
+
+#define RK860X_VSEL0_A		0x00
+#define RK860X_VSEL1_A		0x01
+#define RK860X_VSEL0_B		0x06
+#define RK860X_VSEL1_B		0x07
+#define RK860X_MAX_SET		0x08
+
+/* Control register */
+#define RK860X_CONTROL		0x02
+/* IC Type */
+#define RK860X_ID1		0x03
+/* IC mask version */
+#define RK860X_ID2		0x04
+/* Monitor register */
+#define RK860X_MONITOR		0x05
+
+/* VSEL bit definitions */
+#define VSEL_BUCK_EN		BIT(7)
+#define VSEL_MODE		BIT(6)
+#define VSEL_A_NSEL_MASK	0x3F
+#define VSEL_B_NSEL_MASK	0xff
+
+/* Chip ID */
+#define DIE_ID			0x0f
+#define DIE_REV			0x0f
+/* Control bit definitions */
+#define CTL_OUTPUT_DISCHG	BIT(7)
+#define CTL_SLEW_MASK		(0x7 << 4)
+#define CTL_SLEW_SHIFT		4
+#define CTL_RESET		BIT(2)
+
+#define RK860X_NVOLTAGES_64	64
+#define RK860X_NVOLTAGES_160	160
+
+/* IC Type */
+enum {
+	RK860X_CHIP_ID_00 = 0,
+	RK860X_CHIP_ID_01,
+	RK860X_CHIP_ID_02,
+	RK860X_CHIP_ID_03,
+};
+
+struct rk860x_platform_data {
+	struct regulator_init_data *regulator;
+	unsigned int slew_rate;
+	/* Sleep VSEL ID */
+	unsigned int sleep_vsel_id;
+	int limit_volt;
+	struct gpio_desc *vsel_gpio;
+};
+
+struct rk860x_device_info {
+	struct regmap *regmap;
+	struct device *dev;
+	struct regulator_desc desc;
+	struct regulator_dev *rdev;
+	struct regulator_init_data *regulator;
+	/* IC Type and Rev */
+	int chip_id;
+	/* Voltage setting register */
+	unsigned int vol_reg;
+	unsigned int sleep_reg;
+	unsigned int en_reg;
+	unsigned int sleep_en_reg;
+	unsigned int mode_reg;
+	unsigned int vol_mask;
+	unsigned int mode_mask;
+	unsigned int slew_reg;
+	unsigned int slew_mask;
+	unsigned int slew_shift;
+	/* Voltage range and step(linear) */
+	unsigned int vsel_min;
+	unsigned int vsel_step;
+	unsigned int n_voltages;
+	/* Voltage slew rate limiting */
+	unsigned int slew_rate;
+	struct gpio_desc *vsel_gpio;
+	unsigned int sleep_vsel_id;
+};
+
+static unsigned int rk860x_map_mode(unsigned int mode)
+{
+	return mode == REGULATOR_MODE_FAST ?
+		REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;
+}
+
+static int rk860x_get_voltage(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(di->regmap, RK860X_MAX_SET, &val);
+	if (ret < 0)
+		return ret;
+	ret = regulator_get_voltage_sel_regmap(rdev);
+	if (ret > val)
+		return val;
+
+	return ret;
+}
+
+static int rk860x_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+	int ret;
+
+	ret = regulator_map_voltage_linear(rdev, uV, uV);
+	if (ret < 0)
+		return ret;
+	ret = regmap_update_bits(di->regmap, di->sleep_reg,
+				 di->vol_mask, ret);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int rk860x_set_suspend_enable(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+
+	return regmap_update_bits(di->regmap, di->sleep_en_reg,
+				  VSEL_BUCK_EN, VSEL_BUCK_EN);
+}
+
+static int rk860x_set_suspend_disable(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+
+	return regmap_update_bits(di->regmap, di->sleep_en_reg,
+				  VSEL_BUCK_EN, 0);
+}
+
+static int rk860x_resume(struct regulator_dev *rdev)
+{
+	int ret;
+
+	if (!rdev->constraints->state_mem.changeable)
+		return 0;
+
+	ret = rk860x_set_suspend_enable(rdev);
+	if (ret)
+		return ret;
+
+	return regulator_suspend_enable(rdev, PM_SUSPEND_MEM);
+}
+
+static int rk860x_set_enable(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+
+	if (di->vsel_gpio) {
+		gpiod_set_raw_value(di->vsel_gpio, !di->sleep_vsel_id);
+		return 0;
+	}
+
+	return regmap_update_bits(di->regmap, di->en_reg,
+				  VSEL_BUCK_EN, VSEL_BUCK_EN);
+}
+
+static int rk860x_set_disable(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+
+	if (di->vsel_gpio) {
+		gpiod_set_raw_value(di->vsel_gpio, di->sleep_vsel_id);
+		return 0;
+	}
+
+	return regmap_update_bits(di->regmap, di->en_reg,
+				  VSEL_BUCK_EN, 0);
+}
+
+static int rk860x_is_enabled(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+	unsigned int val;
+	int ret = 0;
+
+	if (di->vsel_gpio) {
+		if (di->sleep_vsel_id)
+			return !gpiod_get_raw_value(di->vsel_gpio);
+		else
+			return gpiod_get_raw_value(di->vsel_gpio);
+	}
+
+	ret = regmap_read(di->regmap, di->en_reg, &val);
+	if (ret < 0)
+		return ret;
+	if (val & VSEL_BUCK_EN)
+		return 1;
+	else
+		return 0;
+}
+
+static int rk860x_set_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		regmap_update_bits(di->regmap, di->mode_reg,
+				   di->mode_mask, di->mode_mask);
+		break;
+	case REGULATOR_MODE_NORMAL:
+		regmap_update_bits(di->regmap, di->mode_reg, di->mode_mask, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static unsigned int rk860x_get_mode(struct regulator_dev *rdev)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+	unsigned int val;
+	int ret = 0;
+
+	ret = regmap_read(di->regmap, di->mode_reg, &val);
+	if (ret < 0)
+		return ret;
+	if (val & di->mode_mask)
+		return REGULATOR_MODE_FAST;
+	else
+		return REGULATOR_MODE_NORMAL;
+}
+
+static const int slew_rates[] = {
+	64000,
+	32000,
+	16000,
+	 8000,
+	 4000,
+	 2000,
+	 1000,
+	  500,
+};
+
+static int rk860x_set_ramp(struct regulator_dev *rdev, int ramp)
+{
+	struct rk860x_device_info *di = rdev_get_drvdata(rdev);
+	int regval = -1, i;
+	const int *slew_rate_t;
+	int slew_rate_n;
+
+	slew_rate_t = slew_rates;
+	slew_rate_n = ARRAY_SIZE(slew_rates);
+
+	for (i = 0; i < slew_rate_n; i++) {
+		if (ramp <= slew_rate_t[i])
+			regval = i;
+		else
+			break;
+	}
+
+	if (regval < 0) {
+		dev_err(di->dev, "unsupported ramp value %d\n", ramp);
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(di->regmap, di->slew_reg,
+				  di->slew_mask, regval << di->slew_shift);
+}
+
+static const struct regulator_ops rk860x_regulator_ops = {
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = rk860x_get_voltage,
+	.set_voltage_time_sel = regulator_set_voltage_time_sel,
+	.map_voltage = regulator_map_voltage_linear,
+	.list_voltage = regulator_list_voltage_linear,
+	.set_suspend_voltage = rk860x_set_suspend_voltage,
+	.enable = rk860x_set_enable,
+	.disable = rk860x_set_disable,
+	.is_enabled = rk860x_is_enabled,
+	.set_mode = rk860x_set_mode,
+	.get_mode = rk860x_get_mode,
+	.set_ramp_delay = rk860x_set_ramp,
+	.set_suspend_enable = rk860x_set_suspend_enable,
+	.set_suspend_disable = rk860x_set_suspend_disable,
+	.resume = rk860x_resume,
+};
+
+/* For 00,01 options:
+ * VOUT = 0.7125V + NSELx * 12.5mV, from 0.7125 to 1.5V.
+ * For 02,03 options:
+ * VOUT = 0.5V + NSELx * 6.25mV, from 0.5 to 1.5V.
+ */
+static int rk860x_device_setup(struct rk860x_device_info *di,
+			       struct rk860x_platform_data *pdata)
+{
+	int ret = 0;
+	u32 val = 0;
+
+	switch (di->chip_id) {
+	case RK860X_CHIP_ID_00:
+	case RK860X_CHIP_ID_01:
+		di->vsel_min = 712500;
+		di->vsel_step = 12500;
+		di->n_voltages = RK860X_NVOLTAGES_64;
+		di->vol_mask = VSEL_A_NSEL_MASK;
+		if (di->sleep_vsel_id) {
+			di->sleep_reg = RK860X_VSEL1_A;
+			di->vol_reg = RK860X_VSEL0_A;
+			di->mode_reg = RK860X_VSEL0_A;
+			di->en_reg = RK860X_VSEL0_A;
+			di->sleep_en_reg = RK860X_VSEL1_A;
+		} else {
+			di->sleep_reg = RK860X_VSEL0_A;
+			di->vol_reg = RK860X_VSEL1_A;
+			di->mode_reg = RK860X_VSEL1_A;
+			di->en_reg = RK860X_VSEL1_A;
+			di->sleep_en_reg = RK860X_VSEL0_A;
+		}
+		break;
+	case RK860X_CHIP_ID_02:
+	case RK860X_CHIP_ID_03:
+		di->vsel_min = 500000;
+		di->vsel_step = 6250;
+		di->n_voltages = RK860X_NVOLTAGES_160;
+		di->vol_mask = VSEL_B_NSEL_MASK;
+		if (di->sleep_vsel_id) {
+			di->sleep_reg = RK860X_VSEL1_B;
+			di->vol_reg = RK860X_VSEL0_B;
+			di->mode_reg = RK860X_VSEL0_A;
+			di->en_reg = RK860X_VSEL0_A;
+			di->sleep_en_reg = RK860X_VSEL1_A;
+		} else {
+			di->sleep_reg = RK860X_VSEL0_B;
+			di->vol_reg = RK860X_VSEL1_B;
+			di->mode_reg = RK860X_VSEL1_A;
+			di->en_reg = RK860X_VSEL1_A;
+			di->sleep_en_reg = RK860X_VSEL0_A;
+		}
+		break;
+	default:
+		dev_err(di->dev, "Chip ID %d not supported!\n", di->chip_id);
+		return -EINVAL;
+	}
+
+	di->mode_mask = VSEL_MODE;
+	di->slew_reg = RK860X_CONTROL;
+	di->slew_mask = CTL_SLEW_MASK;
+	di->slew_shift = CTL_SLEW_SHIFT;
+
+	if (pdata->limit_volt) {
+		if (pdata->limit_volt < di->vsel_min ||
+		    pdata->limit_volt > 1500000)
+			pdata->limit_volt = 1500000;
+		val = (pdata->limit_volt - di->vsel_min) / di->vsel_step;
+		ret = regmap_write(di->regmap, RK860X_MAX_SET, val);
+		if (ret < 0) {
+			dev_err(di->dev, "Failed to set limit voltage!\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int rk860x_regulator_register(struct rk860x_device_info *di,
+				     struct regulator_config *config)
+{
+	struct regulator_desc *rdesc = &di->desc;
+
+	rdesc->name = "rk860x-reg";
+	rdesc->supply_name = "vin";
+	rdesc->ops = &rk860x_regulator_ops;
+	rdesc->type = REGULATOR_VOLTAGE;
+	rdesc->n_voltages = di->n_voltages;
+	rdesc->enable_reg = di->en_reg;
+	rdesc->enable_mask = VSEL_BUCK_EN;
+	rdesc->min_uV = di->vsel_min;
+	rdesc->uV_step = di->vsel_step;
+	rdesc->vsel_reg = di->vol_reg;
+	rdesc->vsel_mask = di->vol_mask;
+	rdesc->owner = THIS_MODULE;
+	rdesc->enable_time = 400;
+
+	di->rdev = devm_regulator_register(di->dev, &di->desc, config);
+	return PTR_ERR_OR_ZERO(di->rdev);
+}
+
+static const struct regmap_config rk860x_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static struct rk860x_platform_data *
+rk860x_parse_dt(struct device *dev, struct device_node *np,
+		const struct regulator_desc *desc)
+{
+	struct rk860x_platform_data *pdata;
+	int ret, flag, limit_volt;
+	u32 tmp;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	pdata->regulator = of_get_regulator_init_data(dev, np, desc);
+	pdata->regulator->constraints.initial_state = PM_SUSPEND_MEM;
+
+	if (!(of_property_read_u32(np, "limit-microvolt", &limit_volt)))
+		pdata->limit_volt = limit_volt;
+
+	ret = of_property_read_u32(np, "rockchip,suspend-voltage-selector",
+				   &tmp);
+	if (!ret)
+		pdata->sleep_vsel_id = tmp;
+
+	if (pdata->sleep_vsel_id)
+		flag = GPIOD_OUT_LOW;
+	else
+		flag = GPIOD_OUT_HIGH;
+
+	pdata->vsel_gpio = devm_gpiod_get_index_optional(dev, "vsel", 0, flag);
+	if (IS_ERR(pdata->vsel_gpio)) {
+		ret = PTR_ERR(pdata->vsel_gpio);
+		dev_err(dev, "failed to get vesl gpio (%d)\n", ret);
+		pdata->vsel_gpio = NULL;
+	}
+
+	return pdata;
+}
+
+static const struct of_device_id rk860x_dt_ids[] = {
+	{
+		.compatible = "rockchip,rk8600",
+		.data = (void *)RK860X_CHIP_ID_00
+	},
+	{
+		.compatible = "rockchip,rk8601",
+		.data = (void *)RK860X_CHIP_ID_01
+	},
+	{
+		.compatible = "rockchip,rk8602",
+		.data = (void *)RK860X_CHIP_ID_02
+	},
+	{
+		.compatible = "rockchip,rk8603",
+		.data = (void *)RK860X_CHIP_ID_03
+	},
+
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rk860x_dt_ids);
+
+static int rk860x_regulator_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct device_node *np = client->dev.of_node;
+	struct rk860x_device_info *di;
+	struct rk860x_platform_data *pdata;
+	struct regulator_config config = { };
+	unsigned int val;
+	int ret;
+
+	di = devm_kzalloc(&client->dev, sizeof(*di), GFP_KERNEL);
+	if (!di)
+		return -ENOMEM;
+
+	di->desc.of_map_mode = rk860x_map_mode;
+
+	pdata = dev_get_platdata(&client->dev);
+	if (!pdata)
+		pdata = rk860x_parse_dt(&client->dev, np, &di->desc);
+
+	if (!pdata || !pdata->regulator) {
+		dev_err(&client->dev, "Platform data not found!\n");
+		return -ENODEV;
+	}
+
+	di->vsel_gpio = pdata->vsel_gpio;
+	di->sleep_vsel_id = pdata->sleep_vsel_id;
+
+	di->regulator = pdata->regulator;
+	if (client->dev.of_node) {
+		di->chip_id =
+			(unsigned long)of_device_get_match_data(&client->dev);
+	} else {
+		/* if no ramp constraint set, get the pdata ramp_delay */
+		if (!di->regulator->constraints.ramp_delay) {
+			int slew_idx = (pdata->slew_rate & 0x7)
+						? pdata->slew_rate : 0;
+
+			di->regulator->constraints.ramp_delay =
+				slew_rates[slew_idx];
+		}
+		di->chip_id = id->driver_data;
+	}
+
+	di->regmap = devm_regmap_init_i2c(client, &rk860x_regmap_config);
+	if (IS_ERR(di->regmap)) {
+		dev_err(&client->dev, "Failed to allocate regmap!\n");
+		return PTR_ERR(di->regmap);
+	}
+	di->dev = &client->dev;
+	i2c_set_clientdata(client, di);
+	/* Get chip ID */
+	ret = regmap_read(di->regmap, RK860X_ID1, &val);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to get chip ID!\n");
+		return ret;
+	}
+
+	switch (di->chip_id) {
+	case RK860X_CHIP_ID_00:
+	case RK860X_CHIP_ID_01:
+		if ((val & DIE_ID) != 0x8) {
+			dev_err(&client->dev, "Failed to match chip ID!\n");
+			return -EINVAL;
+		}
+		break;
+	case RK860X_CHIP_ID_02:
+	case RK860X_CHIP_ID_03:
+		if ((val & DIE_ID) != 0xa) {
+			dev_err(&client->dev, "Failed to match chip ID!\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Device init */
+	ret = rk860x_device_setup(di, pdata);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to setup device!\n");
+		return ret;
+	}
+	/* Register regulator */
+	config.dev = di->dev;
+	config.init_data = di->regulator;
+	config.regmap = di->regmap;
+	config.driver_data = di;
+	config.of_node = np;
+
+	ret = rk860x_regulator_register(di, &config);
+	if (ret < 0)
+		dev_err(&client->dev, "Failed to register regulator!\n");
+
+	return ret;
+}
+
+static void rk860x_regulator_shutdown(struct i2c_client *client)
+{
+	struct rk860x_device_info *di;
+	int ret;
+
+	di = i2c_get_clientdata(client);
+
+	dev_info(di->dev, "rk860..... reset\n");
+
+	ret = regmap_update_bits(di->regmap, di->slew_reg,
+				 CTL_RESET, CTL_RESET);
+
+	if (ret < 0)
+		dev_err(di->dev, "force rk860x_reset error! ret=%d\n", ret);
+	else
+		dev_info(di->dev, "force rk860x_reset ok!\n");
+}
+
+static const struct i2c_device_id rk860x_id[] = {
+	{ .name = "rk8600", .driver_data = RK860X_CHIP_ID_00 },
+	{ .name = "rk8601", .driver_data = RK860X_CHIP_ID_01 },
+	{ .name = "rk8602", .driver_data = RK860X_CHIP_ID_02 },
+	{ .name = "rk8603", .driver_data = RK860X_CHIP_ID_03 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, rk860x_id);
+
+static struct i2c_driver rk860x_regulator_driver = {
+	.driver = {
+		.name = "rk860-regulator",
+		.of_match_table = of_match_ptr(rk860x_dt_ids),
+	},
+	.probe = rk860x_regulator_probe,
+	.shutdown = rk860x_regulator_shutdown,
+	.id_table = rk860x_id,
+};
+
+module_i2c_driver(rk860x_regulator_driver);
+
+MODULE_AUTHOR("Elaine Zhang <zhangqing@rock-chips.com>");
+MODULE_DESCRIPTION("rk860x regulator driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/rockchip/Kconfig b/drivers/soc/rockchip/Kconfig
index aff2f7e9523..a3dfacaa8e6 100644
--- a/drivers/soc/rockchip/Kconfig
+++ b/drivers/soc/rockchip/Kconfig
@@ -22,6 +22,12 @@ config ROCKCHIP_IODOMAIN
 	  necessary for the io domain setting of the SoC to match the
 	  voltage supplied by the regulators.
 
+config ROCKCHIP_OPP
+	tristate "Rockchip OPP select support"
+	depends on PM_DEVFREQ
+	help
+	  Say y here to enable rockchip OPP support.
+
 config ROCKCHIP_PM_DOMAINS
 	bool "Rockchip generic power domain"
 	depends on PM
diff --git a/drivers/soc/rockchip/Makefile b/drivers/soc/rockchip/Makefile
index 05f31a4e743..9e21761c01c 100644
--- a/drivers/soc/rockchip/Makefile
+++ b/drivers/soc/rockchip/Makefile
@@ -4,5 +4,6 @@
 #
 obj-$(CONFIG_ROCKCHIP_GRF) += grf.o
 obj-$(CONFIG_ROCKCHIP_IODOMAIN) += io-domain.o
+obj-$(CONFIG_ROCKCHIP_OPP) += rockchip_opp_select.o
 obj-$(CONFIG_ROCKCHIP_PM_DOMAINS) += pm_domains.o
 obj-$(CONFIG_ROCKCHIP_DTPM) += dtpm.o
diff --git a/drivers/soc/rockchip/pm_domains.c b/drivers/soc/rockchip/pm_domains.c
index 84bc022f9e5..a6cb91f6257 100644
--- a/drivers/soc/rockchip/pm_domains.c
+++ b/drivers/soc/rockchip/pm_domains.c
@@ -43,8 +43,10 @@ struct rockchip_domain_info {
 	bool active_wakeup;
 	int pwr_w_mask;
 	int req_w_mask;
+	int mem_status_mask;
 	int repair_status_mask;
 	u32 pwr_offset;
+	u32 mem_offset;
 	u32 req_offset;
 };
 
@@ -54,6 +56,9 @@ struct rockchip_pmu_info {
 	u32 req_offset;
 	u32 idle_offset;
 	u32 ack_offset;
+	u32 mem_pwr_offset;
+	u32 chain_status_offset;
+	u32 mem_status_offset;
 	u32 repair_status_offset;
 
 	u32 core_pwrcnt_offset;
@@ -119,7 +124,7 @@ struct rockchip_pmu {
 	.active_wakeup = wakeup,			\
 }
 
-#define DOMAIN_M_O_R(_name, p_offset, pwr, status, r_status, r_offset, req, idle, ack, wakeup)	\
+#define DOMAIN_M_O_R(_name, p_offset, pwr, status, m_offset, m_status, r_status, r_offset, req, idle, ack, wakeup)	\
 {							\
 	.name = _name,					\
 	.pwr_offset = p_offset,				\
@@ -269,8 +274,8 @@ void rockchip_pmu_unblock(void)
 }
 EXPORT_SYMBOL_GPL(rockchip_pmu_unblock);
 
-#define DOMAIN_RK3588(name, p_offset, pwr, status, r_status, r_offset, req, idle, wakeup)	\
-	DOMAIN_M_O_R(name, p_offset, pwr, status, r_status, r_offset, req, idle, idle, wakeup)
+#define DOMAIN_RK3588(name, p_offset, pwr, status, m_offset, m_status, r_status, r_offset, req, idle, wakeup)	\
+	DOMAIN_M_O_R(name, p_offset, pwr, status, m_offset, m_status, r_status, r_offset, req, idle, idle, wakeup)
 
 static bool rockchip_pmu_domain_is_idle(struct rockchip_pm_domain *pd)
 {
@@ -408,16 +413,91 @@ static bool rockchip_pmu_domain_is_on(struct rockchip_pm_domain *pd)
 	return !(val & pd->info->status_mask);
 }
 
+static bool rockchip_pmu_domain_is_mem_on(struct rockchip_pm_domain *pd)
+{
+	struct rockchip_pmu *pmu = pd->pmu;
+	unsigned int val;
+
+	regmap_read(pmu->regmap,
+		    pmu->info->mem_status_offset + pd->info->mem_offset, &val);
+
+	/* 1'b0: power on, 1'b1: power off */
+	return !(val & pd->info->mem_status_mask);
+}
+
+static bool rockchip_pmu_domain_is_chain_on(struct rockchip_pm_domain *pd)
+{
+	struct rockchip_pmu *pmu = pd->pmu;
+	unsigned int val;
+
+	regmap_read(pmu->regmap,
+		    pmu->info->chain_status_offset + pd->info->mem_offset, &val);
+
+	/* 1'b1: power on, 1'b0: power off */
+	return val & pd->info->mem_status_mask;
+}
+
+static int rockchip_pmu_domain_mem_reset(struct rockchip_pm_domain *pd)
+{
+	struct rockchip_pmu *pmu = pd->pmu;
+	struct generic_pm_domain *genpd = &pd->genpd;
+	bool is_on;
+	int ret = 0;
+
+	ret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_chain_on, pd, is_on,
+					is_on == true, 0, 10000);
+	if (ret) {
+		dev_err(pmu->dev,
+			"failed to get chain status '%s', target_on=1, val=%d\n",
+			genpd->name, is_on);
+		goto error;
+	}
+
+	udelay(20);
+
+	regmap_write(pmu->regmap, pmu->info->mem_pwr_offset + pd->info->pwr_offset,
+		     (pd->info->pwr_mask | pd->info->pwr_w_mask));
+	dsb(sy);
+
+	ret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_mem_on, pd, is_on,
+					is_on == false, 0, 10000);
+	if (ret) {
+		dev_err(pmu->dev,
+			"failed to get mem status '%s', target_on=0, val=%d\n",
+			genpd->name, is_on);
+		goto error;
+	}
+
+	regmap_write(pmu->regmap, pmu->info->mem_pwr_offset + pd->info->pwr_offset,
+		     pd->info->pwr_w_mask);
+	dsb(sy);
+
+	ret = readx_poll_timeout_atomic(rockchip_pmu_domain_is_mem_on, pd, is_on,
+					is_on == true, 0, 10000);
+	if (ret) {
+		dev_err(pmu->dev,
+			"failed to get mem status '%s', target_on=1, val=%d\n",
+			genpd->name, is_on);
+	}
+
+error:
+	return ret;
+}
+
 static void rockchip_do_pmu_set_power_domain(struct rockchip_pm_domain *pd,
 					     bool on)
 {
 	struct rockchip_pmu *pmu = pd->pmu;
 	struct generic_pm_domain *genpd = &pd->genpd;
 	u32 pd_pwr_offset = pd->info->pwr_offset;
-	bool is_on;
+	bool is_on, is_mem_on = false;
 
 	if (pd->info->pwr_mask == 0)
 		return;
+
+	if (on && pd->info->mem_status_mask)
+		is_mem_on = rockchip_pmu_domain_is_mem_on(pd);
+
 	else if (pd->info->pwr_w_mask)
 		regmap_write(pmu->regmap, pmu->info->pwr_offset + pd_pwr_offset,
 			     on ? pd->info->pwr_w_mask :
@@ -428,6 +508,9 @@ static void rockchip_do_pmu_set_power_domain(struct rockchip_pm_domain *pd,
 
 	wmb();
 
+	if (is_mem_on && rockchip_pmu_domain_mem_reset(pd))
+		return;
+
 	if (readx_poll_timeout_atomic(rockchip_pmu_domain_is_on, pd, is_on,
 				      is_on == on, 0, 10000)) {
 		dev_err(pmu->dev,
@@ -645,7 +728,9 @@ static int rockchip_pm_add_one_domain(struct rockchip_pmu *pmu,
 	pd->genpd.flags = GENPD_FLAG_PM_CLK;
 	if (pd_info->active_wakeup)
 		pd->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
-	pm_genpd_init(&pd->genpd, NULL, !rockchip_pmu_domain_is_on(pd));
+	pm_genpd_init(&pd->genpd, NULL,
+		      !rockchip_pmu_domain_is_on(pd) ||
+		      (pd->info->mem_status_mask && !rockchip_pmu_domain_is_mem_on(pd)));
 
 	pmu->genpd_data.domains[id] = &pd->genpd;
 	return 0;
@@ -1024,35 +1109,35 @@ static const struct rockchip_domain_info rk3568_pm_domains[] = {
 };
 
 static const struct rockchip_domain_info rk3588_pm_domains[] = {
-	[RK3588_PD_GPU]		= DOMAIN_RK3588("gpu",     0x0, BIT(0),  0,       BIT(1),  0x0, BIT(0),  BIT(0),  false),
-	[RK3588_PD_NPU]		= DOMAIN_RK3588("npu",     0x0, BIT(1),  BIT(1),  0,       0x0, 0,       0,       false),
-	[RK3588_PD_VCODEC]	= DOMAIN_RK3588("vcodec",  0x0, BIT(2),  BIT(2),  0,       0x0, 0,       0,       false),
-	[RK3588_PD_NPUTOP]	= DOMAIN_RK3588("nputop",  0x0, BIT(3),  0,       BIT(2),  0x0, BIT(1),  BIT(1),  false),
-	[RK3588_PD_NPU1]	= DOMAIN_RK3588("npu1",    0x0, BIT(4),  0,       BIT(3),  0x0, BIT(2),  BIT(2),  false),
-	[RK3588_PD_NPU2]	= DOMAIN_RK3588("npu2",    0x0, BIT(5),  0,       BIT(4),  0x0, BIT(3),  BIT(3),  false),
-	[RK3588_PD_VENC0]	= DOMAIN_RK3588("venc0",   0x0, BIT(6),  0,       BIT(5),  0x0, BIT(4),  BIT(4),  false),
-	[RK3588_PD_VENC1]	= DOMAIN_RK3588("venc1",   0x0, BIT(7),  0,       BIT(6),  0x0, BIT(5),  BIT(5),  false),
-	[RK3588_PD_RKVDEC0]	= DOMAIN_RK3588("rkvdec0", 0x0, BIT(8),  0,       BIT(7),  0x0, BIT(6),  BIT(6),  false),
-	[RK3588_PD_RKVDEC1]	= DOMAIN_RK3588("rkvdec1", 0x0, BIT(9),  0,       BIT(8),  0x0, BIT(7),  BIT(7),  false),
-	[RK3588_PD_VDPU]	= DOMAIN_RK3588("vdpu",    0x0, BIT(10), 0,       BIT(9),  0x0, BIT(8),  BIT(8),  false),
-	[RK3588_PD_RGA30]	= DOMAIN_RK3588("rga30",   0x0, BIT(11), 0,       BIT(10), 0x0, 0,       0,       false),
-	[RK3588_PD_AV1]		= DOMAIN_RK3588("av1",     0x0, BIT(12), 0,       BIT(11), 0x0, BIT(9),  BIT(9),  false),
-	[RK3588_PD_VI]		= DOMAIN_RK3588("vi",      0x0, BIT(13), 0,       BIT(12), 0x0, BIT(10), BIT(10), false),
-	[RK3588_PD_FEC]		= DOMAIN_RK3588("fec",     0x0, BIT(14), 0,       BIT(13), 0x0, 0,       0,       false),
-	[RK3588_PD_ISP1]	= DOMAIN_RK3588("isp1",    0x0, BIT(15), 0,       BIT(14), 0x0, BIT(11), BIT(11), false),
-	[RK3588_PD_RGA31]	= DOMAIN_RK3588("rga31",   0x4, BIT(0),  0,       BIT(15), 0x0, BIT(12), BIT(12), false),
-	[RK3588_PD_VOP]		= DOMAIN_RK3588("vop",     0x4, BIT(1),  0,       BIT(16), 0x0, BIT(13) | BIT(14), BIT(13) | BIT(14), false),
-	[RK3588_PD_VO0]		= DOMAIN_RK3588("vo0",     0x4, BIT(2),  0,       BIT(17), 0x0, BIT(15), BIT(15), false),
-	[RK3588_PD_VO1]		= DOMAIN_RK3588("vo1",     0x4, BIT(3),  0,       BIT(18), 0x4, BIT(0),  BIT(16), false),
-	[RK3588_PD_AUDIO]	= DOMAIN_RK3588("audio",   0x4, BIT(4),  0,       BIT(19), 0x4, BIT(1),  BIT(17), false),
-	[RK3588_PD_PHP]		= DOMAIN_RK3588("php",     0x4, BIT(5),  0,       BIT(20), 0x4, BIT(5),  BIT(21), false),
-	[RK3588_PD_GMAC]	= DOMAIN_RK3588("gmac",    0x4, BIT(6),  0,       BIT(21), 0x0, 0,       0,       false),
-	[RK3588_PD_PCIE]	= DOMAIN_RK3588("pcie",    0x4, BIT(7),  0,       BIT(22), 0x0, 0,       0,       true),
-	[RK3588_PD_NVM]		= DOMAIN_RK3588("nvm",     0x4, BIT(8),  BIT(24), 0,       0x4, BIT(2),  BIT(18), false),
-	[RK3588_PD_NVM0]	= DOMAIN_RK3588("nvm0",    0x4, BIT(9),  0,       BIT(23), 0x0, 0,       0,       false),
-	[RK3588_PD_SDIO]	= DOMAIN_RK3588("sdio",    0x4, BIT(10), 0,       BIT(24), 0x4, BIT(3),  BIT(19), false),
-	[RK3588_PD_USB]		= DOMAIN_RK3588("usb",     0x4, BIT(11), 0,       BIT(25), 0x4, BIT(4),  BIT(20), true),
-	[RK3588_PD_SDMMC]	= DOMAIN_RK3588("sdmmc",   0x4, BIT(13), 0,       BIT(26), 0x0, 0,       0,       false),
+	[RK3588_PD_GPU]		= DOMAIN_RK3588("gpu",     0x0, BIT(0),  0,       0x0, 0,       BIT(1),  0x0, BIT(0),  BIT(0),  false),
+	[RK3588_PD_NPU]		= DOMAIN_RK3588("npu",     0x0, BIT(1),  BIT(1),  0x0, 0,       0,       0x0, 0,       0,       false),
+	[RK3588_PD_VCODEC]	= DOMAIN_RK3588("vcodec",  0x0, BIT(2),  BIT(2),  0x0, 0,       0,       0x0, 0,       0,       false),
+	[RK3588_PD_NPUTOP]	= DOMAIN_RK3588("nputop",  0x0, BIT(3),  0,       0x0, BIT(11), BIT(2),  0x0, BIT(1),  BIT(1),  false),
+	[RK3588_PD_NPU1]	= DOMAIN_RK3588("npu1",    0x0, BIT(4),  0,       0x0, BIT(12), BIT(3),  0x0, BIT(2),  BIT(2),  false),
+	[RK3588_PD_NPU2]	= DOMAIN_RK3588("npu2",    0x0, BIT(5),  0,       0x0, BIT(13), BIT(4),  0x0, BIT(3),  BIT(3),  false),
+	[RK3588_PD_VENC0]	= DOMAIN_RK3588("venc0",   0x0, BIT(6),  0,       0x0, BIT(14), BIT(5),  0x0, BIT(4),  BIT(4),  false),
+	[RK3588_PD_VENC1]	= DOMAIN_RK3588("venc1",   0x0, BIT(7),  0,       0x0, BIT(15), BIT(6),  0x0, BIT(5),  BIT(5),  false),
+	[RK3588_PD_RKVDEC0]	= DOMAIN_RK3588("rkvdec0", 0x0, BIT(8),  0,       0x0, BIT(16), BIT(7),  0x0, BIT(6),  BIT(6),  false),
+	[RK3588_PD_RKVDEC1]	= DOMAIN_RK3588("rkvdec1", 0x0, BIT(9),  0,       0x0, BIT(17), BIT(8),  0x0, BIT(7),  BIT(7),  false),
+	[RK3588_PD_VDPU]	= DOMAIN_RK3588("vdpu",    0x0, BIT(10), 0,       0x0, BIT(18), BIT(9),  0x0, BIT(8),  BIT(8),  false),
+	[RK3588_PD_RGA30]	= DOMAIN_RK3588("rga30",   0x0, BIT(11), 0,       0x0, BIT(19), BIT(10), 0x0, 0,       0,       false),
+	[RK3588_PD_AV1]		= DOMAIN_RK3588("av1",     0x0, BIT(12), 0,       0x0, BIT(20), BIT(11), 0x0, BIT(9),  BIT(9),  false),
+	[RK3588_PD_VI]		= DOMAIN_RK3588("vi",      0x0, BIT(13), 0,       0x0, BIT(21), BIT(12), 0x0, BIT(10), BIT(10), false),
+	[RK3588_PD_FEC]		= DOMAIN_RK3588("fec",     0x0, BIT(14), 0,       0x0, BIT(22), BIT(13), 0x0, 0,       0,       false),
+	[RK3588_PD_ISP1]	= DOMAIN_RK3588("isp1",    0x0, BIT(15), 0,       0x0, BIT(23), BIT(14), 0x0, BIT(11), BIT(11), false),
+	[RK3588_PD_RGA31]	= DOMAIN_RK3588("rga31",   0x4, BIT(0),  0,       0x0, BIT(24), BIT(15), 0x0, BIT(12), BIT(12), false),
+	[RK3588_PD_VOP]		= DOMAIN_RK3588("vop",     0x4, BIT(1),  0,       0x0, BIT(25), BIT(16), 0x0, BIT(13) | BIT(14), BIT(13) | BIT(14), false),
+	[RK3588_PD_VO0]		= DOMAIN_RK3588("vo0",     0x4, BIT(2),  0,       0x0, BIT(26), BIT(17), 0x0, BIT(15), BIT(15), false),
+	[RK3588_PD_VO1]		= DOMAIN_RK3588("vo1",     0x4, BIT(3),  0,       0x0, BIT(27), BIT(18), 0x4, BIT(0),  BIT(16), false),
+	[RK3588_PD_AUDIO]	= DOMAIN_RK3588("audio",   0x4, BIT(4),  0,       0x0, BIT(28), BIT(19), 0x4, BIT(1),  BIT(17), false),
+	[RK3588_PD_PHP]		= DOMAIN_RK3588("php",     0x4, BIT(5),  0,       0x0, BIT(29), BIT(20), 0x4, BIT(5),  BIT(21), false),
+	[RK3588_PD_GMAC]	= DOMAIN_RK3588("gmac",    0x4, BIT(6),  0,       0x0, BIT(30), BIT(21), 0x0, 0,       0,       false),
+	[RK3588_PD_PCIE]	= DOMAIN_RK3588("pcie",    0x4, BIT(7),  0,       0x0, BIT(31), BIT(22), 0x0, 0,       0,       true),
+	[RK3588_PD_NVM]		= DOMAIN_RK3588("nvm",     0x4, BIT(8),  BIT(24), 0x4, 0,       0,       0x4, BIT(2),  BIT(18), false),
+	[RK3588_PD_NVM0]	= DOMAIN_RK3588("nvm0",    0x4, BIT(9),  0,       0x4, BIT(1),  BIT(23), 0x0, 0,       0,       false),
+	[RK3588_PD_SDIO]	= DOMAIN_RK3588("sdio",    0x4, BIT(10), 0,       0x4, BIT(2),  BIT(24), 0x4, BIT(3),  BIT(19), false),
+	[RK3588_PD_USB]		= DOMAIN_RK3588("usb",     0x4, BIT(11), 0,       0x4, BIT(3),  BIT(25), 0x4, BIT(4),  BIT(20), true),
+	[RK3588_PD_SDMMC]	= DOMAIN_RK3588("sdmmc",   0x4, BIT(13), 0,       0x4, BIT(5),  BIT(26), 0x0, 0,       0,       false),
 };
 
 static const struct rockchip_pmu_info px30_pmu = {
@@ -1207,6 +1292,9 @@ static const struct rockchip_pmu_info rk3588_pmu = {
 	.req_offset = 0x10c,
 	.idle_offset = 0x120,
 	.ack_offset = 0x118,
+	.mem_pwr_offset = 0x1a0,
+	.chain_status_offset = 0x1f0,
+	.mem_status_offset = 0x1f8,
 	.repair_status_offset = 0x290,
 
 	.num_domains = ARRAY_SIZE(rk3588_pm_domains),
diff --git a/drivers/soc/rockchip/rockchip_opp_select.c b/drivers/soc/rockchip/rockchip_opp_select.c
new file mode 100644
index 00000000000..9ef0dc7c589
--- /dev/null
+++ b/drivers/soc/rockchip/rockchip_opp_select.c
@@ -0,0 +1,1595 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+//#define DEBUG
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/devfreq.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/soc/rockchip/pvtm.h>
+#include <linux/thermal.h>
+#include <linux/pm_opp.h>
+#include <linux/version.h>
+#include <soc/rockchip/rockchip_opp_select.h>
+
+#include "../../clk/rockchip/clk.h"
+#include "../../opp/opp.h"
+#include "../../devfreq/governor.h"
+
+#define MAX_PROP_NAME_LEN	6
+#define SEL_TABLE_END		~1
+#define AVS_DELETE_OPP		0
+#define AVS_SCALING_RATE	1
+
+#define LEAKAGE_V1		1
+#define LEAKAGE_V2		2
+#define LEAKAGE_V3		3
+
+#define to_thermal_opp_info(nb) container_of(nb, struct thermal_opp_info, \
+					     thermal_nb)
+
+struct sel_table {
+	int min;
+	int max;
+	int sel;
+};
+
+struct bin_sel_table {
+	int bin;
+	int sel;
+};
+
+struct pvtm_config {
+	unsigned int freq;
+	unsigned int volt;
+	unsigned int ch[2];
+	unsigned int sample_time;
+	unsigned int num;
+	unsigned int err;
+	unsigned int ref_temp;
+	unsigned int offset;
+	int temp_prop[2];
+	const char *tz_name;
+	struct thermal_zone_device *tz;
+	struct regmap *grf;
+};
+
+struct lkg_conversion_table {
+	int temp;
+	int conv;
+};
+
+#define PVTM_CH_MAX	8
+#define PVTM_SUB_CH_MAX	8
+
+#define FRAC_BITS 10
+#define int_to_frac(x) ((x) << FRAC_BITS)
+#define frac_to_int(x) ((x) >> FRAC_BITS)
+
+static int pvtm_value[PVTM_CH_MAX][PVTM_SUB_CH_MAX];
+static int lkg_version;
+
+/*
+ * temp = temp * 10
+ * conv = exp(-ln(1.2) / 5 * (temp - 23)) * 100
+ */
+static const struct lkg_conversion_table conv_table[] = {
+	{ 200, 111 },
+	{ 205, 109 },
+	{ 210, 107 },
+	{ 215, 105 },
+	{ 220, 103 },
+	{ 225, 101 },
+	{ 230, 100 },
+	{ 235, 98 },
+	{ 240, 96 },
+	{ 245, 94 },
+	{ 250, 92 },
+	{ 255, 91 },
+	{ 260, 89 },
+	{ 265, 88 },
+	{ 270, 86 },
+	{ 275, 84 },
+	{ 280, 83 },
+	{ 285, 81 },
+	{ 290, 80 },
+	{ 295, 78 },
+	{ 300, 77 },
+	{ 305, 76 },
+	{ 310, 74 },
+	{ 315, 73 },
+	{ 320, 72 },
+	{ 325, 70 },
+	{ 330, 69 },
+	{ 335, 68 },
+	{ 340, 66 },
+	{ 345, 65 },
+	{ 350, 64 },
+	{ 355, 63 },
+	{ 360, 62 },
+	{ 365, 61 },
+	{ 370, 60 },
+	{ 375, 58 },
+	{ 380, 57 },
+	{ 385, 56 },
+	{ 390, 55 },
+	{ 395, 54 },
+	{ 400, 53 },
+};
+
+static int rockchip_nvmem_cell_read_common(struct device_node *np,
+					   const char *cell_id,
+					   void *val, size_t count)
+{
+	struct nvmem_cell *cell;
+	void *buf;
+	size_t len;
+
+	cell = of_nvmem_cell_get(np, cell_id);
+	if (IS_ERR(cell))
+		return PTR_ERR(cell);
+
+	buf = nvmem_cell_read(cell, &len);
+	if (IS_ERR(buf)) {
+		nvmem_cell_put(cell);
+		return PTR_ERR(buf);
+	}
+	if (len != count) {
+		kfree(buf);
+		nvmem_cell_put(cell);
+		return -EINVAL;
+	}
+	memcpy(val, buf, count);
+	kfree(buf);
+	nvmem_cell_put(cell);
+
+	return 0;
+}
+
+int rockchip_nvmem_cell_read_u8(struct device_node *np, const char *cell_id,
+				u8 *val)
+{
+	return rockchip_nvmem_cell_read_common(np, cell_id, val, sizeof(*val));
+}
+EXPORT_SYMBOL(rockchip_nvmem_cell_read_u8);
+
+int rockchip_nvmem_cell_read_u16(struct device_node *np, const char *cell_id,
+				 u16 *val)
+{
+	return rockchip_nvmem_cell_read_common(np, cell_id, val, sizeof(*val));
+}
+EXPORT_SYMBOL(rockchip_nvmem_cell_read_u16);
+
+static int rockchip_get_sel_table(struct device_node *np, char *porp_name,
+				  struct sel_table **table)
+{
+	struct sel_table *sel_table;
+	const struct property *prop;
+	int count, i;
+
+	prop = of_find_property(np, porp_name, NULL);
+	if (!prop)
+		return -EINVAL;
+
+	if (!prop->value)
+		return -ENODATA;
+
+	count = of_property_count_u32_elems(np, porp_name);
+	if (count < 0)
+		return -EINVAL;
+
+	if (count % 3)
+		return -EINVAL;
+
+	sel_table = kzalloc(sizeof(*sel_table) * (count / 3 + 1), GFP_KERNEL);
+	if (!sel_table)
+		return -ENOMEM;
+
+	for (i = 0; i < count / 3; i++) {
+		of_property_read_u32_index(np, porp_name, 3 * i,
+					   &sel_table[i].min);
+		of_property_read_u32_index(np, porp_name, 3 * i + 1,
+					   &sel_table[i].max);
+		of_property_read_u32_index(np, porp_name, 3 * i + 2,
+					   &sel_table[i].sel);
+	}
+	sel_table[i].min = 0;
+	sel_table[i].max = 0;
+	sel_table[i].sel = SEL_TABLE_END;
+
+	*table = sel_table;
+
+	return 0;
+}
+
+static int rockchip_get_bin_sel_table(struct device_node *np, char *porp_name,
+				      struct bin_sel_table **table)
+{
+	struct bin_sel_table *sel_table;
+	const struct property *prop;
+	int count, i;
+
+	prop = of_find_property(np, porp_name, NULL);
+	if (!prop)
+		return -EINVAL;
+
+	if (!prop->value)
+		return -ENODATA;
+
+	count = of_property_count_u32_elems(np, porp_name);
+	if (count < 0)
+		return -EINVAL;
+
+	if (count % 2)
+		return -EINVAL;
+
+	sel_table = kzalloc(sizeof(*sel_table) * (count / 2 + 1), GFP_KERNEL);
+	if (!sel_table)
+		return -ENOMEM;
+
+	for (i = 0; i < count / 2; i++) {
+		of_property_read_u32_index(np, porp_name, 2 * i,
+					   &sel_table[i].bin);
+		of_property_read_u32_index(np, porp_name, 2 * i + 1,
+					   &sel_table[i].sel);
+	}
+
+	sel_table[i].bin = 0;
+	sel_table[i].sel = SEL_TABLE_END;
+
+	*table = sel_table;
+
+	return 0;
+}
+
+static int rockchip_get_sel(struct device_node *np, char *name,
+			    int value, int *sel)
+{
+	struct sel_table *table = NULL;
+	int i, ret = -EINVAL;
+
+	if (!sel)
+		return -EINVAL;
+
+	if (rockchip_get_sel_table(np, name, &table))
+		return -EINVAL;
+
+	for (i = 0; table[i].sel != SEL_TABLE_END; i++) {
+		if (value >= table[i].min) {
+			*sel = table[i].sel;
+			ret = 0;
+		}
+	}
+	kfree(table);
+
+	return ret;
+}
+
+static int rockchip_get_bin_sel(struct device_node *np, char *name,
+				int value, int *sel)
+{
+	struct bin_sel_table *table = NULL;
+	int i, ret = -EINVAL;
+
+	if (!sel)
+		return -EINVAL;
+
+	if (rockchip_get_bin_sel_table(np, name, &table))
+		return -EINVAL;
+
+	for (i = 0; table[i].sel != SEL_TABLE_END; i++) {
+		if (value == table[i].bin) {
+			*sel = table[i].sel;
+			ret = 0;
+			break;
+		}
+	}
+	kfree(table);
+
+	return ret;
+}
+
+static int rockchip_parse_pvtm_config(struct device_node *np,
+				      struct pvtm_config *pvtm)
+{
+	if (of_property_read_u32(np, "rockchip,pvtm-freq", &pvtm->freq))
+		return -EINVAL;
+	if (of_property_read_u32(np, "rockchip,pvtm-volt", &pvtm->volt))
+		return -EINVAL;
+	if (of_property_read_u32(np, "rockchip,pvtm-sample-time",
+				 &pvtm->sample_time))
+		return -EINVAL;
+	if (of_property_read_u32(np, "rockchip,pvtm-ref-temp", &pvtm->ref_temp))
+		return -EINVAL;
+	if (of_property_read_u32_array(np, "rockchip,pvtm-temp-prop",
+				       pvtm->temp_prop, 2))
+		return -EINVAL;
+	if (of_property_read_string(np, "rockchip,pvtm-thermal-zone",
+				    &pvtm->tz_name)) {
+		if (of_property_read_string(np, "rockchip,thermal-zone",
+					    &pvtm->tz_name))
+			return -EINVAL;
+	}
+	pvtm->tz = thermal_zone_get_zone_by_name(pvtm->tz_name);
+	if (IS_ERR(pvtm->tz))
+		return -EINVAL;
+	if (!pvtm->tz->ops->get_temp)
+		return -EINVAL;
+	if (of_property_read_bool(np, "rockchip,pvtm-pvtpll")) {
+		if (of_property_read_u32(np, "rockchip,pvtm-offset",
+					 &pvtm->offset))
+			return -EINVAL;
+		pvtm->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+		if (IS_ERR(pvtm->grf))
+			return -EINVAL;
+		return 0;
+	}
+	if (of_property_read_u32_array(np, "rockchip,pvtm-ch", pvtm->ch, 2))
+		return -EINVAL;
+	if (pvtm->ch[0] >= PVTM_CH_MAX || pvtm->ch[1] >= PVTM_SUB_CH_MAX)
+		return -EINVAL;
+	if (of_property_read_u32(np, "rockchip,pvtm-number", &pvtm->num))
+		return -EINVAL;
+	if (of_property_read_u32(np, "rockchip,pvtm-error", &pvtm->err))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int rockchip_get_pvtm_specific_value(struct device *dev,
+					    struct device_node *np,
+					    struct clk *clk,
+					    struct regulator *reg,
+					    int *target_value)
+{
+	struct pvtm_config *pvtm;
+	unsigned long old_freq;
+	unsigned int old_volt;
+	int cur_temp, diff_temp;
+	int cur_value, total_value, avg_value, diff_value;
+	int min_value, max_value;
+	int ret = 0, i = 0, retry = 2;
+
+	pvtm = kzalloc(sizeof(*pvtm), GFP_KERNEL);
+	if (!pvtm)
+		return -ENOMEM;
+
+	ret = rockchip_parse_pvtm_config(np, pvtm);
+	if (ret)
+		goto pvtm_value_out;
+
+	old_freq = clk_get_rate(clk);
+	old_volt = regulator_get_voltage(reg);
+
+	/*
+	 * Set pvtm_freq to the lowest frequency in dts,
+	 * so change frequency first.
+	 */
+	ret = clk_set_rate(clk, pvtm->freq * 1000);
+	if (ret) {
+		dev_err(dev, "Failed to set pvtm freq\n");
+		goto pvtm_value_out;
+	}
+
+	ret = regulator_set_voltage(reg, pvtm->volt, pvtm->volt);
+	if (ret) {
+		dev_err(dev, "Failed to set pvtm_volt\n");
+		goto restore_clk;
+	}
+
+	/* The first few values may be fluctuant, if error is too big, retry*/
+	while (retry--) {
+		total_value = 0;
+		min_value = INT_MAX;
+		max_value = 0;
+
+		for (i = 0; i < pvtm->num; i++) {
+			cur_value = rockchip_get_pvtm_value(pvtm->ch[0],
+							    pvtm->ch[1],
+							    pvtm->sample_time);
+			if (cur_value <= 0) {
+				ret = -EINVAL;
+				goto resetore_volt;
+			}
+			if (cur_value < min_value)
+				min_value = cur_value;
+			if (cur_value > max_value)
+				max_value = cur_value;
+			total_value += cur_value;
+		}
+		if (max_value - min_value < pvtm->err)
+			break;
+	}
+	if (!total_value || !pvtm->num) {
+		ret = -EINVAL;
+		goto resetore_volt;
+	}
+	avg_value = total_value / pvtm->num;
+
+	/*
+	 * As pvtm is influenced by temperature, compute difference between
+	 * current temperature and reference temperature
+	 */
+	pvtm->tz->ops->get_temp(pvtm->tz, &cur_temp);
+	diff_temp = (cur_temp / 1000 - pvtm->ref_temp);
+	diff_value = diff_temp *
+		(diff_temp < 0 ? pvtm->temp_prop[0] : pvtm->temp_prop[1]);
+	*target_value = avg_value + diff_value;
+
+	pvtm_value[pvtm->ch[0]][pvtm->ch[1]] = *target_value;
+
+	dev_info(dev, "temp=%d, pvtm=%d (%d + %d)\n",
+		 cur_temp, *target_value, avg_value, diff_value);
+
+resetore_volt:
+	regulator_set_voltage(reg, old_volt, old_volt);
+restore_clk:
+	clk_set_rate(clk, old_freq);
+pvtm_value_out:
+	kfree(pvtm);
+
+	return ret;
+}
+
+/**
+ * mul_frac() - multiply two fixed-point numbers
+ * @x:	first multiplicand
+ * @y:	second multiplicand
+ *
+ * Return: the result of multiplying two fixed-point numbers.  The
+ * result is also a fixed-point number.
+ */
+static inline s64 mul_frac(s64 x, s64 y)
+{
+	return (x * y) >> FRAC_BITS;
+}
+
+static int temp_to_conversion_rate(int temp)
+{
+	int high, low, mid;
+
+	low = 0;
+	high = ARRAY_SIZE(conv_table) - 1;
+	mid = (high + low) / 2;
+
+	/* No temp available, return max conversion_rate */
+	if (temp <= conv_table[low].temp)
+		return conv_table[low].conv;
+	if (temp >= conv_table[high].temp)
+		return conv_table[high].conv;
+
+	while (low <= high) {
+		if (temp <= conv_table[mid].temp && temp >
+		    conv_table[mid - 1].temp) {
+			return conv_table[mid - 1].conv +
+			    (conv_table[mid].conv - conv_table[mid - 1].conv) *
+			    (temp - conv_table[mid - 1].temp) /
+			    (conv_table[mid].temp - conv_table[mid - 1].temp);
+		} else if (temp > conv_table[mid].temp) {
+			low = mid + 1;
+		} else {
+			high = mid - 1;
+		}
+		mid = (low + high) / 2;
+	}
+
+	return 100;
+}
+
+static int rockchip_adjust_leakage(struct device *dev, struct device_node *np,
+				   int *leakage)
+{
+	struct nvmem_cell *cell;
+	u8 value = 0;
+	u32 temp;
+	int conversion;
+	int ret;
+
+	cell = of_nvmem_cell_get(np, "leakage_temp");
+	if (IS_ERR(cell))
+		goto next;
+	nvmem_cell_put(cell);
+	ret = rockchip_nvmem_cell_read_u8(np, "leakage_temp", &value);
+	if (ret) {
+		dev_err(dev, "Failed to get leakage temp\n");
+		return -EINVAL;
+	}
+	/*
+	 * The ambient temperature range: 20C to 40C
+	 * In order to improve the precision, we do a conversion.
+	 * The temp in efuse : temp_efuse = (temp - 20) / (40 - 20) * 63
+	 * The ambient temp : temp = (temp_efuse / 63) * (40 - 20) + 20
+	 * Reserves a decimal point : temp = temp * 10
+	 */
+	temp = value;
+	temp = mul_frac((int_to_frac(temp) / 63 * 20 + int_to_frac(20)),
+			int_to_frac(10));
+	conversion = temp_to_conversion_rate(frac_to_int(temp));
+	*leakage = *leakage * conversion / 100;
+
+next:
+	cell = of_nvmem_cell_get(np, "leakage_volt");
+	if (IS_ERR(cell))
+		return 0;
+	nvmem_cell_put(cell);
+	ret = rockchip_nvmem_cell_read_u8(np, "leakage_volt", &value);
+	if (ret) {
+		dev_err(dev, "Failed to get leakage volt\n");
+		return -EINVAL;
+	}
+	/*
+	 * if ft write leakage use 1.35v, need convert to 1v.
+	 * leakage(1v) = leakage(1.35v) / 4
+	 */
+	if (value)
+		*leakage = *leakage / 4;
+
+	return 0;
+}
+
+static int rockchip_get_leakage_version(int *version)
+{
+	if (*version)
+		return 0;
+
+	if (of_machine_is_compatible("rockchip,rk3368"))
+		*version = LEAKAGE_V2;
+	else if (of_machine_is_compatible("rockchip,rv1126") ||
+		 of_machine_is_compatible("rockchip,rv1109"))
+		*version = LEAKAGE_V3;
+	else
+		*version = LEAKAGE_V1;
+
+	return 0;
+}
+
+static int rockchip_get_leakage_v1(struct device *dev, struct device_node *np,
+				   char *lkg_name, int *leakage)
+{
+	struct nvmem_cell *cell;
+	int ret = 0;
+	u8 value = 0;
+
+	cell = of_nvmem_cell_get(np, "leakage");
+	if (IS_ERR(cell)) {
+		ret = rockchip_nvmem_cell_read_u8(np, lkg_name, &value);
+	} else {
+		nvmem_cell_put(cell);
+		ret = rockchip_nvmem_cell_read_u8(np, "leakage", &value);
+	}
+	if (ret)
+		dev_err(dev, "Failed to get %s\n", lkg_name);
+	else
+		*leakage = value;
+
+	return ret;
+}
+
+static int rockchip_get_leakage_v2(struct device *dev, struct device_node *np,
+				   char *lkg_name, int *leakage)
+{
+	int lkg = 0, ret = 0;
+
+	if (rockchip_get_leakage_v1(dev, np, lkg_name, &lkg))
+		return -EINVAL;
+
+	ret = rockchip_adjust_leakage(dev, np, &lkg);
+	if (ret)
+		dev_err(dev, "Failed to adjust leakage, value=%d\n", lkg);
+	else
+		*leakage = lkg;
+
+	return ret;
+}
+
+static int rockchip_get_leakage_v3(struct device *dev, struct device_node *np,
+				   char *lkg_name, int *leakage)
+{
+	int lkg = 0;
+
+	if (rockchip_get_leakage_v1(dev, np, lkg_name, &lkg))
+		return -EINVAL;
+
+	*leakage = (((lkg & 0xf8) >> 3) * 1000) + ((lkg & 0x7) * 125);
+
+	return 0;
+}
+
+int rockchip_of_get_leakage(struct device *dev, char *lkg_name, int *leakage)
+{
+	struct device_node *np;
+	int ret = -EINVAL;
+
+	np = of_parse_phandle(dev->of_node, "operating-points-v2", 0);
+	if (!np) {
+		dev_warn(dev, "OPP-v2 not supported\n");
+		return -ENOENT;
+	}
+
+	rockchip_get_leakage_version(&lkg_version);
+
+	switch (lkg_version) {
+	case LEAKAGE_V1:
+		ret = rockchip_get_leakage_v1(dev, np, lkg_name, leakage);
+		break;
+	case LEAKAGE_V2:
+		ret = rockchip_get_leakage_v2(dev, np, lkg_name, leakage);
+		break;
+	case LEAKAGE_V3:
+		ret = rockchip_get_leakage_v3(dev, np, lkg_name, leakage);
+		if (!ret) {
+			/*
+			 * round up to the nearest whole number for calculating
+			 * static power,  it does not need to be precise.
+			 */
+			if (*leakage % 1000 > 500)
+				*leakage = *leakage / 1000 + 1;
+			else
+				*leakage = *leakage / 1000;
+		}
+		break;
+	default:
+		break;
+	}
+
+	of_node_put(np);
+
+	return ret;
+}
+EXPORT_SYMBOL(rockchip_of_get_leakage);
+
+void rockchip_of_get_lkg_sel(struct device *dev, struct device_node *np,
+			     char *lkg_name, int process,
+			     int *volt_sel, int *scale_sel)
+{
+	struct property *prop = NULL;
+	int leakage = -EINVAL, ret = 0;
+	char name[NAME_MAX];
+
+	rockchip_get_leakage_version(&lkg_version);
+
+	switch (lkg_version) {
+	case LEAKAGE_V1:
+		ret = rockchip_get_leakage_v1(dev, np, lkg_name, &leakage);
+		if (ret)
+			return;
+		dev_info(dev, "leakage=%d\n", leakage);
+		break;
+	case LEAKAGE_V2:
+		ret = rockchip_get_leakage_v2(dev, np, lkg_name, &leakage);
+		if (ret)
+			return;
+		dev_info(dev, "leakage=%d\n", leakage);
+		break;
+	case LEAKAGE_V3:
+		ret = rockchip_get_leakage_v3(dev, np, lkg_name, &leakage);
+		if (ret)
+			return;
+		dev_info(dev, "leakage=%d.%d\n", leakage / 1000,
+			 leakage % 1000);
+		break;
+	default:
+		return;
+	}
+
+	if (!volt_sel)
+		goto next;
+	if (process >= 0) {
+		snprintf(name, sizeof(name),
+			 "rockchip,p%d-leakage-voltage-sel", process);
+		prop = of_find_property(np, name, NULL);
+	}
+	if (!prop)
+		sprintf(name, "rockchip,leakage-voltage-sel");
+	ret = rockchip_get_sel(np, name, leakage, volt_sel);
+	if (!ret)
+		dev_info(dev, "leakage-volt-sel=%d\n", *volt_sel);
+
+next:
+	if (!scale_sel)
+		return;
+	if (process >= 0) {
+		snprintf(name, sizeof(name),
+			 "rockchip,p%d-leakage-scaling-sel", process);
+		prop = of_find_property(np, name, NULL);
+	}
+	if (!prop)
+		sprintf(name, "rockchip,leakage-scaling-sel");
+	ret = rockchip_get_sel(np, name, leakage, scale_sel);
+	if (!ret)
+		dev_info(dev, "leakage-scale=%d\n", *scale_sel);
+}
+EXPORT_SYMBOL(rockchip_of_get_lkg_sel);
+
+static unsigned long rockchip_pvtpll_get_rate(struct rockchip_opp_info *info)
+{
+	unsigned int rate0, rate1, delta;
+	int i;
+
+#define MIN_STABLE_DELTA 3
+	regmap_read(info->grf, info->pvtpll_avg_offset, &rate0);
+	/* max delay 2ms */
+	for (i = 0; i < 20; i++) {
+		udelay(100);
+		regmap_read(info->grf, info->pvtpll_avg_offset, &rate1);
+		delta = abs(rate1 - rate0);
+		rate0 = rate1;
+		if (delta <= MIN_STABLE_DELTA)
+			break;
+	}
+
+	if (delta > MIN_STABLE_DELTA) {
+		dev_err(info->dev, "%s: bad delta: %u\n", __func__, delta);
+		return 0;
+	}
+
+	return rate0 * 1000000;
+}
+
+static int rockchip_pvtpll_parse_dt(struct rockchip_opp_info *info)
+{
+	struct device_node *np;
+	int ret;
+
+	np = of_parse_phandle(info->dev->of_node, "operating-points-v2", 0);
+	if (!np) {
+		dev_warn(info->dev, "OPP-v2 not supported\n");
+		return -ENOENT;
+	}
+
+	ret = of_property_read_u32(np, "rockchip,pvtpll-avg-offset", &info->pvtpll_avg_offset);
+	if (ret)
+		goto out;
+
+	ret = of_property_read_u32(np, "rockchip,pvtpll-min-rate", &info->pvtpll_min_rate);
+	if (ret)
+		goto out;
+
+	ret = of_property_read_u32(np, "rockchip,pvtpll-volt-step", &info->pvtpll_volt_step);
+out:
+	of_node_put(np);
+
+	return ret;
+}
+
+static int rockchip_init_pvtpll_info(struct rockchip_opp_info *info)
+{
+	struct opp_table *opp_table;
+	struct dev_pm_opp *opp;
+	int i = 0, max_count, ret;
+
+	ret = rockchip_pvtpll_parse_dt(info);
+	if (ret)
+		return ret;
+
+	max_count = dev_pm_opp_get_opp_count(info->dev);
+	if (max_count <= 0)
+		return max_count ? max_count : -ENODATA;
+
+	info->opp_table = kcalloc(max_count, sizeof(*info->opp_table), GFP_KERNEL);
+	if (!info->opp_table)
+		return -ENOMEM;
+
+	opp_table = dev_pm_opp_get_opp_table(info->dev);
+	if (!opp_table) {
+		kfree(info->opp_table);
+		info->opp_table = NULL;
+		return -ENOMEM;
+	}
+
+	mutex_lock(&opp_table->lock);
+	list_for_each_entry(opp, &opp_table->opp_list, node) {
+		if (!opp->available)
+			continue;
+
+		info->opp_table[i].u_volt = opp->supplies[0].u_volt;
+		info->opp_table[i].u_volt_min = opp->supplies[0].u_volt_min;
+		info->opp_table[i].u_volt_max = opp->supplies[0].u_volt_max;
+		info->opp_table[i++].rate = opp->rates[0];
+	}
+	mutex_unlock(&opp_table->lock);
+
+	dev_pm_opp_put_opp_table(opp_table);
+
+	return 0;
+}
+
+void rockchip_pvtpll_calibrate_opp(struct rockchip_opp_info *info)
+{
+	struct opp_table *opp_table;
+	struct dev_pm_opp *opp;
+	struct regulator *reg;
+	unsigned long volt = 0, volt_min, volt_max, old_volt;
+	unsigned long rate, pvtpll_rate, old_rate, delta0, delta1;
+	int i = 0, max_count, step, cur_step, ret;
+
+	if (!info->grf)
+		return;
+
+	dev_dbg(info->dev, "calibrating opp ...\n");
+	ret = rockchip_init_pvtpll_info(info);
+	if (ret)
+		return;
+
+	max_count = dev_pm_opp_get_opp_count(info->dev);
+	if (max_count <= 0)
+		return;
+
+	opp_table = dev_pm_opp_get_opp_table(info->dev);
+	if (!opp_table)
+		return;
+
+	if ((!opp_table->regulators) || IS_ERR(opp_table->clk))
+		goto out_put;
+
+	reg = opp_table->regulators[0];
+	old_volt = regulator_get_voltage(reg);
+	old_rate = clk_get_rate(opp_table->clk);
+	if (IS_ERR_VALUE(old_volt) || IS_ERR_VALUE(old_rate))
+		goto out_put;
+
+	step = regulator_get_linear_step(reg);
+	if (!step)
+		step = info->pvtpll_volt_step;
+
+	for (i = 0; i < max_count; i++) {
+		rate = info->opp_table[i].rate;
+		if (rate < 1000 * info->pvtpll_min_rate)
+			continue;
+
+		volt = max(volt, info->opp_table[i].u_volt);
+		volt_min = info->opp_table[i].u_volt_min;
+		volt_max = info->opp_table[i].u_volt_max;
+
+		ret = dev_pm_opp_set_rate(info->dev, rate);
+		if (ret) {
+			dev_err(info->dev, "%s: Cannot set rate %lu Hz, ret:%d\n",
+				__func__, rate, ret);
+			goto out;
+		}
+		pvtpll_rate = rockchip_pvtpll_get_rate(info);
+		if (!pvtpll_rate)
+			goto out;
+		cur_step = (pvtpll_rate < rate) ? step : -step;
+		delta1 = abs(pvtpll_rate - rate);
+		do {
+			delta0 = delta1;
+			volt += cur_step;
+			if ((volt < volt_min) || (volt > volt_max))
+				break;
+			ret = regulator_set_voltage(reg, volt, volt);
+			if (ret) {
+				dev_err(info->dev, "%s: Cannot set voltage %lu uV, ret:%d\n",
+					__func__, volt, ret);
+				break;
+			}
+			pvtpll_rate = rockchip_pvtpll_get_rate(info);
+			if (!pvtpll_rate)
+				goto out;
+			delta1 = abs(pvtpll_rate - rate);
+		} while (delta1 < delta0);
+
+		volt -= cur_step;
+		info->opp_table[i].u_volt = volt;
+	}
+
+	i = 0;
+	mutex_lock(&opp_table->lock);
+	list_for_each_entry(opp, &opp_table->opp_list, node) {
+		if (!opp->available)
+			continue;
+
+		opp->supplies[0].u_volt = info->opp_table[i++].u_volt;
+	}
+	mutex_unlock(&opp_table->lock);
+	dev_info(info->dev, "opp calibration done\n");
+out:
+	clk_set_rate(opp_table->clk, old_rate);
+	regulator_set_voltage(reg, old_volt, old_volt);
+out_put:
+	dev_pm_opp_put_opp_table(opp_table);
+}
+EXPORT_SYMBOL(rockchip_pvtpll_calibrate_opp);
+
+static int rockchip_get_pvtm_pvtpll(struct device *dev, struct device_node *np,
+				    char *reg_name)
+{
+	struct regulator *reg;
+	struct clk *clk;
+	struct pvtm_config *pvtm;
+	unsigned long old_freq;
+	unsigned int old_volt;
+	int cur_temp, diff_temp, prop_temp, diff_value;
+	int pvtm_value = 0;
+	int ret = 0;
+
+	pvtm = kzalloc(sizeof(*pvtm), GFP_KERNEL);
+	if (!pvtm)
+		return -ENOMEM;
+
+	ret = rockchip_parse_pvtm_config(np, pvtm);
+	if (ret)
+		goto out;
+
+	clk = clk_get(dev, NULL);
+	if (IS_ERR_OR_NULL(clk)) {
+		dev_warn(dev, "Failed to get clk\n");
+		goto out;
+	}
+
+	reg = regulator_get_optional(dev, reg_name);
+	if (IS_ERR_OR_NULL(reg)) {
+		dev_warn(dev, "Failed to get reg\n");
+		clk_put(clk);
+		goto out;
+	}
+	old_freq = clk_get_rate(clk);
+	old_volt = regulator_get_voltage(reg);
+
+	ret = clk_set_rate(clk, pvtm->freq * 1000);
+	if (ret) {
+		dev_err(dev, "Failed to set pvtm freq\n");
+		goto put_reg;
+	}
+	ret = regulator_set_voltage(reg, pvtm->volt, pvtm->volt);
+	if (ret) {
+		dev_err(dev, "Failed to set pvtm_volt\n");
+		goto restore_clk;
+	}
+	usleep_range(pvtm->sample_time, pvtm->sample_time + 100);
+
+	ret = regmap_read(pvtm->grf, pvtm->offset, &pvtm_value);
+	if (ret < 0) {
+		dev_err(dev, "failed to get pvtm from 0x%x\n", pvtm->offset);
+		goto resetore_volt;
+	}
+	pvtm->tz->ops->get_temp(pvtm->tz, &cur_temp);
+	diff_temp = (cur_temp / 1000 - pvtm->ref_temp);
+	if (diff_temp < 0)
+		prop_temp = pvtm->temp_prop[0];
+	else
+		prop_temp = pvtm->temp_prop[1];
+	diff_value = diff_temp * prop_temp / 1000;
+	pvtm_value += diff_value;
+
+	dev_info(dev, "pvtm=%d\n", pvtm_value);
+
+resetore_volt:
+	regulator_set_voltage(reg, old_volt, old_volt);
+restore_clk:
+	clk_set_rate(clk, old_freq);
+put_reg:
+	regulator_put(reg);
+	clk_put(clk);
+out:
+	kfree(pvtm);
+
+	return pvtm_value;
+}
+
+static int rockchip_get_pvtm(struct device *dev, struct device_node *np,
+			     char *reg_name)
+{
+	struct regulator *reg;
+	struct clk *clk;
+	unsigned int ch[2];
+	int pvtm = 0;
+	u16 tmp = 0;
+
+	if (!rockchip_nvmem_cell_read_u16(np, "pvtm", &tmp) && tmp) {
+		pvtm = 10 * tmp;
+		dev_info(dev, "pvtm = %d, from nvmem\n", pvtm);
+		return pvtm;
+	}
+
+	if (of_property_read_u32_array(np, "rockchip,pvtm-ch", ch, 2))
+		return -EINVAL;
+
+	if (ch[0] >= PVTM_CH_MAX || ch[1] >= PVTM_SUB_CH_MAX)
+		return -EINVAL;
+
+	if (pvtm_value[ch[0]][ch[1]]) {
+		dev_info(dev, "pvtm = %d, form pvtm_value\n", pvtm_value[ch[0]][ch[1]]);
+		return pvtm_value[ch[0]][ch[1]];
+	}
+
+	clk = clk_get(dev, NULL);
+	if (IS_ERR_OR_NULL(clk)) {
+		dev_warn(dev, "Failed to get clk\n");
+		return PTR_ERR_OR_ZERO(clk);
+	}
+
+	reg = regulator_get_optional(dev, reg_name);
+	if (IS_ERR_OR_NULL(reg)) {
+		dev_warn(dev, "Failed to get reg\n");
+		clk_put(clk);
+		return PTR_ERR_OR_ZERO(reg);
+	}
+
+	rockchip_get_pvtm_specific_value(dev, np, clk, reg, &pvtm);
+
+	regulator_put(reg);
+	clk_put(clk);
+
+	return pvtm;
+}
+
+void rockchip_of_get_pvtm_sel(struct device *dev, struct device_node *np,
+			      char *reg_name, int process,
+			      int *volt_sel, int *scale_sel)
+{
+	struct property *prop = NULL;
+	char name[NAME_MAX];
+	int pvtm, ret;
+
+	if (of_property_read_bool(np, "rockchip,pvtm-pvtpll"))
+		pvtm = rockchip_get_pvtm_pvtpll(dev, np, reg_name);
+	else
+		pvtm = rockchip_get_pvtm(dev, np, reg_name);
+	if (pvtm <= 0)
+		return;
+
+	if (!volt_sel)
+		goto next;
+	if (process >= 0) {
+		snprintf(name, sizeof(name),
+			 "rockchip,p%d-pvtm-voltage-sel", process);
+		prop = of_find_property(np, name, NULL);
+	}
+	if (!prop)
+		sprintf(name, "rockchip,pvtm-voltage-sel");
+	ret = rockchip_get_sel(np, name, pvtm, volt_sel);
+	if (!ret && volt_sel)
+		dev_info(dev, "pvtm-volt-sel=%d\n", *volt_sel);
+
+next:
+	if (!scale_sel)
+		return;
+	if (process >= 0) {
+		snprintf(name, sizeof(name),
+			 "rockchip,p%d-pvtm-scaling-sel", process);
+		prop = of_find_property(np, name, NULL);
+	}
+	if (!prop)
+		sprintf(name, "rockchip,pvtm-scaling-sel");
+	ret = rockchip_get_sel(np, name, pvtm, scale_sel);
+	if (!ret)
+		dev_info(dev, "pvtm-scale=%d\n", *scale_sel);
+}
+EXPORT_SYMBOL(rockchip_of_get_pvtm_sel);
+
+void rockchip_of_get_bin_sel(struct device *dev, struct device_node *np,
+			     int bin, int *scale_sel)
+{
+	int ret = 0;
+
+	if (!scale_sel || bin < 0)
+		return;
+
+	ret = rockchip_get_bin_sel(np, "rockchip,bin-scaling-sel",
+				   bin, scale_sel);
+	if (!ret)
+		dev_info(dev, "bin-scale=%d\n", *scale_sel);
+}
+EXPORT_SYMBOL(rockchip_of_get_bin_sel);
+
+void rockchip_of_get_bin_volt_sel(struct device *dev, struct device_node *np,
+				  int bin, int *bin_volt_sel)
+{
+	int ret = 0;
+
+	if (!bin_volt_sel || bin < 0)
+		return;
+
+	ret = rockchip_get_bin_sel(np, "rockchip,bin-voltage-sel",
+				   bin, bin_volt_sel);
+	if (!ret)
+		dev_info(dev, "bin-volt-sel=%d\n", *bin_volt_sel);
+}
+EXPORT_SYMBOL(rockchip_of_get_bin_volt_sel);
+
+void rockchip_get_opp_data(const struct of_device_id *matches,
+			   struct rockchip_opp_info *info)
+{
+	const struct of_device_id *match;
+	struct device_node *node;
+
+	node = of_find_node_by_path("/");
+	match = of_match_node(matches, node);
+	if (match && match->data)
+		info->data = match->data;
+	of_node_put(node);
+}
+EXPORT_SYMBOL(rockchip_get_opp_data);
+
+int rockchip_get_volt_rm_table(struct device *dev, struct device_node *np,
+			       char *porp_name, struct volt_rm_table **table)
+{
+	struct volt_rm_table *rm_table;
+	const struct property *prop;
+	int count, i;
+
+	prop = of_find_property(np, porp_name, NULL);
+	if (!prop)
+		return -EINVAL;
+
+	if (!prop->value)
+		return -ENODATA;
+
+	count = of_property_count_u32_elems(np, porp_name);
+	if (count < 0)
+		return -EINVAL;
+
+	if (count % 2)
+		return -EINVAL;
+
+	rm_table = devm_kzalloc(dev, sizeof(*rm_table) * (count / 2 + 1),
+				GFP_KERNEL);
+	if (!rm_table)
+		return -ENOMEM;
+
+	for (i = 0; i < count / 2; i++) {
+		of_property_read_u32_index(np, porp_name, 2 * i,
+					   &rm_table[i].volt);
+		of_property_read_u32_index(np, porp_name, 2 * i + 1,
+					   &rm_table[i].rm);
+	}
+
+	rm_table[i].volt = 0;
+	rm_table[i].rm = VOLT_RM_TABLE_END;
+
+	*table = rm_table;
+
+	return 0;
+}
+EXPORT_SYMBOL(rockchip_get_volt_rm_table);
+
+void rockchip_get_scale_volt_sel(struct device *dev, char *lkg_name,
+				 char *reg_name, int bin, int process,
+				 int *scale, int *volt_sel)
+{
+	struct device_node *np;
+	int lkg_scale = 0, pvtm_scale = 0, bin_scale = 0;
+	int lkg_volt_sel = -EINVAL, pvtm_volt_sel = -EINVAL;
+	int bin_volt_sel = -EINVAL;
+
+	np = of_parse_phandle(dev->of_node, "operating-points-v2", 0);
+	if (!np) {
+		dev_warn(dev, "OPP-v2 not supported\n");
+		return;
+	}
+
+	rockchip_of_get_lkg_sel(dev, np, lkg_name, process,
+				&lkg_volt_sel, &lkg_scale);
+	rockchip_of_get_pvtm_sel(dev, np, reg_name, process,
+				 &pvtm_volt_sel, &pvtm_scale);
+	rockchip_of_get_bin_sel(dev, np, bin, &bin_scale);
+	rockchip_of_get_bin_volt_sel(dev, np, bin, &bin_volt_sel);
+	if (scale)
+		*scale = max3(lkg_scale, pvtm_scale, bin_scale);
+	if (volt_sel) {
+		if (bin_volt_sel >= 0)
+			*volt_sel = bin_volt_sel;
+		else
+			*volt_sel = max(lkg_volt_sel, pvtm_volt_sel);
+	}
+
+	of_node_put(np);
+}
+EXPORT_SYMBOL(rockchip_get_scale_volt_sel);
+
+int rockchip_set_opp_prop_name(struct device *dev, int process,
+					     int volt_sel)
+{
+	char name[MAX_PROP_NAME_LEN];
+
+	if (process >= 0) {
+		if (volt_sel >= 0)
+			snprintf(name, MAX_PROP_NAME_LEN, "P%d-L%d",
+				 process, volt_sel);
+		else
+			snprintf(name, MAX_PROP_NAME_LEN, "P%d", process);
+	} else if (volt_sel >= 0) {
+		snprintf(name, MAX_PROP_NAME_LEN, "L%d", volt_sel);
+	} else {
+		return -EINVAL;
+	}
+
+	return dev_pm_opp_set_prop_name(dev, name);
+}
+EXPORT_SYMBOL(rockchip_set_opp_prop_name);
+
+static int rockchip_adjust_opp_by_irdrop(struct device *dev,
+					 struct device_node *np,
+					 unsigned long *safe_rate,
+					 unsigned long *max_rate)
+{
+	struct sel_table *irdrop_table = NULL;
+	struct opp_table *opp_table;
+	struct dev_pm_opp *opp;
+	unsigned long tmp_safe_rate = 0;
+	int evb_irdrop = 0, board_irdrop, delta_irdrop;
+	int opp_rate, i, ret = 0;
+	u32 max_volt = UINT_MAX;
+	bool reach_max_volt = false;
+
+	of_property_read_u32_index(np, "rockchip,max-volt", 0, &max_volt);
+	of_property_read_u32_index(np, "rockchip,evb-irdrop", 0, &evb_irdrop);
+	rockchip_get_sel_table(np, "rockchip,board-irdrop", &irdrop_table);
+
+	opp_table = dev_pm_opp_get_opp_table(dev);
+	if (!opp_table) {
+		ret =  -ENOMEM;
+		goto out;
+	}
+
+	mutex_lock(&opp_table->lock);
+	list_for_each_entry(opp, &opp_table->opp_list, node) {
+		if (!opp->available)
+			continue;
+		if (!irdrop_table) {
+			delta_irdrop = 0;
+		} else {
+			opp_rate = opp->rates[0] / 1000000;
+			board_irdrop = -EINVAL;
+			for (i = 0; irdrop_table[i].sel != SEL_TABLE_END; i++) {
+				if (opp_rate >= irdrop_table[i].min)
+					board_irdrop = irdrop_table[i].sel;
+			}
+			if (board_irdrop == -EINVAL)
+				delta_irdrop = 0;
+			else
+				delta_irdrop = board_irdrop - evb_irdrop;
+		}
+		if ((opp->supplies[0].u_volt + delta_irdrop) <= max_volt) {
+			opp->supplies[0].u_volt += delta_irdrop;
+			opp->supplies[0].u_volt_min += delta_irdrop;
+			if (opp->supplies[0].u_volt_max + delta_irdrop <=
+			    max_volt)
+				opp->supplies[0].u_volt_max += delta_irdrop;
+			else
+				opp->supplies[0].u_volt_max = max_volt;
+			if (!reach_max_volt)
+				tmp_safe_rate = opp->rates[0];
+			if (opp->supplies[0].u_volt == max_volt)
+				reach_max_volt = true;
+		} else {
+			opp->supplies[0].u_volt = max_volt;
+			opp->supplies[0].u_volt_min = max_volt;
+			opp->supplies[0].u_volt_max = max_volt;
+		}
+		if (max_rate)
+			*max_rate = opp->rates[0];
+		if (safe_rate && tmp_safe_rate != opp->rates[0])
+			*safe_rate = tmp_safe_rate;
+	}
+	mutex_unlock(&opp_table->lock);
+
+	dev_pm_opp_put_opp_table(opp_table);
+out:
+	kfree(irdrop_table);
+
+	return ret;
+}
+
+static void rockchip_adjust_opp_by_mbist_vmin(struct device *dev,
+					      struct device_node *np)
+{
+	struct opp_table *opp_table;
+	struct dev_pm_opp *opp;
+	u32 vmin = 0;
+	u8 index = 0;
+
+	if (rockchip_nvmem_cell_read_u8(np, "mbist-vmin", &index))
+		return;
+
+	if (!index)
+		return;
+
+	if (of_property_read_u32_index(np, "mbist-vmin", index-1, &vmin))
+		return;
+
+	opp_table = dev_pm_opp_get_opp_table(dev);
+	if (!opp_table)
+		return;
+
+	mutex_lock(&opp_table->lock);
+	list_for_each_entry(opp, &opp_table->opp_list, node) {
+		if (!opp->available)
+			continue;
+		if (opp->supplies->u_volt < vmin) {
+			opp->supplies->u_volt = vmin;
+			opp->supplies->u_volt_min = vmin;
+		}
+	}
+	mutex_unlock(&opp_table->lock);
+}
+
+static int rockchip_adjust_opp_table(struct device *dev,
+				     unsigned long scale_rate)
+{
+	struct dev_pm_opp *opp;
+	unsigned long rate;
+	int i, count, ret = 0;
+
+	count = dev_pm_opp_get_opp_count(dev);
+	if (count <= 0) {
+		ret = count ? count : -ENODATA;
+		goto out;
+	}
+
+	for (i = 0, rate = 0; i < count; i++, rate++) {
+		/* find next rate */
+		opp = dev_pm_opp_find_freq_ceil(dev, &rate);
+		if (IS_ERR(opp)) {
+			ret = PTR_ERR(opp);
+			goto out;
+		}
+		if (opp->rates[0] > scale_rate)
+			dev_pm_opp_disable(dev, opp->rates[0]);
+		dev_pm_opp_put(opp);
+	}
+out:
+	return ret;
+}
+
+int rockchip_adjust_power_scale(struct device *dev, int scale)
+{
+	struct device_node *np;
+	struct clk *clk;
+	unsigned long safe_rate = 0, max_rate = 0;
+	int irdrop_scale = 0, opp_scale = 0;
+	u32 target_scale, avs = 0, avs_scale = 0;
+	long scale_rate = 0;
+	int ret = 0;
+
+	np = of_parse_phandle(dev->of_node, "operating-points-v2", 0);
+	if (!np) {
+		dev_warn(dev, "OPP-v2 not supported\n");
+		return -ENOENT;
+	}
+	of_property_read_u32(np, "rockchip,avs-enable", &avs);
+	of_property_read_u32(np, "rockchip,avs", &avs);
+	of_property_read_u32(np, "rockchip,avs-scale", &avs_scale);
+	rockchip_adjust_opp_by_mbist_vmin(dev, np);
+	rockchip_adjust_opp_by_irdrop(dev, np, &safe_rate, &max_rate);
+
+	dev_info(dev, "avs=%d\n", avs);
+	clk = of_clk_get_by_name(np, NULL);
+	if (IS_ERR(clk)) {
+		if (!safe_rate)
+			goto out_np;
+		dev_dbg(dev, "Failed to get clk, safe_rate=%lu\n", safe_rate);
+		ret = rockchip_adjust_opp_table(dev, safe_rate);
+		if (ret)
+			dev_err(dev, "Failed to adjust opp table\n");
+		goto out_np;
+	}
+
+	if (safe_rate)
+		irdrop_scale = rockchip_pll_clk_rate_to_scale(clk, safe_rate);
+	if (max_rate)
+		opp_scale = rockchip_pll_clk_rate_to_scale(clk, max_rate);
+	target_scale = max(irdrop_scale, scale);
+	if (target_scale <= 0)
+		goto out_clk;
+	dev_dbg(dev, "target_scale=%d, irdrop_scale=%d, scale=%d\n",
+		target_scale, irdrop_scale, scale);
+
+	if (avs == AVS_SCALING_RATE) {
+		ret = rockchip_pll_clk_adaptive_scaling(clk, target_scale);
+		if (ret)
+			dev_err(dev, "Failed to adaptive scaling\n");
+		if (opp_scale >= avs_scale)
+			goto out_clk;
+		dev_info(dev, "avs-scale=%d, opp-scale=%d\n", avs_scale,
+			 opp_scale);
+		scale_rate = rockchip_pll_clk_scale_to_rate(clk, avs_scale);
+		if (scale_rate <= 0) {
+			dev_err(dev, "Failed to get avs scale rate, %d\n",
+				avs_scale);
+			goto out_clk;
+		}
+		dev_dbg(dev, "scale_rate=%lu\n", scale_rate);
+		ret = rockchip_adjust_opp_table(dev, scale_rate);
+		if (ret)
+			dev_err(dev, "Failed to adjust opp table\n");
+	} else if (avs == AVS_DELETE_OPP) {
+		if (opp_scale >= target_scale)
+			goto out_clk;
+		dev_info(dev, "target_scale=%d, opp-scale=%d\n", target_scale,
+			 opp_scale);
+		scale_rate = rockchip_pll_clk_scale_to_rate(clk, target_scale);
+		if (scale_rate <= 0) {
+			dev_err(dev, "Failed to get scale rate, %d\n",
+				target_scale);
+			goto out_clk;
+		}
+		dev_dbg(dev, "scale_rate=%lu\n", scale_rate);
+		ret = rockchip_adjust_opp_table(dev, scale_rate);
+		if (ret)
+			dev_err(dev, "Failed to adjust opp table\n");
+	}
+
+out_clk:
+	clk_put(clk);
+out_np:
+	of_node_put(np);
+
+	return ret;
+}
+EXPORT_SYMBOL(rockchip_adjust_power_scale);
+
+int rockchip_get_read_margin(struct device *dev,
+			     struct rockchip_opp_info *opp_info,
+			     unsigned long volt, u32 *target_rm)
+{
+	int i;
+
+	if (!opp_info || !opp_info->volt_rm_tbl)
+		return 0;
+
+	for (i = 0; opp_info->volt_rm_tbl[i].rm != VOLT_RM_TABLE_END; i++) {
+		if (volt >= opp_info->volt_rm_tbl[i].volt) {
+			opp_info->target_rm = opp_info->volt_rm_tbl[i].rm;
+			break;
+		}
+	}
+	*target_rm = opp_info->target_rm;
+
+	return 0;
+}
+EXPORT_SYMBOL(rockchip_get_read_margin);
+
+int rockchip_set_read_margin(struct device *dev,
+			     struct rockchip_opp_info *opp_info, u32 rm,
+			     bool is_set_rm)
+{
+	if (!is_set_rm || !opp_info)
+		return 0;
+	if (!opp_info || !opp_info->volt_rm_tbl)
+		return 0;
+	if (!opp_info->data || !opp_info->data->set_read_margin)
+		return 0;
+	if (rm == opp_info->current_rm)
+		return 0;
+
+	return opp_info->data->set_read_margin(dev, opp_info, rm);
+}
+EXPORT_SYMBOL(rockchip_set_read_margin);
+
+int rockchip_set_intermediate_rate(struct device *dev,
+				   struct rockchip_opp_info *opp_info,
+				   struct clk *clk, unsigned long old_freq,
+				   unsigned long new_freq, bool is_scaling_up,
+				   bool is_set_clk)
+{
+	if (!is_set_clk)
+		return 0;
+	if (!opp_info || !opp_info->volt_rm_tbl)
+		return 0;
+	if (!opp_info->data || !opp_info->data->set_read_margin)
+		return 0;
+	if (opp_info->target_rm == opp_info->current_rm)
+		return 0;
+	/*
+	 * There is no need to set intermediate rate if the new voltage
+	 * and the current voltage are high voltage.
+	 */
+	if ((opp_info->target_rm < opp_info->low_rm) &&
+	    (opp_info->current_rm < opp_info->low_rm))
+		return 0;
+
+	if (is_scaling_up) {
+		/*
+		 * If scaling up and the current frequency is less than
+		 * or equal to intermediate threshold frequency, there is
+		 * no need to set intermediate rate.
+		 */
+		if (opp_info->intermediate_threshold_freq &&
+		    old_freq <= opp_info->intermediate_threshold_freq)
+			return 0;
+		return clk_set_rate(clk, new_freq | OPP_SCALING_UP_INTER);
+	}
+	/*
+	 * If scaling down and the new frequency is less than or equal to
+	 * intermediate threshold frequency , there is no need to set
+	 * intermediate rate and set the new frequency directly.
+	 */
+	if (opp_info->intermediate_threshold_freq &&
+	    new_freq <= opp_info->intermediate_threshold_freq)
+		return clk_set_rate(clk, new_freq);
+
+	return clk_set_rate(clk, new_freq | OPP_SCALING_DOWN_INTER);
+}
+EXPORT_SYMBOL(rockchip_set_intermediate_rate);
+
+int rockchip_init_opp_table(struct device *dev, struct rockchip_opp_info *info,
+			    char *lkg_name, char *reg_name)
+{
+	struct device_node *np;
+	int bin = -EINVAL, process = -EINVAL;
+	int scale = 0, volt_sel = -EINVAL;
+	int ret = 0, num_clks = 0, i;
+	u32 freq;
+
+	/* Get OPP descriptor node */
+	np = of_parse_phandle(dev->of_node, "operating-points-v2", 0);
+	if (!np) {
+		dev_dbg(dev, "Failed to find operating-points-v2\n");
+		return -ENOENT;
+	}
+	if (!info)
+		goto next;
+
+	num_clks = of_clk_get_parent_count(np);
+	if (num_clks > 0) {
+		info->clks = devm_kcalloc(dev, num_clks, sizeof(*info->clks),
+					  GFP_KERNEL);
+		if (!info->clks) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		for (i = 0; i < num_clks; i++) {
+			info->clks[i].clk = of_clk_get(np, i);
+			if (IS_ERR(info->clks[i].clk)) {
+				ret = PTR_ERR(info->clks[i].clk);
+				dev_err(dev, "%s: failed to get clk %d\n",
+					np->name, i);
+				goto out;
+			}
+		}
+		info->num_clks = num_clks;
+		ret = clk_bulk_prepare_enable(info->num_clks, info->clks);
+		if (ret) {
+			dev_err(dev, "failed to enable opp clks\n");
+			goto out;
+		}
+	}
+	if (info->data && info->data->set_read_margin) {
+		info->current_rm = UINT_MAX;
+		info->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+		if (IS_ERR(info->grf))
+			info->grf = NULL;
+		rockchip_get_volt_rm_table(dev, np, "volt-mem-read-margin",
+					   &info->volt_rm_tbl);
+		of_property_read_u32(np, "low-volt-mem-read-margin",
+				     &info->low_rm);
+		if (!of_property_read_u32(np, "intermediate-threshold-freq",
+					  &freq))
+			info->intermediate_threshold_freq = freq * 1000;
+	}
+	if (info->data && info->data->get_soc_info)
+		info->data->get_soc_info(dev, np, &bin, &process);
+
+next:
+	rockchip_get_scale_volt_sel(dev, lkg_name, reg_name, bin, process,
+				    &scale, &volt_sel);
+	rockchip_set_opp_prop_name(dev, process, volt_sel);
+	ret = dev_pm_opp_of_add_table(dev);
+	if (ret) {
+		dev_err(dev, "Invalid operating-points in device tree.\n");
+		goto dis_opp_clk;
+	}
+	rockchip_adjust_power_scale(dev, scale);
+
+dis_opp_clk:
+	if (info && info->clks)
+		clk_bulk_disable_unprepare(info->num_clks, info->clks);
+out:
+	of_node_put(np);
+
+	return ret;
+}
+EXPORT_SYMBOL(rockchip_init_opp_table);
+
+MODULE_DESCRIPTION("ROCKCHIP OPP Select");
+MODULE_AUTHOR("Finley Xiao <finley.xiao@rock-chips.com>, Liang Chen <cl@rock-chips.com>");
+MODULE_LICENSE("GPL");
diff --git a/include/dt-bindings/clock/rockchip,rk3588-cru.h b/include/dt-bindings/clock/rockchip,rk3588-cru.h
index b5616bca7b4..864a321ab36 100644
--- a/include/dt-bindings/clock/rockchip,rk3588-cru.h
+++ b/include/dt-bindings/clock/rockchip,rk3588-cru.h
@@ -733,8 +733,9 @@
 #define ACLK_AV1_PRE			718
 #define PCLK_AV1_PRE			719
 #define HCLK_SDIO_PRE			720
+#define PCLK_VO1GRF			721
 
-#define CLK_NR_CLKS			(HCLK_SDIO_PRE + 1)
+#define CLK_NR_CLKS			(PCLK_VO1GRF + 1)
 
 /* scmi-clocks indices */
 
diff --git a/include/dt-bindings/display/rockchip_vop.h b/include/dt-bindings/display/rockchip_vop.h
new file mode 100644
index 00000000000..3e14128e7ab
--- /dev/null
+++ b/include/dt-bindings/display/rockchip_vop.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+
+#ifndef _DT_BINDINGS_ROCKCHIP_VOP_H
+#define _DT_BINDINGS_ROCKCHIP_VOP_H
+
+#define	ROCKCHIP_VOP2_CLUSTER0	0
+#define	ROCKCHIP_VOP2_CLUSTER1	1
+#define	ROCKCHIP_VOP2_ESMART0	2
+#define	ROCKCHIP_VOP2_ESMART1	3
+#define	ROCKCHIP_VOP2_SMART0	4
+#define	ROCKCHIP_VOP2_SMART1	5
+#define	ROCKCHIP_VOP2_CLUSTER2	6
+#define	ROCKCHIP_VOP2_CLUSTER3	7
+#define	ROCKCHIP_VOP2_ESMART2	8
+#define	ROCKCHIP_VOP2_ESMART3	9
+
+#endif
diff --git a/include/dt-bindings/soc/rockchip-system-status.h b/include/dt-bindings/soc/rockchip-system-status.h
new file mode 100644
index 00000000000..837a1a969c7
--- /dev/null
+++ b/include/dt-bindings/soc/rockchip-system-status.h
@@ -0,0 +1,48 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_SOC_ROCKCHIP_SYSTEM_STATUS_H
+#define _DT_BINDINGS_SOC_ROCKCHIP_SYSTEM_STATUS_H
+
+#define SYS_STATUS_NORMAL	(1 << 0)
+#define SYS_STATUS_SUSPEND	(1 << 1)
+#define SYS_STATUS_IDLE		(1 << 2)
+#define SYS_STATUS_REBOOT	(1 << 3)
+#define SYS_STATUS_VIDEO_4K	(1 << 4)
+#define SYS_STATUS_VIDEO_1080P	(1 << 5)
+#define SYS_STATUS_GPU		(1 << 6)
+#define SYS_STATUS_RGA		(1 << 7)
+#define SYS_STATUS_CIF0		(1 << 8)
+#define SYS_STATUS_CIF1		(1 << 9)
+#define SYS_STATUS_LCDC0	(1 << 10)
+#define SYS_STATUS_LCDC1	(1 << 11)
+#define SYS_STATUS_BOOST	(1 << 12)
+#define SYS_STATUS_PERFORMANCE	(1 << 13)
+#define SYS_STATUS_ISP		(1 << 14)
+#define SYS_STATUS_HDMI		(1 << 15)
+#define SYS_STATUS_VIDEO_4K_10B	(1 << 16)
+#define SYS_STATUS_LOW_POWER	(1 << 17)
+
+#define SYS_STATUS_VIDEO	(SYS_STATUS_VIDEO_4K | \
+				 SYS_STATUS_VIDEO_1080P | \
+				 SYS_STATUS_VIDEO_4K_10B)
+#define SYS_STATUS_DUALVIEW	(SYS_STATUS_LCDC0 | SYS_STATUS_LCDC1)
+
+#define DMC_FREQ_LEVEL_LOW	(0x1 << 0)
+#define DMC_FREQ_LEVEL_MID_LOW	(0x1 << 1)
+#define DMC_FREQ_LEVEL_MID_HIGH	(0x1 << 2)
+#define DMC_FREQ_LEVEL_HIGH	(0x1 << 3)
+
+#endif
diff --git a/include/linux/phy/phy-rockchip-usbdp.h b/include/linux/phy/phy-rockchip-usbdp.h
new file mode 100644
index 00000000000..6a65a159652
--- /dev/null
+++ b/include/linux/phy/phy-rockchip-usbdp.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip USBDP Combo PHY with Samsung IP block driver
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __PHY_ROCKCHIP_USBDP_H_
+#define __PHY_ROCKCHIP_USBDP_H_
+
+#include <linux/bits.h>
+
+/* RK3588 USBDP PHY Register Definitions */
+
+#define UDPHY_PCS				0x4000
+#define UDPHY_PMA				0x8000
+
+/* VO0 GRF Registers */
+#define RK3588_GRF_VO0_CON0			0x0000
+#define RK3588_GRF_VO0_CON2			0x0008
+#define DP_SINK_HPD_CFG				BIT(11)
+#define DP_SINK_HPD_SEL				BIT(10)
+#define DP_AUX_DIN_SEL				BIT(9)
+#define DP_AUX_DOUT_SEL				BIT(8)
+#define DP_LANE_SEL_N(n)			GENMASK(2 * (n) + 1, 2 * (n))
+#define DP_LANE_SEL_ALL				GENMASK(7, 0)
+#define PHY_AUX_DP_DATA_POL_NORMAL		0
+#define PHY_AUX_DP_DATA_POL_INVERT		1
+
+/* PMA CMN Registers */
+#define CMN_LANE_MUX_AND_EN_OFFSET		0x0288	/* cmn_reg00A2 */
+#define CMN_DP_LANE_MUX_N(n)			BIT((n) + 4)
+#define CMN_DP_LANE_EN_N(n)			BIT(n)
+#define CMN_DP_LANE_MUX_ALL			GENMASK(7, 4)
+#define CMN_DP_LANE_EN_ALL			GENMASK(3, 0)
+#define PHY_LANE_MUX_USB			0
+#define PHY_LANE_MUX_DP				1
+
+#define CMN_DP_LINK_OFFSET			0x28c	/*cmn_reg00A3 */
+#define CMN_DP_TX_LINK_BW			GENMASK(6, 5)
+#define CMN_DP_TX_LANE_SWAP_EN			BIT(2)
+
+#define CMN_SSC_EN_OFFSET			0x2d0	/* cmn_reg00B4 */
+#define CMN_ROPLL_SSC_EN			BIT(1)
+#define CMN_LCPLL_SSC_EN			BIT(0)
+
+#define CMN_ANA_LCPLL_DONE_OFFSET		0x0350	/* cmn_reg00D4 */
+#define CMN_ANA_LCPLL_LOCK_DONE			BIT(7)
+#define CMN_ANA_LCPLL_AFC_DONE			BIT(6)
+
+#define CMN_ANA_ROPLL_DONE_OFFSET		0x0354	/* cmn_reg00D5 */
+#define CMN_ANA_ROPLL_LOCK_DONE			BIT(1)
+#define CMN_ANA_ROPLL_AFC_DONE			BIT(0)
+
+#define CMN_DP_RSTN_OFFSET			0x038c	/* cmn_reg00E3 */
+#define CMN_DP_INIT_RSTN			BIT(3)
+#define CMN_DP_CMN_RSTN				BIT(2)
+#define CMN_CDR_WTCHDG_EN			BIT(1)
+#define CMN_CDR_WTCHDG_MSK_CDR_EN		BIT(0)
+
+#define TRSV_ANA_TX_CLK_OFFSET_N(n)		(0x854 + (n) * 0x800)	/* trsv_reg0215 */
+#define LN_ANA_TX_SER_TXCLK_INV			BIT(1)
+
+#define TRSV_LN0_MON_RX_CDR_DONE_OFFSET		0x0b84	/* trsv_reg02E1 */
+#define TRSV_LN0_MON_RX_CDR_LOCK_DONE		BIT(0)
+
+#define TRSV_LN2_MON_RX_CDR_DONE_OFFSET		0x1b84	/* trsv_reg06E1 */
+#define TRSV_LN2_MON_RX_CDR_LOCK_DONE		BIT(0)
+
+#endif
diff --git a/include/linux/soc/rockchip/cpu.h b/include/linux/soc/rockchip/cpu.h
new file mode 100644
index 00000000000..ed881b1c165
--- /dev/null
+++ b/include/linux/soc/rockchip/cpu.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __LINUX_ROCKCHIP_CPU_H
+#define __LINUX_ROCKCHIP_CPU_H
+
+#include <linux/of.h>
+
+#define ROCKCHIP_CPU_MASK		0xffff0000
+#define ROCKCHIP_CPU_SHIFT		16
+#define ROCKCHIP_CPU_PX30		0x33260000
+#define ROCKCHIP_CPU_RV1103		0x11030000
+#define ROCKCHIP_CPU_RV1106		0x11060000
+#define ROCKCHIP_CPU_RV1109		0x11090000
+#define ROCKCHIP_CPU_RV1126		0x11260000
+#define ROCKCHIP_CPU_RK312X		0x31260000
+#define ROCKCHIP_CPU_RK3288		0x32880000
+#define ROCKCHIP_CPU_RK3308		0x33080000
+#define ROCKCHIP_CPU_RK3566		0x35660000
+#define ROCKCHIP_CPU_RK3568		0x35680000
+
+#if IS_REACHABLE(CONFIG_ROCKCHIP_CPUINFO)
+
+extern unsigned long rockchip_soc_id;
+
+#define ROCKCHIP_CPU_VERION_MASK	0x0000f000
+#define ROCKCHIP_CPU_VERION_SHIFT	12
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return (rockchip_soc_id & ROCKCHIP_CPU_VERION_MASK)
+		>> ROCKCHIP_CPU_VERION_SHIFT;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+	rockchip_soc_id &= ~ROCKCHIP_CPU_VERION_MASK;
+	rockchip_soc_id |=
+		(ver << ROCKCHIP_CPU_VERION_SHIFT) & ROCKCHIP_CPU_VERION_MASK;
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+	if (!code)
+		return;
+
+	rockchip_soc_id &= ~ROCKCHIP_CPU_MASK;
+	rockchip_soc_id |= (code << ROCKCHIP_CPU_SHIFT) & ROCKCHIP_CPU_MASK;
+}
+
+int rockchip_soc_id_init(void);
+
+#else
+
+#define rockchip_soc_id 0
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return 0;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+}
+
+static inline int rockchip_soc_id_init(void)
+{
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_CPU_PX30
+static inline bool cpu_is_px30(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_PX30;
+	return of_machine_is_compatible("rockchip,px30") ||
+	       of_machine_is_compatible("rockchip,px30s") ||
+	       of_machine_is_compatible("rockchip,rk3326") ||
+	       of_machine_is_compatible("rockchip,rk3326s");
+}
+#else
+static inline bool cpu_is_px30(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RV1106)
+static inline bool cpu_is_rv1103(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1103;
+	return of_machine_is_compatible("rockchip,rv1103");
+}
+
+static inline bool cpu_is_rv1106(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1106;
+	return of_machine_is_compatible("rockchip,rv1106");
+}
+#else
+static inline bool cpu_is_rv1103(void) { return false; }
+static inline bool cpu_is_rv1106(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RV1126) || defined(CONFIG_CPU_RV1109)
+static inline bool cpu_is_rv1109(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1109;
+	return of_machine_is_compatible("rockchip,rv1109");
+}
+
+static inline bool cpu_is_rv1126(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1126;
+	return of_machine_is_compatible("rockchip,rv1126");
+}
+#else
+static inline bool cpu_is_rv1109(void) { return false; }
+static inline bool cpu_is_rv1126(void) { return false; }
+#endif
+
+#ifdef CONFIG_CPU_RK312X
+static inline bool cpu_is_rk312x(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK312X;
+	return of_machine_is_compatible("rockchip,rk3126") ||
+	       of_machine_is_compatible("rockchip,rk3126b") ||
+	       of_machine_is_compatible("rockchip,rk3126c") ||
+	       of_machine_is_compatible("rockchip,rk3128");
+}
+#else
+static inline bool cpu_is_rk312x(void) { return false; }
+#endif
+
+#ifdef CONFIG_CPU_RK3288
+static inline bool cpu_is_rk3288(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3288;
+	return of_machine_is_compatible("rockchip,rk3288") ||
+	       of_machine_is_compatible("rockchip,rk3288w");
+}
+#else
+static inline bool cpu_is_rk3288(void) { return false; }
+#endif
+
+#ifdef CONFIG_CPU_RK3308
+static inline bool cpu_is_rk3308(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3308;
+
+	return of_machine_is_compatible("rockchip,rk3308") ||
+	       of_machine_is_compatible("rockchip,rk3308bs");
+}
+#else
+static inline bool cpu_is_rk3308(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RK3568)
+static inline bool cpu_is_rk3566(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3566;
+	return of_machine_is_compatible("rockchip,rk3566");
+}
+
+static inline bool cpu_is_rk3568(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3568;
+	return of_machine_is_compatible("rockchip,rk3568");
+}
+#else
+static inline bool cpu_is_rk3566(void) { return false; }
+static inline bool cpu_is_rk3568(void) { return false; }
+#endif
+
+#define ROCKCHIP_SOC_MASK	(ROCKCHIP_CPU_MASK | 0xff)
+#define ROCKCHIP_SOC_PX30	(ROCKCHIP_CPU_PX30 | 0x00)
+#define ROCKCHIP_SOC_PX30S	(ROCKCHIP_CPU_PX30 | 0x01)
+#define ROCKCHIP_SOC_RV1103     (ROCKCHIP_CPU_RV1103 | 0x00)
+#define ROCKCHIP_SOC_RV1106     (ROCKCHIP_CPU_RV1106 | 0x00)
+#define ROCKCHIP_SOC_RV1109     (ROCKCHIP_CPU_RV1109 | 0x00)
+#define ROCKCHIP_SOC_RV1126     (ROCKCHIP_CPU_RV1126 | 0x00)
+#define ROCKCHIP_SOC_RK3126     (ROCKCHIP_CPU_RK312X | 0x00)
+#define ROCKCHIP_SOC_RK3126B    (ROCKCHIP_CPU_RK312X | 0x10)
+#define ROCKCHIP_SOC_RK3126C    (ROCKCHIP_CPU_RK312X | 0x20)
+#define ROCKCHIP_SOC_RK3128     (ROCKCHIP_CPU_RK312X | 0x01)
+#define ROCKCHIP_SOC_RK3288     (ROCKCHIP_CPU_RK3288 | 0x00)
+#define ROCKCHIP_SOC_RK3288W    (ROCKCHIP_CPU_RK3288 | 0x01)
+#define ROCKCHIP_SOC_RK3308	(ROCKCHIP_CPU_RK3308 | 0x00)
+#define ROCKCHIP_SOC_RK3308B	(ROCKCHIP_CPU_RK3308 | 0x01)
+#define ROCKCHIP_SOC_RK3308BS	(ROCKCHIP_CPU_RK3308 | 0x02)
+#define ROCKCHIP_SOC_RK3566	(ROCKCHIP_CPU_RK3566 | 0x00)
+#define ROCKCHIP_SOC_RK3568	(ROCKCHIP_CPU_RK3568 | 0x00)
+
+#define ROCKCHIP_SOC(CPU, id, ID) \
+static inline bool soc_is_##id(void) \
+{ \
+	if (!IS_ENABLED(CONFIG_CPU_##CPU)) \
+		return false; \
+	if (rockchip_soc_id) \
+		return ((rockchip_soc_id & ROCKCHIP_SOC_MASK) == ROCKCHIP_SOC_ ##ID); \
+	return of_machine_is_compatible("rockchip,"#id); \
+}
+
+ROCKCHIP_SOC(PX30, px30, PX30)
+ROCKCHIP_SOC(PX30, px30s, PX30S)
+ROCKCHIP_SOC(RV1106, rv1103, RV1103)
+ROCKCHIP_SOC(RV1106, rv1106, RV1106)
+ROCKCHIP_SOC(RV1126, rv1109, RV1109)
+ROCKCHIP_SOC(RV1126, rv1126, RV1126)
+ROCKCHIP_SOC(RK312X, rk3126, RK3126)
+ROCKCHIP_SOC(RK312X, rk3126b, RK3126B)
+ROCKCHIP_SOC(RK312X, rk3126c, RK3126C)
+ROCKCHIP_SOC(RK312X, rk3128, RK3128)
+ROCKCHIP_SOC(RK3288, rk3288, RK3288)
+ROCKCHIP_SOC(RK3288, rk3288w, RK3288W)
+ROCKCHIP_SOC(RK3308, rk3308, RK3308)
+ROCKCHIP_SOC(RK3308, rk3308b, RK3308B)
+ROCKCHIP_SOC(RK3308, rk3308bs, RK3308BS)
+ROCKCHIP_SOC(RK3568, rk3566, RK3566)
+ROCKCHIP_SOC(RK3568, rk3568, RK3568)
+
+#endif
diff --git a/include/linux/soc/rockchip/grf.h b/include/linux/soc/rockchip/grf.h
new file mode 100644
index 00000000000..fae51232297
--- /dev/null
+++ b/include/linux/soc/rockchip/grf.h
@@ -0,0 +1,700 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __MACH_ROCKCHIP_GRF_H
+#define __MACH_ROCKCHIP_GRF_H
+
+#define RK3188_GRF_GPIO0L_DIR           0x0000
+#define RK3188_GRF_GPIO0H_DIR           0x0004
+#define RK3188_GRF_GPIO1L_DIR           0x0008
+#define RK3188_GRF_GPIO1H_DIR           0x000c
+#define RK3188_GRF_GPIO2L_DIR           0x0010
+#define RK3188_GRF_GPIO2H_DIR           0x0014
+#define RK3188_GRF_GPIO3L_DIR           0x0018
+#define RK3188_GRF_GPIO3H_DIR           0x001c
+#define RK3188_GRF_GPIO0L_DO            0x0020
+#define RK3188_GRF_GPIO0H_DO            0x0024
+#define RK3188_GRF_GPIO1L_DO            0x0028
+#define RK3188_GRF_GPIO1H_DO            0x002c
+#define RK3188_GRF_GPIO2L_DO            0x0030
+#define RK3188_GRF_GPIO2H_DO            0x0034
+#define RK3188_GRF_GPIO3L_DO            0x0038
+#define RK3188_GRF_GPIO3H_DO            0x003c
+#define RK3188_GRF_GPIO0L_EN            0x0040
+#define RK3188_GRF_GPIO0H_EN            0x0044
+#define RK3188_GRF_GPIO1L_EN            0x0048
+#define RK3188_GRF_GPIO1H_EN            0x004c
+#define RK3188_GRF_GPIO2L_EN            0x0050
+#define RK3188_GRF_GPIO2H_EN            0x0054
+#define RK3188_GRF_GPIO3L_EN            0x0058
+#define RK3188_GRF_GPIO3H_EN            0x005c
+
+#define RK3188_GRF_GPIO0C_IOMUX         0x0068
+#define RK3188_GRF_GPIO0D_IOMUX         0x006c
+#define RK3188_GRF_GPIO1A_IOMUX         0x0070
+#define RK3188_GRF_GPIO1B_IOMUX         0x0074
+#define RK3188_GRF_GPIO1C_IOMUX         0x0078
+#define RK3188_GRF_GPIO1D_IOMUX         0x007c
+#define RK3188_GRF_GPIO2A_IOMUX         0x0080
+#define RK3188_GRF_GPIO2B_IOMUX         0x0084
+#define RK3188_GRF_GPIO2C_IOMUX         0x0088
+#define RK3188_GRF_GPIO2D_IOMUX         0x008c
+#define RK3188_GRF_GPIO3A_IOMUX         0x0090
+#define RK3188_GRF_GPIO3B_IOMUX         0x0094
+#define RK3188_GRF_GPIO3C_IOMUX         0x0098
+#define RK3188_GRF_GPIO3D_IOMUX         0x009c
+#define RK3188_GRF_SOC_CON0             0x00a0
+#define RK3188_GRF_SOC_CON1             0x00a4
+#define RK3188_GRF_SOC_CON2             0x00a8
+#define RK3188_GRF_SOC_STATUS0          0x00ac
+#define RK3188_GRF_DMAC1_CON0           0x00b0
+#define RK3188_GRF_DMAC1_CON1           0x00b4
+#define RK3188_GRF_DMAC1_CON2           0x00b8
+#define RK3188_GRF_DMAC2_CON0           0x00bc
+#define RK3188_GRF_DMAC2_CON1           0x00c0
+#define RK3188_GRF_DMAC2_CON2           0x00c4
+#define RK3188_GRF_DMAC2_CON3           0x00c8
+#define RK3188_GRF_CPU_CON0             0x00cc
+#define RK3188_GRF_CPU_CON1             0x00d0
+#define RK3188_GRF_CPU_CON2             0x00d4
+#define RK3188_GRF_CPU_CON3             0x00d8
+#define RK3188_GRF_CPU_CON4             0x00dc
+#define RK3188_GRF_CPU_CON5             0x00e0
+
+#define RK3188_GRF_DDRC_CON0            0x00ec
+#define RK3188_GRF_DDRC_STAT            0x00f0
+#define RK3188_GRF_IO_CON0              0x00f4
+#define RK3188_GRF_IO_CON1              0x00f8
+#define RK3188_GRF_IO_CON2              0x00fc
+#define RK3188_GRF_IO_CON3              0x0100
+#define RK3188_GRF_IO_CON4              0x0104
+#define RK3188_GRF_SOC_STATUS1          0x0108
+#define RK3188_GRF_UOC0_CON0            0x010c
+#define RK3188_GRF_UOC0_CON1            0x0110
+#define RK3188_GRF_UOC0_CON2            0x0114
+#define RK3188_GRF_UOC0_CON3            0x0118
+#define RK3188_GRF_UOC1_CON0            0x011c
+#define RK3188_GRF_UOC1_CON1            0x0120
+#define RK3188_GRF_UOC1_CON2            0x0124
+#define RK3188_GRF_UOC1_CON3            0x0128
+#define RK3188_GRF_UOC2_CON0            0x012c
+#define RK3188_GRF_UOC2_CON1            0x0130
+
+#define RK3188_GRF_UOC3_CON0            0x0138
+#define RK3188_GRF_UOC3_CON1            0x013c
+#define RK3188_GRF_EHCI_STAT            0x0140
+#define RK3188_GRF_OS_REG0              0x0144
+#define RK3188_GRF_OS_REG1              0x0148
+#define RK3188_GRF_OS_REG2              0x014c
+#define RK3188_GRF_OS_REG3              0x0150
+#define RK3188_GRF_OS_REG4              0x0154
+#define RK3188_GRF_OS_REG5              0x0158
+#define RK3188_GRF_OS_REG6              0x015c
+#define RK3188_GRF_OS_REG7              0x0160
+#define RK3188_GRF_GPIO0B_PULL          0x0164
+#define RK3188_GRF_GPIO0C_PULL          0x0168
+#define RK3188_GRF_GPIO0D_PULL          0x016c
+#define RK3188_GRF_GPIO1A_PULL          0x0170
+#define RK3188_GRF_GPIO1B_PULL          0x0174
+#define RK3188_GRF_GPIO1C_PULL          0x0178
+#define RK3188_GRF_GPIO1D_PULL          0x017c
+#define RK3188_GRF_GPIO2A_PULL          0x0180
+#define RK3188_GRF_GPIO2B_PULL          0x0184
+#define RK3188_GRF_GPIO2C_PULL          0x0188
+#define RK3188_GRF_GPIO2D_PULL          0x018c
+#define RK3188_GRF_GPIO3A_PULL          0x0190
+#define RK3188_GRF_GPIO3B_PULL          0x0194
+#define RK3188_GRF_GPIO3C_PULL          0x0198
+#define RK3188_GRF_GPIO3D_PULL          0x019c
+#define RK3188_GRF_FLASH_DATA_PULL      0x01a0
+#define RK3188_GRF_FLASH_CMD_PULL       0x01a4
+
+
+#define RK3288_GRF_GPIO0_A_IOMUX	0x0084
+#define RK3288_GRF_GPIO0_B_IOMUX	0x0088
+#define RK3288_GRF_GPIO0_C_IOMUX	0x008c
+
+#define RK3288_GRF_GPIO1D_IOMUX         0x000c
+#define RK3288_GRF_GPIO2A_IOMUX         0x0010
+#define RK3288_GRF_GPIO2B_IOMUX         0x0014
+#define RK3288_GRF_GPIO2C_IOMUX         0x0018
+
+#define RK3288_GRF_GPIO3A_IOMUX         0x0020
+#define RK3288_GRF_GPIO3B_IOMUX         0x0024
+#define RK3288_GRF_GPIO3C_IOMUX         0x0028
+#define RK3288_GRF_GPIO3DL_IOMUX        0x002c
+#define RK3288_GRF_GPIO3DH_IOMUX        0x0030
+#define RK3288_GRF_GPIO4AL_IOMUX        0x0034
+#define RK3288_GRF_GPIO4AH_IOMUX        0x0038
+#define RK3288_GRF_GPIO4BL_IOMUX        0x003c
+
+#define RK3288_GRF_GPIO4C_IOMUX         0x0044
+#define RK3288_GRF_GPIO4D_IOMUX         0x0048
+
+#define RK3288_GRF_GPIO5B_IOMUX         0x0050
+#define RK3288_GRF_GPIO5C_IOMUX         0x0054
+
+#define RK3288_GRF_GPIO6A_IOMUX         0x005c
+#define RK3288_GRF_GPIO6B_IOMUX         0x0060
+#define RK3288_GRF_GPIO6C_IOMUX         0x0064
+
+#define RK3288_GRF_GPIO7A_IOMUX         0x006c
+#define RK3288_GRF_GPIO7B_IOMUX         0x0070
+#define RK3288_GRF_GPIO7CL_IOMUX        0x0074
+#define RK3288_GRF_GPIO7CH_IOMUX        0x0078
+
+#define RK3288_GRF_GPIO8A_IOMUX         0x0080
+#define RK3288_GRF_GPIO8B_IOMUX         0x0084
+
+#define RK3288_GRF_GPIO1H_SR            0x0104
+#define RK3288_GRF_GPIO2L_SR            0x0108
+#define RK3288_GRF_GPIO2H_SR            0x010c
+#define RK3288_GRF_GPIO3L_SR            0x0110
+#define RK3288_GRF_GPIO3H_SR            0x0114
+#define RK3288_GRF_GPIO4L_SR            0x0118
+#define RK3288_GRF_GPIO4H_SR            0x011c
+#define RK3288_GRF_GPIO5L_SR            0x0120
+#define RK3288_GRF_GPIO5H_SR            0x0124
+#define RK3288_GRF_GPIO6L_SR            0x0128
+#define RK3288_GRF_GPIO6H_SR            0x012c
+#define RK3288_GRF_GPIO7L_SR            0x0130
+#define RK3288_GRF_GPIO7H_SR            0x0134
+#define RK3288_GRF_GPIO8L_SR            0x0138
+
+#define RK3288_GRF_GPIO1D_P             0x014c
+#define RK3288_GRF_GPIO2A_P             0x0150
+#define RK3288_GRF_GPIO2B_P             0x0154
+#define RK3288_GRF_GPIO2C_P             0x0158
+
+#define RK3288_GRF_GPIO3A_P             0x0160
+#define RK3288_GRF_GPIO3B_P             0x0164
+#define RK3288_GRF_GPIO3C_P             0x0168
+#define RK3288_GRF_GPIO3D_P             0x016c
+#define RK3288_GRF_GPIO4A_P             0x0170
+#define RK3288_GRF_GPIO4B_P             0x0174
+#define RK3288_GRF_GPIO4C_P             0x0178
+#define RK3288_GRF_GPIO4D_P             0x017c
+
+#define RK3288_GRF_GPIO5B_P             0x0184
+#define RK3288_GRF_GPIO5C_P             0x0188
+
+#define RK3288_GRF_GPIO6A_P             0x0190
+#define RK3288_GRF_GPIO6B_P             0x0194
+#define RK3288_GRF_GPIO6C_P             0x0198
+
+#define RK3288_GRF_GPIO7A_P             0x01a0
+#define RK3288_GRF_GPIO7B_P             0x01a4
+#define RK3288_GRF_GPIO7C_P             0x01a8
+
+#define RK3288_GRF_GPIO8A_P             0x01b0
+#define RK3288_GRF_GPIO8B_P             0x01b4
+
+#define RK3288_GRF_GPIO1D_E             0x01cc
+#define RK3288_GRF_GPIO2A_E             0x01d0
+#define RK3288_GRF_GPIO2B_E             0x01d4
+#define RK3288_GRF_GPIO2C_E             0x01d8
+
+#define RK3288_GRF_GPIO3A_E             0x01e0
+#define RK3288_GRF_GPIO3B_E             0x01e4
+#define RK3288_GRF_GPIO3C_E             0x01e8
+#define RK3288_GRF_GPIO3D_E             0x01ec
+#define RK3288_GRF_GPIO4A_E             0x01f0
+#define RK3288_GRF_GPIO4B_E             0x01f4
+#define RK3288_GRF_GPIO4C_E             0x01f8
+#define RK3288_GRF_GPIO4D_E             0x01fc
+
+#define RK3288_GRF_GPIO5B_E             0x0204
+#define RK3288_GRF_GPIO5C_E             0x0208
+
+#define RK3288_GRF_GPIO6A_E             0x0210
+#define RK3288_GRF_GPIO6B_E             0x0214
+#define RK3288_GRF_GPIO6C_E             0x0218
+
+#define RK3288_GRF_GPIO7A_E             0x0220
+#define RK3288_GRF_GPIO7B_E             0x0224
+#define RK3288_GRF_GPIO7C_E             0x0228
+
+#define RK3288_GRF_GPIO8A_E             0x0230
+#define RK3288_GRF_GPIO8B_E             0x0234
+
+#define RK3288_GRF_GPIO_SMT             0x0240
+#define RK3288_GRF_SOC_CON0             0x0244
+#define RK3288_GRF_SOC_CON1             0x0248
+#define RK3288_GRF_SOC_CON2             0x024c
+#define RK3288_GRF_SOC_CON3             0x0250
+#define RK3288_GRF_SOC_CON4             0x0254
+#define RK3288_GRF_SOC_CON5             0x0258
+#define RK3288_GRF_SOC_CON6             0x025c
+#define RK3288_GRF_SOC_CON7             0x0260
+#define RK3288_GRF_SOC_CON8             0x0264
+#define RK3288_GRF_SOC_CON9             0x0268
+#define RK3288_GRF_SOC_CON10            0x026c
+#define RK3288_GRF_SOC_CON11            0x0270
+#define RK3288_GRF_SOC_CON12            0x0274
+#define RK3288_GRF_SOC_CON13            0x0278
+#define RK3288_GRF_SOC_CON14            0x027c
+#define RK3288_GRF_SOC_STATUS0          0x0280
+#define RK3288_GRF_SOC_STATUS1          0x0284
+#define RK3288_GRF_SOC_STATUS2          0x0288
+#define RK3288_GRF_SOC_STATUS3          0x028c
+#define RK3288_GRF_SOC_STATUS4          0x0290
+#define RK3288_GRF_SOC_STATUS5          0x0294
+#define RK3288_GRF_SOC_STATUS6          0x0298
+#define RK3288_GRF_SOC_STATUS7          0x029c
+#define RK3288_GRF_SOC_STATUS8          0x02a0
+#define RK3288_GRF_SOC_STATUS9          0x02a4
+#define RK3288_GRF_SOC_STATUS10         0x02a8
+#define RK3288_GRF_SOC_STATUS11         0x02ac
+#define RK3288_GRF_SOC_STATUS12         0x02b0
+#define RK3288_GRF_SOC_STATUS13         0x02b4
+#define RK3288_GRF_SOC_STATUS14         0x02b8
+#define RK3288_GRF_SOC_STATUS15         0x02bc
+#define RK3288_GRF_SOC_STATUS16         0x02c0
+#define RK3288_GRF_SOC_STATUS17         0x02c4
+#define RK3288_GRF_SOC_STATUS18         0x02c8
+#define RK3288_GRF_SOC_STATUS19         0x02cc
+#define RK3288_GRF_SOC_STATUS20         0x02d0
+#define RK3288_GRF_SOC_STATUS21         0x02d4
+
+#define RK3288_GRF_PERIDMAC_CON0        0x02e0
+#define RK3288_GRF_PERIDMAC_CON1        0x02e4
+#define RK3288_GRF_PERIDMAC_CON2        0x02e8
+#define RK3288_GRF_PERIDMAC_CON3        0x02ec
+#define RK3288_GRF_DDRC0_CON0           0x02f0
+#define RK3288_GRF_DDRC1_CON0           0x02f4
+#define RK3288_GRF_CPU_CON0             0x02f8
+#define RK3288_GRF_CPU_CON1             0x02fc
+#define RK3288_GRF_CPU_CON2             0x0300
+#define RK3288_GRF_CPU_CON3             0x0304
+#define RK3288_GRF_CPU_CON4             0x0308
+
+#define RK3288_GRF_CPU_STATUS0          0x0318
+
+#define RK3288_GRF_UOC0_CON0            0x0320
+#define RK3288_GRF_UOC0_CON1            0x0324
+#define RK3288_GRF_UOC0_CON2            0x0328
+#define RK3288_GRF_UOC0_CON3            0x032c
+#define RK3288_GRF_UOC0_CON4            0x0330
+#define RK3288_GRF_UOC1_CON0            0x0334
+#define RK3288_GRF_UOC1_CON1            0x0338
+#define RK3288_GRF_UOC1_CON2            0x033c
+#define RK3288_GRF_UOC1_CON3            0x0340
+#define RK3288_GRF_UOC1_CON4            0x0344
+#define RK3288_GRF_UOC2_CON0            0x0348
+#define RK3288_GRF_UOC2_CON1            0x034c
+#define RK3288_GRF_UOC2_CON2            0x0350
+#define RK3288_GRF_UOC2_CON3            0x0354
+#define RK3288_GRF_UOC3_CON0            0x0358
+#define RK3288_GRF_UOC3_CON1            0x035c
+#define RK3288_GRF_UOC4_CON0            0x0360
+#define RK3288_GRF_UOC4_CON1            0x0364
+#define RK3288_GRF_PVTM_CON0            0x0368
+#define RK3288_GRF_PVTM_CON1            0x036c
+#define RK3288_GRF_PVTM_CON2            0x0370
+#define RK3288_GRF_PVTM_STATUS0         0x0374
+#define RK3288_GRF_PVTM_STATUS1         0x0378
+#define RK3288_GRF_PVTM_STATUS2         0x037c
+#define RK3288_GRF_IO_VSEL              0x0380
+#define RK3288_GRF_SARADC_TESTBIT       0x0384
+#define RK3288_GRF_TSADC_TESTBIT_L      0x0388
+#define RK3288_GRF_TSADC_TESTBIT_H      0x038c
+#define RK3288_GRF_OS_REG0              0x0390
+#define RK3288_GRF_OS_REG1              0x0394
+#define RK3288_GRF_OS_REG2              0x0398
+#define RK3288_GRF_OS_REG3              0x039c
+
+#define RK3288_GRF_SOC_CON15            0x03a4
+#define RK3288_GRF_SOC_CON16            0x03a8
+
+#define RK3288_SGRF_SOC_CON0            0x0000
+#define RK3288_SGRF_SOC_CON1            0x0004
+#define RK3288_SGRF_SOC_CON2            0x0008
+#define RK3288_SGRF_SOC_CON3            0x000c
+#define RK3288_SGRF_SOC_CON4            0x0010
+#define RK3288_SGRF_SOC_CON5            0x0014
+
+#define RK3288_SGRF_BUSDMAC_CON0        0x0020
+#define RK3288_SGRF_BUSDMAC_CON1        0x0024
+
+#define RK3288_SGRF_CPU_CON0            0x0040
+#define RK3288_SGRF_CPU_CON1            0x0044
+#define RK3288_SGRF_CPU_CON2            0x0048
+
+#define RK3288_SGRF_SOC_CON6            0x0050
+#define RK3288_SGRF_SOC_CON7            0x0054
+#define RK3288_SGRF_SOC_CON8            0x0058
+#define RK3288_SGRF_SOC_CON9            0x005c
+#define RK3288_SGRF_SOC_CON10           0x0060
+#define RK3288_SGRF_SOC_CON11           0x0064
+#define RK3288_SGRF_SOC_CON12           0x0068
+#define RK3288_SGRF_SOC_CON13           0x006c
+#define RK3288_SGRF_SOC_CON14           0x0070
+#define RK3288_SGRF_SOC_CON15           0x0074
+#define RK3288_SGRF_SOC_CON16           0x0078
+#define RK3288_SGRF_SOC_CON17           0x007c
+#define RK3288_SGRF_SOC_CON18           0x0080
+#define RK3288_SGRF_SOC_CON19           0x0084
+#define RK3288_SGRF_SOC_CON20           0x0088
+#define RK3288_SGRF_SOC_CON21           0x008c
+
+#define RK3288_SGRF_SOC_STATUS0         0x0100
+#define RK3288_SGRF_SOC_STATUS1         0x0104
+
+#define RK3288_SGRF_FAST_BOOT_ADDR      0x0120
+
+
+#define RK3036_GRF_GPIO0A_IOMUX         0x000a8
+#define RK3036_GRF_GPIO0B_IOMUX         0x000ac
+#define RK3036_GRF_GPIO0C_IOMUX         0x000b0
+#define RK3036_GRF_GPIO0D_IOMUX         0x000b4
+#define RK3036_GRF_GPIO1A_IOMUX         0x000b8
+#define RK3036_GRF_GPIO1B_IOMUX         0x000bc
+#define RK3036_GRF_GPIO1C_IOMUX         0x000c0
+#define RK3036_GRF_GPIO1D_IOMUX         0x000c4
+#define RK3036_GRF_GPIO2A_IOMUX         0x000c8
+#define RK3036_GRF_GPIO2B_IOMUX         0x000cc
+#define RK3036_GRF_GPIO2C_IOMUX         0x000d0
+#define RK3036_GRF_GPIO2D_IOMUX         0x000d4
+#define RK3036_GRF_GPIO_DS              0x00100
+#define RK3036_GRF_GPIO0L_PULL          0x00118
+#define RK3036_GRF_GPIO0H_PULL          0x0011c
+#define RK3036_GRF_GPIO1L_PULL          0x00120
+#define RK3036_GRF_GPIO1H_PULL          0x00124
+
+#define RK3036_GRF_GPIO2L_PULL 0x00128
+#define RK3036_GRF_GPIO2H_PULL 0x0012c
+#define RK3036_GRF_SOC_CON0 0x00140
+#define RK3036_GRF_SOC_CON1 0x00144
+#define RK3036_GRF_SOC_CON2 0x00148
+#define RK3036_GRF_SOC_STATUS0 0x0014c
+#define RK3036_GRF_SOC_CON3 0x00154
+#define RK3036_GRF_DMAC_CON0 0x0015c
+#define RK3036_GRF_DMAC_CON1 0x00160
+#define RK3036_GRF_DMAC_CON2 0x00164
+#define RK3036_GRF_UOC0_CON5 0x0017c
+#define RK3036_GRF_UOC1_CON4 0x00190
+#define RK3036_GRF_UOC1_CON5 0x00194
+#define RK3036_GRF_DDRC_STAT 0x0019c
+#define RK3036_GRF_UOC_CON6 0x001a0
+#define RK3036_GRF_SOC_STATUS1 0x001a4
+#define RK3036_GRF_CPU_CON0 0x001a8
+#define RK3036_GRF_CPU_CON1 0x001ac
+#define RK3036_GRF_CPU_CON2 0x001b0
+#define RK3036_GRF_CPU_CON3 0x001b4
+#define RK3036_GRF_CPU_STATUS0 0x001c0
+#define RK3036_GRF_CPU_STATUS1 0x001c4
+#define RK3036_GRF_OS_REG0 0x001c8
+#define RK3036_GRF_OS_REG1 0x001cc
+#define RK3036_GRF_OS_REG2 0x001d0
+#define RK3036_GRF_OS_REG3 0x001d4
+#define RK3036_GRF_OS_REG4 0x001d8
+#define RK3036_GRF_OS_REG5 0x001dc
+#define RK3036_GRF_OS_REG6 0x001e0
+#define RK3036_GRF_OS_REG7 0x001e4
+#define RK3036_GRF_DLL_CON0 0x00200
+#define RK3036_GRF_DLL_CON1 0x00204
+#define RK3036_GRF_DLL_CON2 0x00208
+#define RK3036_GRF_DLL_CON3 0x0020c
+#define RK3036_GRF_DLL_STATUS0 0x00210
+#define RK3036_GRF_DLL_STATUS1 0x00214
+
+#define RK3036_GRF_DLL_STATUS2 0x00218
+#define RK3036_GRF_DLL_STATUS3 0x0021c
+#define RK3036_GRF_DFI_WRNUM 0x00220
+#define RK3036_GRF_DFI_RDNUM 0x00224
+#define RK3036_GRF_DFI_ACTNUM 0x00228
+#define RK3036_GRF_DFI_TIMERVAL 0x0022c
+#define RK3036_GRF_NIF_FIFO0 0x00230
+#define RK3036_GRF_NIF_FIFO1 0x00234
+#define RK3036_GRF_NIF_FIFO2 0x00238
+#define RK3036_GRF_NIF_FIFO3 0x0023c
+#define RK3036_GRF_USBPHY0_CON0 0x00280
+#define RK3036_GRF_USBPHY0_CON1 0x00284
+#define RK3036_GRF_USBPHY0_CON2 0x00288
+#define RK3036_GRF_USBPHY0_CON3 0x0028c
+#define RK3036_GRF_USBPHY0_CON4 0x00290
+#define RK3036_GRF_USBPHY0_CON5 0x00294
+#define RK3036_GRF_USBPHY0_CON6 0x00298
+#define RK3036_GRF_USBPHY0_CON7 0x0029c
+#define RK3036_GRF_USBPHY1_CON0 0x002a0
+#define RK3036_GRF_USBPHY1_CON1 0x002a4
+#define RK3036_GRF_USBPHY1_CON2 0x002a8
+#define RK3036_GRF_USBPHY1_CON3 0x002ac
+#define RK3036_GRF_USBPHY1_CON4 0x002b0
+#define RK3036_GRF_USBPHY1_CON5 0x002b4
+#define RK3036_GRF_USBPHY1_CON6 0x002b8
+
+#define RK3036_GRF_USBPHY1_CON7 0x002bc
+#define RK3036_GRF_CHIP_TAG 0x00300
+#define RK3036_GRF_SDMMC_DET_CNT 0x00304
+
+#define RK312X_GRF_GPIO0A_IOMUX         0x000a8
+#define RK312X_GRF_GPIO0B_IOMUX         0x000ac
+#define RK312X_GRF_GPIO0C_IOMUX         0x000b0
+#define RK312X_GRF_GPIO0D_IOMUX         0x000b4
+#define RK312X_GRF_GPIO1A_IOMUX         0x000b8
+#define RK312X_GRF_GPIO1B_IOMUX         0x000bc
+#define RK312X_GRF_GPIO1C_IOMUX         0x000c0
+#define RK312X_GRF_GPIO1D_IOMUX         0x000c4
+#define RK312X_GRF_GPIO2A_IOMUX         0x000c8
+#define RK312X_GRF_GPIO2B_IOMUX         0x000cc
+#define RK312X_GRF_GPIO2C_IOMUX         0x000d0
+#define RK312X_GRF_GPIO2D_IOMUX         0x000d4
+#define RK312X_GRF_GPIO3A_IOMUX         0x000d8
+#define RK312X_GRF_GPIO3B_IOMUX         0x000dc
+#define RK312X_GRF_GPIO3C_IOMUX         0x000e0
+#define RK312X_GRF_GPIO3D_IOMUX         0x000e4
+#define RK312X_GRF_CIF_IOMUX		0x000ec
+#define RK312X_GRF_CIF_IOMUX1 		0x000f0
+#define RK312X_GRF_GPIO_DS              0x00100
+#define RK312X_GRF_GPIO0L_PULL          0x00118
+#define RK312X_GRF_GPIO0H_PULL          0x0011c
+#define RK312X_GRF_GPIO1L_PULL          0x00120
+#define RK312X_GRF_GPIO1H_PULL          0x00124
+#define RK312X_GRF_GPIO2L_PULL          0x00128
+#define RK312X_GRF_GPIO2H_PULL          0x0012c
+#define RK312X_GRF_GPIO3L_PULL          0x00130
+#define RK312X_GRF_GPIO3H_PULL          0x00134
+#define RK312X_GRF_ACODEC_CON		0x0013c
+
+#define RK312X_GRF_SOC_CON0 0x00140
+#define RK312X_GRF_SOC_CON1 0x00144
+#define RK312X_GRF_SOC_CON2 0x00148
+#define RK312X_GRF_SOC_STATUS0 0x0014c
+#define RK312X_GRF_LVDS_CON0 0x00150
+#define RK312X_GRF_SOC_CON3 0x00154
+#define RK312X_GRF_DMAC_CON0 0x0015c
+#define RK312X_GRF_DMAC_CON1 0x00160
+#define RK312X_GRF_DMAC_CON2 0x00164
+#define RK312X_GRF_MAC_CON0 0x00168
+#define RK312X_GRF_MAC_CON1 0x0016c
+#define RK312X_GRF_TVE_CON 0x00170
+#define RK312X_GRF_UOC0_CON0 0x0017c
+#define RK312X_GRF_UOC1_CON1 0x00184
+#define RK312X_GRF_UOC1_CON2 0x00188
+#define RK312X_GRF_UOC1_CON3 0x0018c
+#define RK312X_GRF_UOC1_CON4 0x00190
+#define RK312X_GRF_UOC1_CON5 0x00194
+#define RK312X_GRF_DDRC_STAT 0x0019c
+#define RK312X_GRF_SOC_STATUS1 0x001a4
+#define RK312X_GRF_CPU_CON0 0x001a8
+#define RK312X_GRF_CPU_CON1 0x001ac
+#define RK312X_GRF_CPU_CON2 0x001b0
+#define RK312X_GRF_CPU_CON3 0x001b4
+#define RK312X_GRF_CPU_STATUS0 0x001c0
+#define RK312X_GRF_CPU_STATUS1 0x001c4
+#define RK312X_GRF_OS_REG0 0x001c8
+#define RK312X_GRF_OS_REG1 0x001cc
+#define RK312X_GRF_OS_REG2 0x001d0
+#define RK312X_GRF_OS_REG3 0x001d4
+#define RK312X_GRF_OS_REG4 0x001d8
+#define RK312X_GRF_OS_REG5 0x001dc
+#define RK312X_GRF_OS_REG6 0x001e0
+#define RK312X_GRF_OS_REG7 0x001e4
+#define RK312X_GRF_PVTM_CON0 0x00200
+#define RK312X_GRF_PVTM_CON1 0x00204
+#define RK312X_GRF_PVTM_CON2 0x00208
+#define RK312X_GRF_PVTM_CON3 0x0020c
+#define RK312X_GRF_PVTM_STATUS0 0x00210
+#define RK312X_GRF_PVTM_STATUS1 0x00214
+#define RK312X_GRF_PVTM_STATUS2 0x00218
+#define RK312X_GRF_PVTM_STATUS3 0x0021c
+#define RK312X_GRF_DFI_WRNUM 0x00220
+#define RK312X_GRF_DFI_RDNUM 0x00224
+#define RK312X_GRF_DFI_ACTNUM 0x00228
+#define RK312X_GRF_DFI_TIMERVAL 0x0022c
+#define RK312X_GRF_NIF_FIFO0 0x00230
+#define RK312X_GRF_NIF_FIFO1 0x00234
+#define RK312X_GRF_NIF_FIFO2 0x00238
+#define RK312X_GRF_NIF_FIFO3 0x0023c
+#define RK312X_GRF_USBPHY0_CON0 0x00280
+#define RK312X_GRF_USBPHY0_CON1 0x00284
+#define RK312X_GRF_USBPHY0_CON2 0x00288
+#define RK312X_GRF_USBPHY0_CON3 0x0028c
+#define RK312X_GRF_USBPHY0_CON4 0x00290
+#define RK312X_GRF_USBPHY0_CON5 0x00294
+#define RK312X_GRF_USBPHY0_CON6 0x00298
+#define RK312X_GRF_USBPHY0_CON7 0x0029c
+#define RK312X_GRF_USBPHY1_CON0 0x002a0
+#define RK312X_GRF_USBPHY1_CON1 0x002a4
+#define RK312X_GRF_USBPHY1_CON2 0x002a8
+#define RK312X_GRF_USBPHY1_CON3 0x002ac
+#define RK312X_GRF_USBPHY1_CON4 0x002b0
+#define RK312X_GRF_USBPHY1_CON5 0x002b4
+#define RK312X_GRF_USBPHY1_CON6 0x002b8
+#define RK312X_GRF_USBPHY1_CON7 0x002bc
+#define RK312X_GRF_UOC_STATUS0 0x002c0
+#define RK312X_GRF_CHIP_TAG 0x00300
+#define RK312X_GRF_SDMMC_DET_CNT 0x00304
+#define RK312X_GRF_EFUSE_PRG_EN 0x0037c
+
+#define RK3228_GRF_GPIO0A_IOMUX		0x0000
+#define RK3228_GRF_GPIO0B_IOMUX		0x0004
+#define RK3228_GRF_GPIO0C_IOMUX		0x0008
+#define RK3228_GRF_GPIO0D_IOMUX		0x000c
+#define RK3228_GRF_GPIO1A_IOMUX		0x0010
+#define RK3228_GRF_GPIO1B_IOMUX		0x0014
+#define RK3228_GRF_GPIO1C_IOMUX		0x0018
+#define RK3228_GRF_GPIO1D_IOMUX		0x001c
+#define RK3228_GRF_GPIO2A_IOMUX		0x0020
+#define RK3228_GRF_GPIO2B_IOMUX		0x0024
+#define RK3228_GRF_GPIO2C_IOMUX		0x0028
+#define RK3228_GRF_GPIO2D_IOMUX		0x002c
+#define RK3228_GRF_GPIO3A_IOMUX		0x0030
+#define RK3228_GRF_GPIO3B_IOMUX		0x0034
+#define RK3228_GRF_GPIO3C_IOMUX		0x0038
+#define RK3228_GRF_GPIO3D_IOMUX		0x003c
+#define RK3228_GRF_COM_IOMUX		0x0050
+#define RK3228_GRF_GPIO0A_P		0x0100
+#define RK3228_GRF_GPIO0B_P		0x0104
+#define RK3228_GRF_GPIO0C_P		0x0108
+#define RK3228_GRF_GPIO0D_P		0x010c
+#define RK3228_GRF_GPIO1A_P		0x0110
+#define RK3228_GRF_GPIO1B_P		0x0114
+#define RK3228_GRF_GPIO1C_P		0x0118
+#define RK3228_GRF_GPIO1D_P		0x011c
+#define RK3228_GRF_GPIO2A_P		0x0120
+#define RK3228_GRF_GPIO2B_P		0x0124
+#define RK3228_GRF_GPIO2C_P		0x0128
+#define RK3228_GRF_GPIO2D_P		0x012c
+#define RK3228_GRF_GPIO3A_P		0x0130
+#define RK3228_GRF_GPIO3B_P		0x0134
+#define RK3228_GRF_GPIO3C_P		0x0138
+#define RK3228_GRF_GPIO3D_P		0x013c
+#define RK3228_GRF_GPIO0A_E		0x0200
+#define RK3228_GRF_GPIO0B_E		0x0204
+#define RK3228_GRF_GPIO0C_E		0x0208
+#define RK3228_GRF_GPIO0D_E		0x020c
+#define RK3228_GRF_GPIO1A_E		0x0210
+#define RK3228_GRF_GPIO1B_E		0x0214
+#define RK3228_GRF_GPIO1C_E		0x0218
+#define RK3228_GRF_GPIO1D_E		0x021c
+#define RK3228_GRF_GPIO2A_E		0x0220
+#define RK3228_GRF_GPIO2B_E		0x0224
+#define RK3228_GRF_GPIO2C_E		0x0228
+#define RK3228_GRF_GPIO2D_E		0x022c
+#define RK3228_GRF_GPIO3A_E		0x0230
+#define RK3228_GRF_GPIO3B_E		0x0234
+#define RK3228_GRF_GPIO3C_E		0x0238
+#define RK3228_GRF_GPIO3D_E		0x023c
+#define RK3228_GRF_GPIO0L_SR		0x0300
+#define RK3228_GRF_GPIO0H_SR		0x0304
+#define RK3228_GRF_GPIO1L_SR		0x0308
+#define RK3228_GRF_GPIO1H_SR		0x030c
+#define RK3228_GRF_GPIO2L_SR		0x0310
+#define RK3228_GRF_GPIO2H_SR		0x0314
+#define RK3228_GRF_GPIO3L_SR		0x0318
+#define RK3228_GRF_GPIO3H_SR		0x031c
+#define RK3228_GRF_GPIO0L_SMT		0x0380
+#define RK3228_GRF_GPIO0H_SMT		0x0384
+#define RK3228_GRF_GPIO1L_SMT		0x0388
+#define RK3228_GRF_GPIO1H_SMT		0x038c
+#define RK3228_GRF_GPIO2L_SMT		0x0390
+#define RK3228_GRF_GPIO2H_SMT		0x0394
+#define RK3228_GRF_GPIO3L_SMT		0x0398
+#define RK3228_GRF_GPIO3H_SMT		0x039c
+#define RK3228_GRF_SOC_CON0		0x0400
+#define RK3228_GRF_SOC_CON1		0x0404
+#define RK3228_GRF_SOC_CON2		0x0408
+#define RK3228_GRF_SOC_CON3		0x040c
+#define RK3228_GRF_SOC_CON4		0x0410
+#define RK3228_GRF_SOC_CON5		0x0414
+#define RK3228_GRF_SOC_CON6		0x0418
+#define RK3228_GRF_SOC_STATUS0		0x0480
+#define RK3228_GRF_SOC_STATUS1		0x0484
+#define RK3228_GRF_SOC_STATUS2		0x0488
+#define RK3228_GRF_CHIP_ID		0x048c
+#define RK3228_GRF_CPU_CON0		0x0500
+#define RK3228_GRF_CPU_CON1		0x0504
+#define RK3228_GRF_CPU_CON2		0x0508
+#define RK3228_GRF_CPU_CON3		0x050c
+#define RK3228_GRF_CPU_STATUS0		0x0520
+#define RK3228_GRF_CPU_STATUS1		0x0524
+#define RK3228_GRF_OS_REG0		0x05c8
+#define RK3228_GRF_OS_REG1		0x05cc
+#define RK3228_GRF_OS_REG2		0x05d0
+#define RK3228_GRF_OS_REG3		0x05d4
+#define RK3228_GRF_OS_REG4		0x05d8
+#define RK3228_GRF_OS_REG5		0x05dc
+#define RK3228_GRF_OS_REG6		0x05e0
+#define RK3228_GRF_OS_REG7		0x05e4
+#define RK3228_GRF_DDRC_STAT		0x0604
+#define RK3228_GRF_SIG_DETECT_CON	0x0680
+#define RK3228_GRF_SIG_DETECT_CON1	0x0684
+#define RK3228_GRF_SIG_DETECT_STATUS	0x0690
+#define RK3228_GRF_SIG_DETECT_STATUS1	0x0694
+#define RK3228_GRF_SIG_DETECT_CLR	0x06a0
+#define RK3228_GRF_SIG_DETECT_CLR1	0x06a4
+#define RK3228_GRF_EMMC_DET		0x06b0
+#define RK3228_GRF_HOST0_CON0		0x0700
+#define RK3228_GRF_HOST0_CON1		0x0704
+#define RK3228_GRF_HOST0_CON2		0x0708
+#define RK3228_GRF_HOST1_CON0		0x0710
+#define RK3228_GRF_HOST1_CON1		0x0714
+#define RK3228_GRF_HOST1_CON2		0x0718
+#define RK3228_GRF_HOST2_CON0		0x0720
+#define RK3228_GRF_HOST2_CON1		0x0724
+#define RK3228_GRF_HOST2_CON2		0x0728
+#define RK3228_GRF_USBPHY0_CON0		0x0760
+#define RK3228_GRF_USBPHY0_CON1		0x0764
+#define RK3228_GRF_USBPHY0_CON2		0x0768
+#define RK3228_GRF_USBPHY0_CON3		0x076c
+#define RK3228_GRF_USBPHY0_CON4		0x0770
+#define RK3228_GRF_USBPHY0_CON5		0x0774
+#define RK3228_GRF_USBPHY0_CON6		0x0778
+#define RK3228_GRF_USBPHY0_CON7		0x077c
+#define RK3228_GRF_USBPHY0_CON8		0x0780
+#define RK3228_GRF_USBPHY0_CON9		0x0784
+#define RK3228_GRF_USBPHY0_CON10	0x0788
+#define RK3228_GRF_USBPHY0_CON11	0x078c
+#define RK3228_GRF_USBPHY0_CON12	0x0790
+#define RK3228_GRF_USBPHY0_CON13	0x0794
+#define RK3228_GRF_USBPHY0_CON14	0x0798
+#define RK3228_GRF_USBPHY0_CON15	0x079c
+#define RK3228_GRF_USBPHY0_CON16	0x07a0
+#define RK3228_GRF_USBPHY0_CON17	0x07a4
+#define RK3228_GRF_USBPHY0_CON18	0x07a8
+#define RK3228_GRF_USBPHY0_CON19	0x07ac
+#define RK3228_GRF_USBPHY0_CON20	0x07b0
+#define RK3228_GRF_USBPHY0_CON21	0x07b4
+#define RK3228_GRF_USBPHY0_CON22	0x07b8
+#define RK3228_GRF_USBPHY0_CON23	0x07bc
+#define RK3228_GRF_USBPHY0_CON24	0x07c0
+#define RK3228_GRF_USBPHY0_CON25	0x07c4
+#define RK3228_GRF_USBPHY0_CON26	0x07c8
+#define RK3228_GRF_USBPHY1_CON0		0x0800
+#define RK3228_GRF_USBPHY1_CON1		0x0804
+#define RK3228_GRF_USBPHY1_CON2		0x0808
+#define RK3228_GRF_USBPHY1_CON3		0x080c
+#define RK3228_GRF_USBPHY1_CON4		0x0810
+#define RK3228_GRF_USBPHY1_CON5		0x0814
+#define RK3228_GRF_USBPHY1_CON6		0x0818
+#define RK3228_GRF_USBPHY1_CON7		0x081c
+#define RK3228_GRF_USBPHY1_CON8		0x0820
+#define RK3228_GRF_USBPHY1_CON9		0x0824
+#define RK3228_GRF_USBPHY1_CON10	0x0828
+#define RK3228_GRF_USBPHY1_CON11	0x082c
+#define RK3228_GRF_USBPHY1_CON12	0x0830
+#define RK3228_GRF_USBPHY1_CON13	0x0834
+#define RK3228_GRF_USBPHY1_CON14	0x0838
+#define RK3228_GRF_USBPHY1_CON15	0x083c
+#define RK3228_GRF_USBPHY1_CON16	0x0840
+#define RK3228_GRF_USBPHY1_CON17	0x0844
+#define RK3228_GRF_USBPHY1_CON18	0x0848
+#define RK3228_GRF_USBPHY1_CON19	0x084c
+#define RK3228_GRF_USBPHY1_CON20	0x0850
+#define RK3228_GRF_USBPHY1_CON21	0x0854
+#define RK3228_GRF_USBPHY1_CON22	0x0858
+#define RK3228_GRF_USBPHY1_CON23	0x085c
+#define RK3228_GRF_USBPHY1_CON24	0x0860
+#define RK3228_GRF_USBPHY1_CON25	0x0864
+#define RK3228_GRF_USBPHY1_CON26	0x0868
+#define RK3228_GRF_OTG_CON0		0x0880
+#define RK3228_GRF_UOC_CON0		0x0884
+#define RK3228_GRF_MAC_CON0		0x0900
+#define RK3228_GRF_MAC_CON1		0x0904
+#define RK3228_GRF_MACPHY_CON0		0x0b00
+#define RK3228_GRF_MACPHY_CON1		0x0b04
+#define RK3228_GRF_MACPHY_CON2		0x0b08
+#define RK3228_GRF_MACPHY_CON3		0x0b0c
+#define RK3228_GRF_MACPHY_STATUS	0x0b10
+
+#endif
diff --git a/include/linux/soc/rockchip/psci.h b/include/linux/soc/rockchip/psci.h
new file mode 100644
index 00000000000..870da27edf6
--- /dev/null
+++ b/include/linux/soc/rockchip/psci.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_PSCI_H
+#define __ROCKCHIP_PSCI_H
+
+#define SEC_REG_RD (0x0)
+#define SEC_REG_WR (0x1)
+
+/*
+ * trust firmware verison
+ */
+#define RKTF_VER_MAJOR(ver)		(((ver) >> 16) & 0xffff)
+#define RKTF_VER_MINOR(ver)		((ver) & 0xffff)
+
+/*
+ * pcsi smc funciton id
+ */
+#define PSCI_SIP_RKTF_VER		(0x82000001)
+#define PSCI_SIP_ACCESS_REG		(0x82000002)
+#define PSCI_SIP_ACCESS_REG64		(0xc2000002)
+#define PSCI_SIP_SUSPEND_WR_CTRBITS	(0x82000003)
+#define PSCI_SIP_PENDING_CPUS		(0x82000004)
+#define PSCI_SIP_UARTDBG_CFG		(0x82000005)
+#define PSCI_SIP_UARTDBG_CFG64		(0xc2000005)
+#define PSCI_SIP_EL3FIQ_CFG		(0x82000006)
+#define PSCI_SIP_SMEM_CONFIG		(0x82000007)
+
+/*
+ * pcsi smc funciton err code
+ */
+#define PSCI_SMC_FUNC_UNK		0xffffffff
+
+/*
+ * define PSCI_SIP_UARTDBG_CFG call type
+ */
+#define UARTDBG_CFG_INIT		0xf0
+#define UARTDBG_CFG_OSHDL_TO_OS		0xf1
+#define UARTDBG_CFG_OSHDL_CPUSW		0xf3
+#define UARTDBG_CFG_OSHDL_DEBUG_ENABLE	0xf4
+#define UARTDBG_CFG_OSHDL_DEBUG_DISABLE	0xf5
+
+/*
+ * rockchip psci function call interface
+ */
+
+u32 rockchip_psci_smc_read(u32 function_id, u32 arg0, u32 arg1, u32 arg2,
+			   u32 *val);
+u32 rockchip_psci_smc_write(u32 function_id, u32 arg0, u32 arg1, u32 arg2);
+
+u32 rockchip_psci_smc_get_tf_ver(void);
+u32 rockchip_secure_reg_read(u32 addr_phy);
+u32 rockchip_secure_reg_write(u32 addr_phy, u32 val);
+
+#ifdef CONFIG_ARM64
+u32 rockchip_psci_smc_write64(u64 function_id, u64 arg0, u64 arg1, u64 arg2);
+u32 rockchip_psci_smc_read64(u64 function_id, u64 arg0, u64 arg1, u64 arg2,
+			     u64 *val);
+u64 rockchip_secure_reg_read64(u64 addr_phy);
+u32 rockchip_secure_reg_write64(u64 addr_phy, u64 val);
+
+void psci_fiq_debugger_uart_irq_tf_cb(u64 sp_el1, u64 offset);
+#endif
+
+u32 psci_fiq_debugger_switch_cpu(u32 cpu);
+void psci_fiq_debugger_uart_irq_tf_init(u32 irq_id, void *callback);
+void psci_fiq_debugger_enable_debug(bool val);
+
+#if defined(CONFIG_ARM_PSCI) || defined(CONFIG_ARM64)
+u32 psci_set_memory_secure(bool val);
+#else
+static inline u32 psci_set_memory_secure(bool val)
+{
+	return 0;
+}
+#endif
+
+#endif /* __ROCKCHIP_PSCI_H */
diff --git a/include/linux/soc/rockchip/pvtm.h b/include/linux/soc/rockchip/pvtm.h
new file mode 100644
index 00000000000..3d2495cfd6e
--- /dev/null
+++ b/include/linux/soc/rockchip/pvtm.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __SOC_ROCKCHIP_PVTM_H
+#define __SOC_ROCKCHIP_PVTM_H
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_PVTM)
+u32 rockchip_get_pvtm_value(unsigned int id, unsigned int ring_sel,
+			    unsigned int time_us);
+#else
+static inline u32 rockchip_get_pvtm_value(unsigned int id,
+					  unsigned int ring_sel,
+					  unsigned int time_us)
+{
+	return 0;
+}
+#endif
+
+#endif /* __SOC_ROCKCHIP_PVTM_H */
diff --git a/include/linux/soc/rockchip/rockchip_sip.h b/include/linux/soc/rockchip/rockchip_sip.h
new file mode 100644
index 00000000000..8f5f7d3646b
--- /dev/null
+++ b/include/linux/soc/rockchip/rockchip_sip.h
@@ -0,0 +1,467 @@
+/* Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __ROCKCHIP_SIP_H
+#define __ROCKCHIP_SIP_H
+
+#include <linux/arm-smccc.h>
+#include <linux/io.h>
+
+/* SMC function IDs for SiP Service queries, compatible with kernel-3.10 */
+#define SIP_ATF_VERSION			0x82000001
+#define SIP_ACCESS_REG			0x82000002
+#define SIP_SUSPEND_MODE		0x82000003
+#define SIP_PENDING_CPUS		0x82000004
+#define SIP_UARTDBG_CFG			0x82000005
+#define SIP_UARTDBG_CFG64		0xc2000005
+#define SIP_MCU_EL3FIQ_CFG		0x82000006
+#define SIP_ACCESS_CHIP_STATE64		0xc2000006
+#define SIP_SECURE_MEM_CONFIG		0x82000007
+#define SIP_ACCESS_CHIP_EXTRA_STATE64	0xc2000007
+#define SIP_DRAM_CONFIG			0x82000008
+#define SIP_SHARE_MEM			0x82000009
+#define SIP_SIP_VERSION			0x8200000a
+#define SIP_REMOTECTL_CFG		0x8200000b
+#define PSCI_SIP_VPU_RESET		0x8200000c
+#define SIP_BUS_CFG			0x8200000d
+#define SIP_LAST_LOG			0x8200000e
+#define SIP_SCMI_AGENT0			0x82000010
+#define SIP_SCMI_AGENT1			0x82000011
+#define SIP_SCMI_AGENT2			0x82000012
+#define SIP_SCMI_AGENT3			0x82000013
+#define SIP_SCMI_AGENT4			0x82000014
+#define SIP_SCMI_AGENT5			0x82000015
+#define SIP_SCMI_AGENT6			0x82000016
+#define SIP_SCMI_AGENT7			0x82000017
+#define SIP_SCMI_AGENT8			0x82000018
+#define SIP_SCMI_AGENT9			0x82000019
+#define SIP_SCMI_AGENT10		0x8200001a
+#define SIP_SCMI_AGENT11		0x8200001b
+#define SIP_SCMI_AGENT12		0x8200001c
+#define SIP_SCMI_AGENT13		0x8200001d
+#define SIP_SCMI_AGENT14		0x8200001e
+#define SIP_SCMI_AGENT15		0x8200001f
+#define SIP_SDEI_FIQ_DBG_SWITCH_CPU	0x82000020
+#define SIP_SDEI_FIQ_DBG_GET_EVENT_ID	0x82000021
+#define RK_SIP_AMP_CFG			0x82000022
+#define RK_SIP_FIQ_CTRL			0x82000024
+#define SIP_HDCP_CONFIG			0x82000025
+#define SIP_WDT_CFG			0x82000026
+
+#define TRUSTED_OS_HDCPKEY_INIT		0xB7000003
+
+/* Rockchip Sip version */
+#define SIP_IMPLEMENT_V1                (1)
+#define SIP_IMPLEMENT_V2                (2)
+
+/* Trust firmware version */
+#define ATF_VER_MAJOR(ver)		(((ver) >> 16) & 0xffff)
+#define ATF_VER_MINOR(ver)		(((ver) >> 0) & 0xffff)
+
+/* SIP_ACCESS_REG: read or write */
+#define SECURE_REG_RD			0x0
+#define SECURE_REG_WR			0x1
+
+/* Fiq debugger share memory: 8KB enough */
+#define FIQ_UARTDBG_PAGE_NUMS		2
+#define FIQ_UARTDBG_SHARE_MEM_SIZE	((FIQ_UARTDBG_PAGE_NUMS) * 4096)
+
+/* Error return code */
+#define IS_SIP_ERROR(x)			(!!(x))
+
+#define SIP_RET_SUCCESS			0
+#define SIP_RET_SMC_UNKNOWN		-1
+#define SIP_RET_NOT_SUPPORTED		-2
+#define SIP_RET_INVALID_PARAMS		-3
+#define SIP_RET_INVALID_ADDRESS		-4
+#define SIP_RET_DENIED			-5
+#define SIP_RET_SET_RATE_TIMEOUT	-6
+
+/* SIP_UARTDBG_CFG64 call types */
+#define UARTDBG_CFG_INIT		0xf0
+#define UARTDBG_CFG_OSHDL_TO_OS		0xf1
+#define UARTDBG_CFG_OSHDL_CPUSW		0xf3
+#define UARTDBG_CFG_OSHDL_DEBUG_ENABLE	0xf4
+#define UARTDBG_CFG_OSHDL_DEBUG_DISABLE	0xf5
+#define UARTDBG_CFG_PRINT_PORT		0xf7
+#define UARTDBG_CFG_FIQ_ENABEL		0xf8
+#define UARTDBG_CFG_FIQ_DISABEL		0xf9
+
+/* SIP_SUSPEND_MODE32 call types */
+#define SUSPEND_MODE_CONFIG		0x01
+#define WKUP_SOURCE_CONFIG		0x02
+#define PWM_REGULATOR_CONFIG		0x03
+#define GPIO_POWER_CONFIG		0x04
+#define SUSPEND_DEBUG_ENABLE		0x05
+#define APIOS_SUSPEND_CONFIG		0x06
+#define VIRTUAL_POWEROFF		0x07
+#define SUSPEND_WFI_TIME_MS		0x08
+#define LINUX_PM_STATE			0x09
+#define SUSPEND_IO_RET_CONFIG		0x0a
+
+/* SIP_REMOTECTL_CFG call types */
+#define	REMOTECTL_SET_IRQ		0xf0
+#define REMOTECTL_SET_PWM_CH		0xf1
+#define REMOTECTL_SET_PWRKEY		0xf2
+#define REMOTECTL_GET_WAKEUP_STATE	0xf3
+#define REMOTECTL_ENABLE		0xf4
+/* wakeup state */
+#define REMOTECTL_PWRKEY_WAKEUP		0xdeadbeaf
+
+struct dram_addrmap_info {
+	u64 ch_mask[2];
+	u64 bk_mask[4];
+	u64 bg_mask[2];
+	u64 cs_mask[2];
+	u32 reserved[20];
+	u32 bank_bit_first;
+	u32 bank_bit_mask;
+};
+
+/* AMP Ctrl */
+enum {
+	RK_AMP_SUB_FUNC_CFG_MODE = 0,
+	RK_AMP_SUB_FUNC_BOOT_ARG01,
+	RK_AMP_SUB_FUNC_BOOT_ARG23,
+	RK_AMP_SUB_FUNC_REQ_CPU_OFF,
+	RK_AMP_SUB_FUNC_GET_CPU_STATUS,
+	RK_AMP_SUB_FUNC_RSV, /* for RTOS */
+	RK_AMP_SUB_FUNC_CPU_ON,
+	RK_AMP_SUB_FUNC_END,
+};
+
+enum {
+	FIRMWARE_NONE,
+	FIRMWARE_TEE_32BIT,
+	FIRMWARE_ATF_32BIT,
+	FIRMWARE_ATF_64BIT,
+	FIRMWARE_END,
+};
+
+/* Share mem page types */
+typedef enum {
+	SHARE_PAGE_TYPE_INVALID = 0,
+	SHARE_PAGE_TYPE_UARTDBG,
+	SHARE_PAGE_TYPE_DDR,
+	SHARE_PAGE_TYPE_DDRDBG,
+	SHARE_PAGE_TYPE_DDRECC,
+	SHARE_PAGE_TYPE_DDRFSP,
+	SHARE_PAGE_TYPE_DDR_ADDRMAP,
+	SHARE_PAGE_TYPE_LAST_LOG,
+	SHARE_PAGE_TYPE_HDCP,
+	SHARE_PAGE_TYPE_MAX,
+} share_page_type_t;
+
+/* fiq control sub func */
+enum {
+	RK_SIP_FIQ_CTRL_FIQ_EN = 1,
+	RK_SIP_FIQ_CTRL_FIQ_DIS,
+	RK_SIP_FIQ_CTRL_SET_AFF
+};
+
+/* hdcp function types */
+enum {
+	HDCP_FUNC_STORAGE_INCRYPT = 1,
+	HDCP_FUNC_KEY_LOAD,
+	HDCP_FUNC_ENCRYPT_MODE
+};
+
+/* support hdcp device list */
+enum {
+	DP_TX0,
+	DP_TX1,
+	EDP_TX0,
+	EDP_TX1,
+	HDMI_TX0,
+	HDMI_TX1,
+	HDMI_RX,
+	MAX_DEVICE,
+};
+
+/* SIP_WDT_CONFIG call types  */
+enum {
+	WDT_START = 0,
+	WDT_STOP = 1,
+	WDT_PING = 2,
+};
+
+/*
+ * Rules: struct arm_smccc_res contains result and data, details:
+ *
+ * a0: error code(0: success, !0: error);
+ * a1~a3: data
+ */
+#if IS_REACHABLE(CONFIG_ROCKCHIP_SIP)
+struct arm_smccc_res sip_smc_get_atf_version(void);
+struct arm_smccc_res sip_smc_get_sip_version(void);
+struct arm_smccc_res sip_smc_dram(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_request_share_mem(u32 page_num,
+					       share_page_type_t page_type);
+struct arm_smccc_res sip_smc_mcu_el3fiq(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_vpu_reset(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_get_suspend_info(u32 info);
+struct arm_smccc_res sip_smc_lastlog_request(void);
+
+int sip_smc_set_suspend_mode(u32 ctrl, u32 config1, u32 config2);
+int sip_smc_virtual_poweroff(void);
+int sip_smc_remotectl_config(u32 func, u32 data);
+
+int sip_smc_secure_reg_write(u32 addr_phy, u32 val);
+u32 sip_smc_secure_reg_read(u32 addr_phy);
+struct arm_smccc_res sip_smc_bus_config(u32 arg0, u32 arg1, u32 arg2);
+struct dram_addrmap_info *sip_smc_get_dram_map(void);
+int sip_smc_amp_config(u32 sub_func_id, u32 arg1, u32 arg2, u32 arg3);
+struct arm_smccc_res sip_smc_get_amp_info(u32 sub_func_id, u32 arg1);
+
+void __iomem *sip_hdcp_request_share_memory(int id);
+struct arm_smccc_res sip_hdcp_config(u32 arg0, u32 arg1, u32 arg2);
+ulong sip_cpu_logical_map_mpidr(u32 cpu);
+/***************************fiq debugger **************************************/
+void sip_fiq_debugger_enable_fiq(bool enable, uint32_t tgt_cpu);
+void sip_fiq_debugger_enable_debug(bool enable);
+int sip_fiq_debugger_uart_irq_tf_init(u32 irq_id, void *callback_fn);
+int sip_fiq_debugger_set_print_port(u32 port_phyaddr, u32 baudrate);
+int sip_fiq_debugger_request_share_memory(void);
+int sip_fiq_debugger_get_target_cpu(void);
+int sip_fiq_debugger_switch_cpu(u32 cpu);
+int sip_fiq_debugger_sdei_switch_cpu(u32 cur_cpu, u32 target_cpu, u32 flag);
+int sip_fiq_debugger_is_enabled(void);
+int sip_fiq_debugger_sdei_get_event_id(u32 *fiq, u32 *sw_cpu, u32 *flag);
+int sip_fiq_control(u32 sub_func, u32 irq, unsigned long data);
+int sip_wdt_config(u32 sub_func, u32 arg1, u32 arg2, u32 arg3);
+int sip_hdcpkey_init(u32 hdcp_id);
+#else
+static inline struct arm_smccc_res sip_smc_get_atf_version(void)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_get_sip_version(void)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_dram(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_request_share_mem
+			(u32 page_num, share_page_type_t page_type)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_mcu_el3fiq
+			(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res
+sip_smc_vpu_reset(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_get_suspend_info(u32 info)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_lastlog_request(void)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline int sip_smc_set_suspend_mode(u32 ctrl, u32 config1, u32 config2)
+{
+	return 0;
+}
+
+static inline int sip_smc_virtual_poweroff(void) { return 0; }
+static inline int sip_smc_remotectl_config(u32 func, u32 data) { return 0; }
+static inline int sip_smc_secure_reg_write(u32 addr_phy, u32 val) { return 0; }
+static inline u32 sip_smc_secure_reg_read(u32 addr_phy) { return 0; }
+
+static inline struct arm_smccc_res sip_smc_bus_config(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct dram_addrmap_info *sip_smc_get_dram_map(void)
+{
+	return NULL;
+}
+
+static inline int sip_smc_amp_config(u32 sub_func_id,
+				     u32 arg1,
+				     u32 arg2,
+				     u32 arg3)
+{
+	return 0;
+}
+
+static inline struct arm_smccc_res sip_smc_get_amp_info(u32 sub_func_id,
+							u32 arg1)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED, };
+
+	return tmp;
+}
+
+static inline void __iomem *sip_hdcp_request_share_memory(int id)
+{
+	return NULL;
+}
+
+static inline struct arm_smccc_res sip_hdcp_config(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+
+	return tmp;
+}
+
+static inline ulong sip_cpu_logical_map_mpidr(u32 cpu) { return 0; }
+
+/***************************fiq debugger **************************************/
+static inline void sip_fiq_debugger_enable_fiq
+			(bool enable, uint32_t tgt_cpu) { return; }
+
+static inline void sip_fiq_debugger_enable_debug(bool enable) { return; }
+static inline int sip_fiq_debugger_uart_irq_tf_init(u32 irq_id,
+						    void *callback_fn)
+{
+	return 0;
+}
+
+static inline int sip_fiq_debugger_set_print_port(u32 port_phyaddr,
+						  u32 baudrate)
+{
+	return 0;
+}
+
+static inline int sip_fiq_debugger_request_share_memory(void) { return 0; }
+static inline int sip_fiq_debugger_get_target_cpu(void) { return 0; }
+static inline int sip_fiq_debugger_switch_cpu(u32 cpu) { return 0; }
+static inline int sip_fiq_debugger_sdei_switch_cpu(u32 cur_cpu, u32 target_cpu,
+						   u32 flag) { return 0; }
+static inline int sip_fiq_debugger_is_enabled(void) { return 0; }
+static inline int sip_fiq_debugger_sdei_get_event_id(u32 *fiq, u32 *sw_cpu, u32 *flag)
+{
+	return SIP_RET_NOT_SUPPORTED;
+}
+
+static inline int sip_fiq_control(u32 sub_func, u32 irq, unsigned long data)
+{
+	return 0;
+}
+
+static inline int sip_wdt_config(u32 sub_func,
+				 u32 arg1,
+				 u32 arg2,
+				 u32 arg3)
+{
+	return 0;
+}
+
+static inline int sip_hdcpkey_init(u32 hdcp_id)
+{
+	return 0;
+}
+#endif
+
+/* 32-bit OP-TEE context, never change order of members! */
+struct sm_nsec_ctx {
+	u32 usr_sp;
+	u32 usr_lr;
+	u32 irq_spsr;
+	u32 irq_sp;
+	u32 irq_lr;
+	u32 fiq_spsr;
+	u32 fiq_sp;
+	u32 fiq_lr;
+	u32 svc_spsr;
+	u32 svc_sp;
+	u32 svc_lr;
+	u32 abt_spsr;
+	u32 abt_sp;
+	u32 abt_lr;
+	u32 und_spsr;
+	u32 und_sp;
+	u32 und_lr;
+	u32 mon_lr;
+	u32 mon_spsr;
+	u32 r4;
+	u32 r5;
+	u32 r6;
+	u32 r7;
+	u32 r8;
+	u32 r9;
+	u32 r10;
+	u32 r11;
+	u32 r12;
+	u32 r0;
+	u32 r1;
+	u32 r2;
+	u32 r3;
+};
+
+/* 64-bit ATF context, never change order of members! */
+struct gp_regs_ctx {
+	u64 x0;
+	u64 x1;
+	u64 x2;
+	u64 x3;
+	u64 x4;
+	u64 x5;
+	u64 x6;
+	u64 x7;
+	u64 x8;
+	u64 x9;
+	u64 x10;
+	u64 x11;
+	u64 x12;
+	u64 x13;
+	u64 x14;
+	u64 x15;
+	u64 x16;
+	u64 x17;
+	u64 x18;
+	u64 x19;
+	u64 x20;
+	u64 x21;
+	u64 x22;
+	u64 x23;
+	u64 x24;
+	u64 x25;
+	u64 x26;
+	u64 x27;
+	u64 x28;
+	u64 x29;
+	u64 lr;
+	u64 sp_el0;
+	u64 scr_el3;
+	u64 runtime_sp;
+	u64 spsr_el3;
+	u64 elr_el3;
+};
+
+#endif
diff --git a/include/soc/rockchip/rockchip-system-status.h b/include/soc/rockchip/rockchip-system-status.h
new file mode 100644
index 00000000000..200b1ee8960
--- /dev/null
+++ b/include/soc/rockchip/rockchip-system-status.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (C) 2019, Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __SOC_ROCKCHIP_SYSTEM_STATUS_H
+#define __SOC_ROCKCHIP_SYSTEM_STATUS_H
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_SYSTEM_MONITOR)
+int rockchip_register_system_status_notifier(struct notifier_block *nb);
+int rockchip_unregister_system_status_notifier(struct notifier_block *nb);
+void rockchip_set_system_status(unsigned long status);
+void rockchip_clear_system_status(unsigned long status);
+unsigned long rockchip_get_system_status(void);
+int rockchip_add_system_status_interface(struct device *dev);
+void rockchip_update_system_status(const char *buf);
+#else
+static inline int
+rockchip_register_system_status_notifier(struct notifier_block *nb)
+{
+	return -ENOTSUPP;
+};
+
+static inline int
+rockchip_unregister_system_status_notifier(struct notifier_block *nb)
+{
+	return -ENOTSUPP;
+};
+
+static inline void rockchip_set_system_status(unsigned long status)
+{
+};
+
+static inline void rockchip_clear_system_status(unsigned long status)
+{
+};
+
+static inline unsigned long rockchip_get_system_status(void)
+{
+	return 0;
+};
+
+static inline int rockchip_add_system_status_interface(struct device *dev)
+{
+	return -ENOTSUPP;
+};
+
+static inline void rockchip_update_system_status(const char *buf)
+{
+};
+#endif /* CONFIG_ROCKCHIP_SYSTEM_MONITOR */
+
+#endif
diff --git a/include/soc/rockchip/rockchip_dmc.h b/include/soc/rockchip/rockchip_dmc.h
new file mode 100644
index 00000000000..882aa268ac8
--- /dev/null
+++ b/include/soc/rockchip/rockchip_dmc.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#ifndef __SOC_ROCKCHIP_DMC_H
+#define __SOC_ROCKCHIP_DMC_H
+
+#include <linux/devfreq.h>
+
+/* for lcdc_type */
+#define SCREEN_NULL		0
+#define SCREEN_RGB		1
+#define SCREEN_LVDS		2
+#define SCREEN_DUAL_LVDS	3
+#define SCREEN_MCU		4
+#define SCREEN_TVOUT		5
+#define SCREEN_HDMI		6
+#define SCREEN_MIPI		7
+#define SCREEN_DUAL_MIPI	8
+#define SCREEN_EDP		9
+#define SCREEN_TVOUT_TEST	10
+#define SCREEN_LVDS_10BIT	11
+#define SCREEN_DUAL_LVDS_10BIT	12
+#define SCREEN_DP		13
+
+#define DMCFREQ_TABLE_END	~1u
+
+struct freq_map_table {
+	unsigned int min;
+	unsigned int max;
+	unsigned long freq;
+};
+
+struct rl_map_table {
+	unsigned int pn; /* panel number */
+	unsigned int rl; /* readlatency */
+};
+
+struct dmcfreq_common_info {
+	struct device *dev;
+	struct devfreq *devfreq;
+	struct freq_map_table *vop_bw_tbl;
+	struct freq_map_table *vop_frame_bw_tbl;
+	struct rl_map_table *vop_pn_rl_tbl;
+	struct delayed_work msch_rl_work;
+	unsigned long vop_req_rate;
+	unsigned int read_latency;
+	unsigned int auto_freq_en;
+	bool is_msch_rl_work_started;
+	int (*set_msch_readlatency)(unsigned int rl);
+};
+
+struct dmcfreq_vop_info {
+	unsigned int line_bw_mbyte;
+	unsigned int frame_bw_mbyte;
+	unsigned int plane_num;
+};
+
+#if IS_REACHABLE(CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ)
+void rockchip_dmcfreq_lock(void);
+void rockchip_dmcfreq_lock_nested(void);
+void rockchip_dmcfreq_unlock(void);
+int rockchip_dmcfreq_write_trylock(void);
+void rockchip_dmcfreq_write_unlock(void);
+int rockchip_dmcfreq_wait_complete(void);
+int rockchip_dmcfreq_vop_bandwidth_init(struct dmcfreq_common_info *info);
+int rockchip_dmcfreq_vop_bandwidth_request(struct dmcfreq_vop_info *vop_info);
+void rockchip_dmcfreq_vop_bandwidth_update(struct dmcfreq_vop_info *vop_info);
+#else
+static inline void rockchip_dmcfreq_lock(void)
+{
+}
+
+static inline void rockchip_dmcfreq_lock_nested(void)
+{
+}
+
+static inline void rockchip_dmcfreq_unlock(void)
+{
+}
+
+static inline int rockchip_dmcfreq_write_trylock(void)
+{
+	return 0;
+}
+
+static inline void rockchip_dmcfreq_write_unlock(void)
+{
+}
+
+static inline int rockchip_dmcfreq_wait_complete(void)
+{
+	return 0;
+}
+
+static inline int
+rockchip_dmcfreq_vop_bandwidth_request(struct dmcfreq_vop_info *vop_info)
+{
+	return 0;
+}
+
+static inline void
+rockchip_dmcfreq_vop_bandwidth_update(struct dmcfreq_vop_info *vop_info)
+{
+}
+
+static inline void
+rockchip_dmcfreq_vop_bandwidth_init(struct dmcfreq_common_info *info)
+{
+}
+#endif
+
+#endif
diff --git a/include/soc/rockchip/rockchip_ipa.h b/include/soc/rockchip/rockchip_ipa.h
new file mode 100644
index 00000000000..cb333f463c7
--- /dev/null
+++ b/include/soc/rockchip/rockchip_ipa.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#ifndef __SOC_ROCKCHIP_IPA_H
+#define __SOC_ROCKCHIP_IPA_H
+
+struct ipa_power_model_data {
+	u32 static_coefficient;
+	u32 dynamic_coefficient;
+	s32 ts[4];			/* temperature scaling factor */
+	struct thermal_zone_device *tz;
+	u32 leakage;
+	u32 ref_leakage;
+	u32 lkg_range[2];		/* min leakage and max leakage */
+	s32 ls[3];			/* leakage scaling factor */
+};
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_IPA)
+struct ipa_power_model_data *rockchip_ipa_power_model_init(struct device *dev,
+							   char *lkg_name);
+unsigned long
+rockchip_ipa_get_static_power(struct ipa_power_model_data *model_data,
+			      unsigned long voltage_mv);
+#else
+static inline struct ipa_power_model_data *
+rockchip_ipa_power_model_init(struct device *dev, char *lkg_name)
+{
+	return ERR_PTR(-ENOTSUPP);
+};
+
+static inline unsigned long
+rockchip_ipa_get_static_power(struct ipa_power_model_data *data,
+			      unsigned long voltage_mv)
+{
+	return 0;
+}
+#endif /* CONFIG_ROCKCHIP_IPA */
+
+#endif
diff --git a/include/soc/rockchip/rockchip_opp_select.h b/include/soc/rockchip/rockchip_opp_select.h
new file mode 100644
index 00000000000..0580db6955d
--- /dev/null
+++ b/include/soc/rockchip/rockchip_opp_select.h
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef __SOC_ROCKCHIP_OPP_SELECT_H
+#define __SOC_ROCKCHIP_OPP_SELECT_H
+
+#define VOLT_RM_TABLE_END	~1
+
+#define OPP_INTERMEDIATE_MASK	0x3f
+#define OPP_INTERMEDIATE_RATE	BIT(0)
+#define OPP_SCALING_UP_RATE	BIT(1)
+#define OPP_SCALING_UP_INTER	(OPP_INTERMEDIATE_RATE | OPP_SCALING_UP_RATE)
+#define OPP_SCALING_DOWN_INTER	OPP_INTERMEDIATE_RATE
+#define OPP_LENGTH_LOW		BIT(2)
+
+struct rockchip_opp_info;
+
+struct volt_rm_table {
+	int volt;
+	int rm;
+};
+
+struct rockchip_opp_data {
+	int (*get_soc_info)(struct device *dev, struct device_node *np,
+			    int *bin, int *process);
+	int (*set_soc_info)(struct device *dev, struct device_node *np,
+			    int bin, int process, int volt_sel);
+	int (*set_read_margin)(struct device *dev,
+			       struct rockchip_opp_info *opp_info,
+			       u32 rm);
+};
+
+struct pvtpll_opp_table {
+	unsigned long rate;
+	unsigned long u_volt;
+	unsigned long u_volt_min;
+	unsigned long u_volt_max;
+};
+
+struct rockchip_opp_info {
+	struct device *dev;
+	struct pvtpll_opp_table *opp_table;
+	const struct rockchip_opp_data *data;
+	struct volt_rm_table *volt_rm_tbl;
+	struct regmap *grf;
+	struct regmap *dsu_grf;
+	struct clk_bulk_data *clks;
+	struct clk *scmi_clk;
+	/* The threshold frequency for set intermediate rate */
+	unsigned long intermediate_threshold_freq;
+	unsigned int pvtpll_avg_offset;
+	unsigned int pvtpll_min_rate;
+	unsigned int pvtpll_volt_step;
+	int num_clks;
+	/* The read margin for low voltage */
+	u32 low_rm;
+	u32 current_rm;
+	u32 target_rm;
+};
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_OPP)
+int rockchip_of_get_leakage(struct device *dev, char *lkg_name, int *leakage);
+void rockchip_of_get_lkg_sel(struct device *dev, struct device_node *np,
+			     char *lkg_name, int process,
+			     int *volt_sel, int *scale_sel);
+void rockchip_pvtpll_calibrate_opp(struct rockchip_opp_info *info);
+void rockchip_of_get_pvtm_sel(struct device *dev, struct device_node *np,
+			      char *reg_name, int process,
+			      int *volt_sel, int *scale_sel);
+void rockchip_of_get_bin_sel(struct device *dev, struct device_node *np,
+			     int bin, int *scale_sel);
+void rockchip_of_get_bin_volt_sel(struct device *dev, struct device_node *np,
+				  int bin, int *bin_volt_sel);
+int rockchip_nvmem_cell_read_u8(struct device_node *np, const char *cell_id,
+				u8 *val);
+int rockchip_nvmem_cell_read_u16(struct device_node *np, const char *cell_id,
+				 u16 *val);
+int rockchip_get_volt_rm_table(struct device *dev, struct device_node *np,
+			       char *porp_name, struct volt_rm_table **table);
+void rockchip_get_opp_data(const struct of_device_id *matches,
+			   struct rockchip_opp_info *info);
+void rockchip_get_scale_volt_sel(struct device *dev, char *lkg_name,
+				 char *reg_name, int bin, int process,
+				 int *scale, int *volt_sel);
+int rockchip_set_opp_prop_name(struct device *dev, int process,
+					     int volt_sel);
+int rockchip_adjust_power_scale(struct device *dev, int scale);
+int rockchip_get_read_margin(struct device *dev,
+			     struct rockchip_opp_info *opp_info,
+			     unsigned long volt, u32 *target_rm);
+int rockchip_set_read_margin(struct device *dev,
+			     struct rockchip_opp_info *opp_info, u32 rm,
+			     bool is_set_rm);
+int rockchip_set_intermediate_rate(struct device *dev,
+				   struct rockchip_opp_info *opp_info,
+				   struct clk *clk, unsigned long old_freq,
+				   unsigned long new_freq, bool is_scaling_up,
+				   bool is_set_clk);
+int rockchip_init_opp_table(struct device *dev,
+			    struct rockchip_opp_info *info,
+			    char *lkg_name, char *reg_name);
+#else
+static inline int rockchip_of_get_leakage(struct device *dev, char *lkg_name,
+					  int *leakage)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void rockchip_of_get_lkg_sel(struct device *dev,
+					   struct device_node *np,
+					   char *lkg_name, int process,
+					   int *volt_sel, int *scale_sel)
+{
+}
+
+static inline void rockchip_pvtpll_calibrate_opp(struct rockchip_opp_info *info)
+{
+}
+
+static inline void rockchip_of_get_pvtm_sel(struct device *dev,
+					    struct device_node *np,
+					    char *reg_name, int process,
+					    int *volt_sel, int *scale_sel)
+{
+}
+
+static inline void rockchip_of_get_bin_sel(struct device *dev,
+					   struct device_node *np, int bin,
+					   int *scale_sel)
+{
+}
+
+static inline void rockchip_of_get_bin_volt_sel(struct device *dev,
+						struct device_node *np,
+						int bin, int *bin_volt_sel)
+{
+}
+
+static inline int rockchip_nvmem_cell_read_u8(struct device_node *np,
+					      const char *cell_id, u8 *val)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int rockchip_nvmem_cell_read_u16(struct device_node *np,
+					       const char *cell_id, u16 *val)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int rockchip_get_volt_rm_table(struct device *dev,
+					     struct device_node *np,
+					     char *porp_name,
+					     struct volt_rm_table **table)
+{
+	return -EOPNOTSUPP;
+
+}
+
+static inline void rockchip_get_opp_data(const struct of_device_id *matches,
+					 struct rockchip_opp_info *info)
+{
+}
+
+static inline void rockchip_get_scale_volt_sel(struct device *dev,
+					       char *lkg_name, char *reg_name,
+					       int bin, int process, int *scale,
+					       int *volt_sel)
+{
+}
+
+static inline struct opp_table *rockchip_set_opp_prop_name(struct device *dev,
+							   int process,
+							   int volt_sel)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
+static inline int rockchip_adjust_power_scale(struct device *dev, int scale)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int rockchip_get_read_margin(struct device *dev,
+					   struct rockchip_opp_info *opp_info,
+					   unsigned long volt, u32 *target_rm)
+{
+	return -EOPNOTSUPP;
+}
+static inline int rockchip_set_read_margin(struct device *dev,
+					   struct rockchip_opp_info *opp_info,
+					   u32 rm, bool is_set_rm)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int
+rockchip_set_intermediate_rate(struct device *dev,
+			       struct rockchip_opp_info *opp_info,
+			       struct clk *clk, unsigned long old_freq,
+			       unsigned long new_freq, bool is_scaling_up,
+			       bool is_set_clk)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int rockchip_init_opp_table(struct device *dev,
+					  struct rockchip_opp_info *info,
+					  char *lkg_name, char *reg_name)
+{
+	return -EOPNOTSUPP;
+}
+
+#endif /* CONFIG_ROCKCHIP_OPP */
+
+#endif
diff --git a/include/soc/rockchip/rockchip_system_monitor.h b/include/soc/rockchip/rockchip_system_monitor.h
new file mode 100644
index 00000000000..a8f50065116
--- /dev/null
+++ b/include/soc/rockchip/rockchip_system_monitor.h
@@ -0,0 +1,213 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (C) 2019, Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __SOC_ROCKCHIP_SYSTEM_MONITOR_H
+#define __SOC_ROCKCHIP_SYSTEM_MONITOR_H
+
+enum monitor_dev_type {
+	MONITOR_TPYE_CPU = 0,	/* CPU */
+	MONITOR_TPYE_DEV,	/* GPU, NPU, DMC, and so on */
+};
+
+struct volt_adjust_table {
+	unsigned int min;	/* Minimum frequency in MHz */
+	unsigned int max;	/* Maximum frequency in MHz */
+	int volt;		/* Voltage in microvolt */
+};
+
+struct temp_freq_table {
+	int temp;		/* millicelsius */
+	unsigned int freq;	/* KHz */
+};
+
+/**
+ * struct temp_opp_table - System monitor device OPP description structure
+ * @rate:		Frequency in hertz
+ * @volt:		Target voltage in microvolt
+ * @mem_volt:		Target voltage for memory in microvolt
+ * @low_temp_volt:	Target voltage when low temperature, in microvolt
+ * @low_temp_mem_volt:	Target voltage for memory when low temperature,
+ *			in microvolt
+ * @max_volt:		Maximum voltage in microvolt
+ * @max_mem_volt:	Maximum voltage for memory in microvolt
+ */
+struct temp_opp_table {
+	unsigned long rate;
+	unsigned long volt;
+	unsigned long mem_volt;
+	unsigned long low_temp_volt;
+	unsigned long low_temp_mem_volt;
+	unsigned long max_volt;
+	unsigned long max_mem_volt;
+};
+
+/**
+ * struct monitor_dev_info - structure for a system monitor device
+ * @dev:		Device registered by system monitor
+ * @low_temp_adjust_table:	Voltage margin for different OPPs when lowe
+ *				temperature
+ * @opp_table:		Frequency and voltage information of device
+ * @devp:		Device-specific system monitor profile
+ * @node:		Node in monitor_dev_list
+ * @high_limit_table:	Limit maximum frequency at different temperature,
+ *			but the frequency is also changed by thermal framework.
+ * @volt_adjust_mutex:	A mutex to protect changing voltage.
+ * @max_temp_freq_req:	CPU maximum frequency constraint changed according
+ *			to temperature.
+ * @min_sta_freq_req:   CPU minimum frequency constraint changed according
+ *			to system status.
+ * @max_sta_freq_req:   CPU maximum frequency constraint changed according
+ *			to system status.
+ * @dev_max_freq_req:	Devices maximum frequency constraint changed according
+ *			to temperature.
+ * @low_limit:		Limit maximum frequency when low temperature, in Hz
+ * @high_limit:		Limit maximum frequency when high temperature, in Hz
+ * @max_volt:		Maximum voltage in microvolt
+ * @low_temp_min_volt:	Minimum voltage of OPPs when low temperature, in
+ *			microvolt
+ * @high_temp_max_volt:	Maximum voltage when high temperature, in microvolt
+ * @wide_temp_limit:	Target maximum frequency when low or high temperature,
+ *			in Hz
+ * @video_4k_freq:	Maximum frequency when paly 4k video, in KHz
+ * @reboot_freq:	Limit maximum and minimum frequency when reboot, in KHz
+ * @status_min_limit:	Minimum frequency of some status frequency, in KHz
+ * @status_max_limit:	Minimum frequency of all status frequency, in KHz
+ * @low_temp:		Low temperature trip point, in millicelsius
+ * @high_temp:		High temperature trip point, in millicelsius
+ * @temp_hysteresis:	A low hysteresis value on low_temp, in millicelsius
+ * @is_low_temp:	True if current temperature less than low_temp
+ * @is_high_temp:	True if current temperature greater than high_temp
+ * @is_low_temp_enabled:	True if device node contains low temperature
+ *				configuration
+ * @is_status_freq_fixed:	True if enter into some status
+ */
+struct monitor_dev_info {
+	struct device *dev;
+	struct volt_adjust_table *low_temp_adjust_table;
+	struct temp_opp_table *opp_table;
+	struct monitor_dev_profile *devp;
+	struct list_head node;
+	struct temp_freq_table *high_limit_table;
+	struct mutex volt_adjust_mutex;
+	struct freq_qos_request max_temp_freq_req;
+	struct freq_qos_request min_sta_freq_req;
+	struct freq_qos_request max_sta_freq_req;
+	struct dev_pm_qos_request dev_max_freq_req;
+	struct regulator *early_reg;
+	struct regulator **regulators;
+	struct dev_pm_set_opp_data *set_opp_data;
+	struct clk *clk;
+	unsigned long low_limit;
+	unsigned long high_limit;
+	unsigned long max_volt;
+	unsigned long low_temp_min_volt;
+	unsigned long high_temp_max_volt;
+	unsigned int video_4k_freq;
+	unsigned int reboot_freq;
+	unsigned int init_freq;
+	unsigned int status_min_limit;
+	unsigned int status_max_limit;
+	unsigned int early_min_volt;
+	unsigned int regulator_count;
+	int low_temp;
+	int high_temp;
+	int temp_hysteresis;
+	bool is_low_temp;
+	bool is_high_temp;
+	bool is_low_temp_enabled;
+};
+
+struct monitor_dev_profile {
+	enum monitor_dev_type type;
+	void *data;
+	bool is_checked;
+	int (*low_temp_adjust)(struct monitor_dev_info *info, bool is_low);
+	int (*high_temp_adjust)(struct monitor_dev_info *info, bool is_low);
+	int (*update_volt)(struct monitor_dev_info *info);
+	int (*set_opp)(struct dev_pm_set_opp_data *data);
+	struct cpumask allowed_cpus;
+	struct rockchip_opp_info *opp_info;
+};
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_SYSTEM_MONITOR)
+struct monitor_dev_info *
+rockchip_system_monitor_register(struct device *dev,
+				 struct monitor_dev_profile *devp);
+void rockchip_system_monitor_unregister(struct monitor_dev_info *info);
+int rockchip_monitor_cpu_low_temp_adjust(struct monitor_dev_info *info,
+					 bool is_low);
+int rockchip_monitor_cpu_high_temp_adjust(struct monitor_dev_info *info,
+					  bool is_high);
+void rockchip_monitor_volt_adjust_lock(struct monitor_dev_info *info);
+void rockchip_monitor_volt_adjust_unlock(struct monitor_dev_info *info);
+int rockchip_monitor_check_rate_volt(struct monitor_dev_info *info);
+int rockchip_monitor_dev_low_temp_adjust(struct monitor_dev_info *info,
+					 bool is_low);
+int rockchip_monitor_dev_high_temp_adjust(struct monitor_dev_info *info,
+					  bool is_high);
+int rockchip_monitor_suspend_low_temp_adjust(int cpu);
+#else
+static inline struct monitor_dev_info *
+rockchip_system_monitor_register(struct device *dev,
+				 struct monitor_dev_profile *devp)
+{
+	return ERR_PTR(-ENOTSUPP);
+};
+
+static inline void
+rockchip_system_monitor_unregister(struct monitor_dev_info *info)
+{
+}
+
+static inline int
+rockchip_monitor_cpu_low_temp_adjust(struct monitor_dev_info *info, bool is_low)
+{
+	return 0;
+};
+
+static inline int
+rockchip_monitor_cpu_high_temp_adjust(struct monitor_dev_info *info,
+				      bool is_high)
+{
+	return 0;
+};
+
+static inline void
+rockchip_monitor_volt_adjust_lock(struct monitor_dev_info *info)
+{
+}
+
+static inline void
+rockchip_monitor_volt_adjust_unlock(struct monitor_dev_info *info)
+{
+}
+
+static inline int
+rockchip_monitor_check_rate_volt(struct monitor_dev_info *info)
+{
+	return 0;
+}
+
+static inline int
+rockchip_monitor_dev_low_temp_adjust(struct monitor_dev_info *info, bool is_low)
+{
+	return 0;
+};
+
+static inline int
+rockchip_monitor_dev_high_temp_adjust(struct monitor_dev_info *info,
+				      bool is_high)
+{
+	return 0;
+};
+
+static inline int rockchip_monitor_suspend_low_temp_adjust(int cpu)
+{
+	return 0;
+};
+
+#endif /* CONFIG_ROCKCHIP_SYSTEM_MONITOR */
+
+#endif
diff --git a/kernel/dma/pool.c b/kernel/dma/pool.c
index 6af7ecc9a14..4d40dcce760 100644
--- a/kernel/dma/pool.c
+++ b/kernel/dma/pool.c
@@ -189,11 +189,13 @@ static int __init dma_atomic_pool_init(void)
 	int ret = 0;
 
 	/*
-	 * Always use 2MiB as default pool size.
-	 * See: https://forum.armbian.com/topic/4811-uas-mainline-kernel-coherent-pool-memory-size/
+	 * If coherent_pool was not used on the command line, default the pool
+	 * sizes to 128KB per 1GB of memory, min 128KB, max MAX_ORDER-1.
 	 */
 	if (!atomic_pool_size) {
-		atomic_pool_size = SZ_2M;
+		unsigned long pages = totalram_pages() / (SZ_1G / SZ_128K);
+		pages = min_t(unsigned long, pages, MAX_ORDER_NR_PAGES);
+		atomic_pool_size = max_t(size_t, pages << PAGE_SHIFT, SZ_128K);
 	}
 	INIT_WORK(&atomic_pool_work, atomic_pool_work_fn);
 
diff --git a/sound/soc/rockchip/rockchip_i2s.c b/sound/soc/rockchip/rockchip_i2s.c
index a8758ad6844..2e24cc0570e 100644
--- a/sound/soc/rockchip/rockchip_i2s.c
+++ b/sound/soc/rockchip/rockchip_i2s.c
@@ -659,6 +659,7 @@ static const struct of_device_id rockchip_i2s_match[] __maybe_unused = {
 	{ .compatible = "rockchip,rk3366-i2s", },
 	{ .compatible = "rockchip,rk3368-i2s", },
 	{ .compatible = "rockchip,rk3399-i2s", .data = &rk3399_i2s_pins },
+	{ .compatible = "rockchip,rk3588-i2s", },
 	{ .compatible = "rockchip,rv1126-i2s", },
 	{},
 };
-- 
Created with Armbian build tools https://github.com/armbian/build

